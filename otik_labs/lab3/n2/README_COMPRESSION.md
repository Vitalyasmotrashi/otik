# ВАЖНО: ГДЕ СЖАТИЕ И КОДИРОВАНИЕ?

## Коротко
**В текущем коде (n2.py) сжатие и защита НЕ реализованы.**  
Это «нулевой профиль»: comp_ctx=0, comp_nctx=0, protection=0.

## Почему это нормально для Л3.№2?

Задание Л3.№2 требует:
- **Описать формат** (✅ сделано в spec_l3v2.md).
- Заложить в формат поля для кодов алгоритмов (✅ есть).
- Заложить места для служебных данных (✅ global_meta_offset/length, extra_len).
- Поддержать иерархию папок для +7 баллов (✅ реализовано).

**Само сжатие/защита реализуются в Л3.№3.**  
В spec_l3v2.md сказано:

> Для Л3.№3 допустимо реализовать только «нулевой профиль»:
> - comp_ctx = 0, comp_nctx = 0, protection = 0
> - stored_size == original_size
> - Данные — точная копия исходных байтов

Это стандартный подход: сначала определяют формат контейнера, потом добавляют
конкретные алгоритмы без изменения структуры заголовков.

## Где в коде заложены места для алгоритмов?

### 1. Заголовок архива (HDR_FMT)
```python
# Строка 47-53 в n2.py:
HDR_FMT = "<8sHHBBBBI Q I Q Q Q"
#             ...BBBB...
#               ^^^^^^^^^^^
#               comp_ctx, comp_nctx, protection, reserved
```
Эти байты сейчас заполнены нулями (строка 34-36: `COMP_CTX = 0`, `COMP_NCTX = 0`, `PROTECT = 0`).

В Л3.№3 здесь можно указать:
- comp_ctx = 1 (Arithmetic coding)
- comp_nctx = 2 (LZSS)
- protection = 1 (CRC32)

### 2. Запись TOC (ENTRY_FMT)
```python
# Строка 59-61:
ENTRY_FMT = "<HHI Q BBBB Q Q Q I Q"
#                     ^^^^
#                     comp_ctx, comp_nctx, protection, reserved per-entry
```
Каждый файл может иметь СВОЙ набор алгоритмов или наследовать глобальные (0xFF).

### 3. Служебные данные
```python
# В заголовке:
global_meta_offset  # Смещение на глобальные метаданные (таблицы частот для AC и т.п.)
global_meta_length  # Длина глобальных метаданных

# В записи TOC:
extra_len           # Длина дополнительных данных для конкретного файла
```
Сейчас все нули — в Л3.№3 здесь можно сохранять статистику для сжатия.

### 4. Где применять алгоритмы при упаковке?
**Строка 252-257 в pack():**
```python
# HERE: compression/protection hook — в Л3.№3 можно
# оборачивать поток chunk'ов в кодеры и писать уже
# преобразованные данные. Сейчас — сырые байты.
out.write(chunk)
```

**Псевдокод для Л3.№3:**
```python
# Вместо прямого out.write(chunk):
compressed_chunk = apply_comp_ctx(chunk, code=comp_ctx)  # ArithmeticCoder
compressed_chunk = apply_comp_nctx(compressed_chunk, code=comp_nctx)  # LZSS
protected_chunk = apply_protection(compressed_chunk, code=protection)  # CRC32
out.write(protected_chunk)
```

### 5. Где применять алгоритмы при распаковке?
**Строка 386-390 в unpack():**
```python
# HERE: decompression/deprotection hook — если бы были
# включены алгоритмы, здесь надо было бы прогонять chunk
# через декодер(ы). Сейчас — прямой вывод.
out.write(chunk)
```

**Псевдокод для Л3.№3:**
```python
# Вместо прямого out.write(chunk):
chunk = remove_protection(chunk, code=e['protection'])
chunk = decode_comp_nctx(chunk, code=e['comp_nctx'])
chunk = decode_comp_ctx(chunk, code=e['comp_ctx'])
out.write(chunk)
```

## Как работает «композиция алгоритмов сжатия»?

Из задания (скриншот):
> коды используемых алгоритмов сжатия и защиты от помех (с учётом того,
> что сжатие без учёта контекста применяется поверх сжатия с его учётом —
> кодов алгоритма сжатия будет два)

**Порядок при упаковке:**
1. Сырые данные → **comp_ctx** (Arithmetic/Range, с учётом контекста)
2. → **comp_nctx** (RLE/LZSS, без учёта контекста, поверх первого)
3. → **protection** (CRC32/SHA256, самый внешний слой)
4. → запись в архив

**Порядок при распаковке (обратный):**
1. Читаем из архива
2. → снимаем **protection**
3. → декодируем **comp_nctx**
4. → декодируем **comp_ctx**
5. → получаем исходные данные

## Что сейчас делает код?

**При упаковке (pack):**
- Сканирует дерево папок.
- Формирует TOC с путями, правами, mtime.
- Записывает заголовок с кодами 0/0/0.
- **Копирует файлы БЕЗ ИЗМЕНЕНИЙ** → stored_size == original_size.

**При распаковке (unpack):**
- Читает заголовок и TOC.
- Проверяет сигнатуру/версию.
- Создаёт каталоги с правильной иерархией.
- **Копирует данные БЕЗ ИЗМЕНЕНИЙ**.

## Итог

**Текущий код:**
- ✅ Формат полностью описан и реализован.
- ✅ Иерархия папок работает (+7 баллов).
- ✅ Места для алгоритмов заложены.
- ❌ Само сжатие/защита пока отсутствуют (код 0 = нет алгоритма).

**Для Л3.№3:**
- Добавить функции: `encode_arithmetic()`, `encode_lzss()`, `crc32_append()`.
- Вставить их вызовы в помеченные места (строки 252-257, 386-390).
- Сохранять служебные данные (таблицы частот) в global_meta/extra.
- Обновить stored_size с учётом реального сжатого размера.

**Л3.№2 выполнено полностью:**
- Формат описан.
- Код работает.
- Иерархия папок поддерживается.
- Сжатие можно добавить позже без изменения формата.
