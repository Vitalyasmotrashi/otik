# Назначение и обзор формата

Программа — это CLI‑кодек для пользовательского архива OTIK v2, который сохраняет полную иерархию папок, права, времена изменения и данные файлов. Команды:
- **pack:** собрать архив из каталога с сохранением структуры.
- **unpack:** восстановить каталог из архива.

Архив имеет фиксированный бинарный заголовок, затем таблицу содержимого (TOC) с записями для каждого каталога и файла, блок выравнивания до 8 байт и пул данных файлов (payload).

---

# Структура архива

## Заголовок (56 байт)
- **Сигнатура:** `b"SOBSTV02"` — 8 байт, проверка типа архива.
- **Версия:** major=2, minor=0 — контроль совместимости.
- **Глобальные коды алгоритмов:** comp_ctx, comp_nctx, protection — сейчас 0 (профиль “без сжатия/шифрования”), но архитектурно предусмотрены.
- **Служебные поля:** reserved — 1 байт.
- **Счетчики и смещения:**
  - **toc_entries:** количество записей TOC.
  - **global_meta_offset/length:** место для будущих глобальных метаданных (сейчас 0).
  - **toc_offset:** смещение TOC (сразу после заголовка).
  - **data_offset:** начало области данных файлов (после TOC с выравниванием на 8).
  - **total_original_size:** сумма исходных размеров всех файлов.

Формат пакуется/распакуется через `struct.pack/unpack` по схеме `HDR_FMT = "<8sHHBBBBI Q I Q Q Q"` (little‑endian).

## Запись TOC (на каждый путь)
- **Фиксированная часть:** `ENTRY_FMT = "<HHI Q BBBB Q Q Q I Q"`
  - **path_len:** длина UTF‑8 строки пути.
  - **flags:** каталог или файл (битовые флаги: `FLAG_DIR=0x1`, `FLAG_FILE=0x2`).
  - **mode:** POSIX‑права (нижние 12 бит `st_mode`).
  - **mtime:** время изменения (целые секунды, `int`).
  - **comp_ctx/nctx/protection/reserved:** локальные коды алгоритмов (0xFF означает “наследовать из заголовка”).
  - **original_size:** исходный размер (для каталога 0).
  - **stored_size:** сохранённый размер (в профиле 0 совпадает с original_size).
  - **data_offset:** смещение данных файла в пуле payload (для каталога 0).
  - **extra_len:** длина дополнительной секции (сейчас 0).
  - **entry_id:** задел для идентификатора (сейчас 0).
- **Путь:** сразу после фиксированной части записывается UTF‑8 путь длиной `path_len`. Для каталогов — с завершающим `/` (кроме корня), для файлов — без `/`.

---

# Как работает pack

## Сканирование дерева и сбор записей
- **Каталоги:** для каждого создаётся запись с путём вида `"dir/subdir/"`, правами и mtime, размер=0.
- **Файлы:** запись с путём `"dir/file.ext"`, правами, mtime и размером файла.
- **Корень:** вставляется запись с пустым путём `''` как маркер корневой директории, чтобы при распаковке корректно создать `out_dir` и применить метаданные.

## Расчёт макета архива
- **toc_entries:** количество записей.
- **total_original_size:** сумма размеров всех файлов.
- **toc_size:** суммарный размер всех записей TOC + путей.
- **Выравнивание:** `toc_size_aligned = _align(toc_size, 8)` — TOC подгоняется до кратности 8.
- **Смещения:** `toc_offset = HDR_SIZE`, `data_offset = HDR_SIZE + toc_size_aligned`.

## Назначение смещений данных
- **Итерируем файлы:** для каждого файла курсор выравнивается к 8 байтам, поле `data_offset` ставится на курсор, `stored_size` = `size`, курсор увеличивается на размер.
- **Каталоги:** `stored_size = 0`, `data_offset = 0`.

## Запись в архив
- **Заголовок:** пишется по `HDR_FMT`.
- **TOC:** на каждую запись — фиксированная часть + UTF‑8 путь; локальные comp/protect ставятся как 0xFF (“наследовать”).
- **Паддинг:** после TOC добивается нулями до ближайшего `ALIGN=8`.
- **Payload:** потоковая запись данных файлов. Перед каждым файлом, если текущая позиция меньше `data_offset`, добиваем нулями до `data_offset`. Если больше — ошибка макета (защита от расхождений расчётов).

Итог: архив сохраняет полную иерархию, права, mtime, и раскладывает данные файлов строго по рассчитанным смещениям.

---

# Как работает unpack

## Чтение заголовка и проверка
- **Читается HDR_SIZE:** проверка длины, сигнатуры и версии major.
- **Сохраняются глобальные поля:** comp/protect и смещения.

## Чтение TOC
- **Seek к toc_off:** читаем `toc_entries` записей: фиксированная часть + `path_len` байт пути.
- **Интерпретация флагов:** `is_dir` по `FLAG_DIR`.
- **Наследование алгоритмов:** если в записи 0xFF, берём из заголовка, иначе локальный код.

## Восстановление каталогов
- **Итерация по записям каталогов:** создаём директории, включая корень `''`, через `_safe_join`:
  - **Защита от traversal:** запрещены абсолютные пути и выход через `..`.
- **Метаданные:** пытаемся применить `chmod` и `utime` (игнорируем ошибки прав).

## Восстановление файлов
- **Итерация по файлам:** готовим путь (с безопасным join), создаём родительские каталоги.
- **Seek к data_offset:** читаем ровно `stored_size`.
- **Пишем потоково:** кусками по 1 МБ; ошибка при неожиданном EOF.
- **Метаданные:** `chmod` и `utime` на восстановленный файл.

---

# Важные детали, ограничения и расширяемость

- **Сохранение структуры:** да, архив сохраняет иерархию папок, права, и времена; корневой пустой путь — маркер.
- **Без сжатия/шифрования:** профиль 0/0/0 — данные копируются “как есть”. Поля comp/protection заложены под будущие алгоритмы.
- **Выравнивание:** все важные блоки выровнены к 8 байтам — удобно для DMA/блоковых алгоритмов и упрощает навигацию.
- **Без глобальных метаданных:** поля для них есть, но сейчас не используются.
- **Без контрольных сумм:** нет хешей/CRC — целостность не проверяется при распаковке, кроме базовых длин и EOF.
- **Без символических ссылок/спецфайлов:** права сохраняются, но типы вроде symlink/char/block явно не сериализуются; обрабатываются как обычные файлы/директории.
- **Безобидная обработка ошибок прав:** `chmod` может упасть — игнорируется (полезно на Windows).

---

# Как запускать

- **Упаковка:**
  - Команда: `n2.py pack <root_dir> <archive>`
  - Пример: `n2.py pack ./project ./project.otik`
- **Распаковка:**
  - Команда: `n2.py unpack <archive> <out_dir>`
  - Пример: `n2.py unpack ./project.otik ./restore`

Если хочешь, добавлю в формат контрольные суммы и поддержку сжатия (например, LZ4/ZSTD), чтобы `stored_size` отличался от `original_size`, и распаковка включала декодирование и верификацию.