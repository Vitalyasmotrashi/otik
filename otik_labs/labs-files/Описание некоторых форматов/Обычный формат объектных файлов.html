<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<html><head>
   <meta http-equiv="Content-Type" content="text/html; charset=KOI8-R">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Unix">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="unix">

<title>Обычный формат объектных файлов</title>
<!--                                                                   -->
</head>

<body background="%D0%9E%D0%B1%D1%8B%D1%87%D0%BD%D1%8B%D0%B9%20%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D1%85%20%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2_files/iip_1.jpg">
<p>
</p><table cellpadding="10">
<tbody><tr><td><a href="http://khpi-iip.mipk.kharkiv.edu/library/index.htm">Каталог</a></td><td><a href="http://khpi-iip.mipk.kharkiv.edu/library/extent/os/index.htm">Индекс раздела</a></td><td></td></tr>
</tbody></table>
<table cellpadding="10">
<tbody><tr><td><a href="http://khpi-iip.mipk.kharkiv.edu/library/extent/os/ruprog/p05.html">Назад</a></td><td><a href="http://khpi-iip.mipk.kharkiv.edu/library/extent/os/ruprog/index.html">Оглавление</a></td><td><a href="http://khpi-iip.mipk.kharkiv.edu/library/extent/os/ruprog/p07.html">Вперед</a></td></tr>
</tbody></table>
<p></p>
<hr>
<h1>Обычный формат объектных файлов</h1>


<h4>СОДЕРЖАНИЕ</h4>

<p><a href="#01">1. Введение</a>

</p><p><a href="#02">2. Определения и соглашения</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#02_01">2.1. Секции</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#02_02">2.2. Физические и виртуальные адреса</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#02_03">2.3. Целевой компьютер</a>

</p><p><a href="#03">3. Заголовок файла</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#03_01">3.1. Магическое число</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#03_02">3.2. Флаги</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#03_03">3.3. Описание заголовка файла</a>

</p><p><a href="#04">4. Вспомогательный заголовок системы UNIX</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#04_01">4.1. a.out - стандартный заголовок системы UNIX</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#04_02">4.2. Описание вспомогательного заголовка</a>

</p><p><a href="#05">5. Заголовки секций</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#05_01">5.1. Флаги</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#05_02">5.2. Описание заголовка секции</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#05_03">5.3. Заголовок секции неинициализированных данных</a>

</p><p><a href="#06">6. Секции</a>

</p><p><a href="#07">7. Информация о настройке ссылок</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#07_01">7.1. Описание элемента таблицы настройки ссылок</a>

</p><p><a href="#08">8. Информация о номерах строк</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#08_01">8.1. Описание элемента таблицы номеров строк</a>

</p><p><a href="#09">9. Таблица имен</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_01">9.1. Специальные имена</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_02">9.2. Внутренние блоки</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_03">9.3. Имена и функции</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_04">9.4. Элементы таблицы имен</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_04_01">9.4.1. Тексты имен</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_04_02">9.4.2. Классы памяти</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_04_03">9.4.3. Классы памяти специальных имен</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_04_04">9.4.4. Поле значения имени</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_04_05">9.4.5. Поле номера секции</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_04_06">9.4.6. Номера секций и классы памяти</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_04_07">9.4.7. Поле типа</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_04_08">9.4.8. Связь между типом и классом памяти</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_04_09">9.4.9. Описание элемента таблицы имен</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_05">9.5. Вспомогательные элементы таблицы имен</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_05_01">9.5.1. Имя файла</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_05_02">9.5.2. Секция</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_05_03">9.5.3. Начало структуры, объединения или перечисления</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_05_04">9.5.4. Конец структуры</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_05_05">9.5.5. Функция</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_05_06">9.5.6. Массив</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_05_07">9.5.7. Конец блока или функции</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_05_08">9.5.8. Начало блока или функции</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_05_09">9.5.9. Имена, связанные со структурой, объединением или перечислением</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#09_05_10">9.5.10. Описание вспомогательного элемента</a>

</p><p><a href="#10">10. Таблица цепочек</a>

</p><p><a href="#11">11. Программы доступа к объектным файлам обычного формата</a>

</p><hr>

<p>&nbsp;</p>
<a name="01">
<h2>1. ВВЕДЕНИЕ</h2>

<p>Ниже описывается обычный формат объектных файлов (common object
file format, COFF), принятый в ОС UNIX. Ассемблер, 
<samp><i>as</i></samp>(1), и редактор  внешних связей, 
<samp><i>ld</i></samp>(1), генерируют объектные файлы обычного формата.

</p><p>Основные особенности этого формата таковы:
</p><ul>
        <li>В  объектные  файлы можно добавлять свою информацию, не
        нарушая работоспособности стандартных средств обработки
        подобных файлов.

        </li><li>Отведено место для отладочной информации.

        </li><li>Можно влиять на способ создания объектных  файлов,  используя директивы времени компиляции.
</li></ul>

<p>Объектный файл поддерживает определяемые пользователем секции и
содержит избыточную информацию, необходимую для работы символьных 
отладчиков. Объектный файл содержит:
</p><ul>
<li>Заголовок файла.

        </li><li>Вспомогательный заголовок системы UNIX.

        </li><li>Таблицу заголовков секций.

        </li><li>Содержимое соответствующих секций.

        </li><li>Информацию о настройке ссылок.

        </li><li>Информацию о номерах строк.

        </li><li>Таблицу имен.

        </li><li>Таблицу цепочек.
</li></ul>

<p>Общая структура объектного файла обычного формата  приведена  в
следующей таблице:

</p><p></p><table align="center" border="">
<tbody><tr><td align="center">ЗАГОЛОВОК ФАЙЛА    
</td></tr><tr>
<td align="center">Вспомогательный заголовок системы UNIX 
</td></tr><tr>
<td align="center">Заголовок секции 1    
</td></tr><tr>
<td align="center"><samp>. . .     </samp>
</td></tr><tr>
<td align="center">Заголовок секции n    
</td></tr><tr>
<td align="center">Содержимое секции 1    
</td></tr><tr>
<td align="center"><samp>. . .     </samp>
</td></tr><tr>
<td align="center">Содержимое секции 1    
</td></tr><tr>
<td align="center">Информация о настройке ссылок секции 1 
</td></tr><tr>
<td align="center"><samp>. . .     </samp>
</td></tr><tr>
<td align="center">Информация о настройке ссылок секции n 
</td></tr><tr>
<td align="center">Информация о номерах строк секции 1  
</td></tr><tr>
<td align="center"><samp>. . .     </samp>
</td></tr><tr>
<td align="center">Информация о номерах строк секции n  
</td></tr><tr>
<td align="center">ТАБЛИЦА ИМЕН     
</td></tr><tr>
<td align="center">ТАБЛИЦА ЦЕПОЧЕК    
</td></tr></tbody></table>

<p>Последние четыре части (информация о настройке ссылок, информация о 
номерах строк, таблица имен и таблица цепочек) могут отсутствовать, если 
внешние связи редактировались с помощью команды <samp>ld -s</samp>, 
или если таблицы номеров строк, имен и цепочек были удалены командой 
<samp><i>strip</i></samp>(1). Информация о номерах строк генерируется только по 
командам <samp>cc -g</samp> или <samp>svs +d</samp>. Кроме того, если
после  редактирования  связей не осталось неразрешенных внешних
ссылок, то информация о настройке отсутствует за ненадобностью.
Таблица цепочек отсутствует, если исходный  текст  не  содержит
имен, длина которых больше 8 символов.

</p><p>Выполняемым  считается объектный файл, не содержащий ошибок или
неразрешенных внешних ссылок.

</p><p>&nbsp;</p>
</a><a name="02">
<h2>2. ОПРЕДЕЛЕНИЯ И СОГЛАШЕНИЯ</h2>

</a><p><a name="02">Дадим определения и оговорим соглашения, которые будут  использоваться в дальнейшем изложении.

</a><a name="02_01">
</a></p><h3><a name="02_01">2.1. Секции</a></h3><a name="02_01">

<p>Секция  есть наименьшая часть объектного файла, которая подвергается 
перемещению и рассматривается как нечто отдельное и различимое. Как правило, 
в объектном файле присутствуют  три  секции,  именуемые <samp>.text</samp>, 
<samp>.data</samp> и <samp>.bss</samp>. 
Это секции команд, инициализированных и неинициализированных данных.  В  
других  секциях
могут размещаться комментарии, дополнительные сегменты команд и
данных,  разделяемые сегменты данных. Допускаются секции, определенные 
пользователем. Однако в любом случае ОС UNIX при  загрузке  файла  на  
выполнение  помещает  в  память только секции
<samp>.text</samp>, <samp>.data</samp> и <samp>.bss</samp>.

</p><p><u>Примечание</u>
</p><dir>
        Было бы ошибкой думать, что каждый объектный файл обычного 
формата  имеет  какое-то  определенное  количество
        секций.  Неправильно  было  бы также полагать заданными
        такие характеристики файла, как порядок секций, их расположение в
 файле или адрес, по которому они будут загружены. Подобная информация 
может  быть  получена  лишь
        после создания объектного файла. Если программы обрабатывают  
объектные файлы обычного формата, то они должны
        извлекать эту информацию из заголовков файла и входящих
        в него секций.
</dir>

</a><a name="02_02">
<h3>2.2. Физические и виртуальные адреса</h3>

</a><p><a name="02_02">Физический адрес секции или имени есть смещение этой секции или
данных,  соответствующих этому имени, от начала (нулевого адреса) 
адресного пространства. Значение термина физический  адрес,
когда  он  используется  для описания объектных файлов обычного
формата, отличается от общепринятого. Физический адрес  объекта
не обязательно будет совпадать с адресом, по которому этот объект 
будет помещен во время выполнения. Так, в системах со страничной  
виртуальной памятью адрес берется относительно нулевого
адреса виртуальной памяти, после чего операционная система  выполняет  
дальнейшее преобразование адреса. Заголовок секции содержит 
два адресных поля, для физического и виртуального  
адресов;  однако  во всех версиях COFF-формата и ОС UNIX эти адреса
совпадают.

</a><a name="02_03">
</a></p><h3><a name="02_03">2.3. Целевой компьютер</a></h3><a name="02_03">

<p>Компиляторы и редакторы внешних связей создают выполняемые объектные  
файлы,  предназначенные  для  запуска  на  определенных
компьютерах.  В случае использования кросс-компиляторов, на одном 
компьютере компилируются и редактируются  объектные  файлы,
предназначенные для выполнения на другом компьютере. Термин целевой  
компьютер обозначает тот компьютер, на котором предполагается 
выполнять объектный файл. За редким исключением  целевой
компьютер  - это в точности тот же компьютер, на котором создается 
объектный файл.



</p><p>&nbsp;</p>
</a><a name="03">
<h2>3. ЗАГОЛОВОК ФАЙЛА</h2>

<p>Заголовок файла состоит из 20 байт; его формат показан в следующей 
таблице. Последние два байта содержат флаги,  используемые
редактором  связей  ld(1)  и другими утилитами, обрабатывающими
объектные файлы.

   </p><p></p><table align="center" border=""><tbody><tr>
<td><b>Байты     </b></td>
<td><b>Описание       </b></td>
<td><b>Имя                          </b></td>
<td><b>Смысл                        </b></td>
</tr><tr>
<td>0-1  </td>
<td><samp>unsigned short</samp>  </td>
<td><samp>f_magic</samp>   </td>
<td>Магическое число                     </td>
   </tr><tr>
<td>2-3  </td>
<td><samp>unsigned short</samp>  </td>
<td><samp>f_nscns</samp>   </td>
<td>Количество секций в файле            </td>
   </tr><tr>
<td>4-7  </td>
<td><samp>long int</samp>        </td>
<td><samp>f_timdat</samp> </td>
<td>Дата/время создания файла. Выражается количеством секунд, прошедших с 00:00:00 1 января 1970г. (по Гринвичу)</td>
   </tr><tr>
<td>8-11  </td>
<td><samp>long int</samp>        </td>
<td><samp>f_symptr</samp>  </td>
<td>Указатель в файле. Содержит адрес    
начала таблицы имен                  </td>
   </tr><tr>
<td>12-15  </td>
<td><samp>long int</samp>        </td>
<td><samp>f_nsyms</samp>   </td>
<td>Число элементов в таблице имен       </td>
   </tr><tr>
<td>16-17  </td>
<td><samp>unsigned short</samp>  </td>
<td><samp>f_opthdr</samp>  </td>
<td>Размер вспомогательного заголовка    
в байтах                             </td>
   </tr><tr>
<td>18-19  </td>
<td><samp>unsigned short</samp>  </td>
<td><samp>f_flags</samp>                        </td>
<td>Флаги (см. следующую таблицу)        </td>
   </tr></tbody></table>

</a><a name="03_01">
<h3>3.1. Магическое число</h3>

</a><p><a name="03_01">Магическое  число  определяет  целевой  компьютер, для которого
предназначен объектный файл.

</a><a name="03_02">
</a></p><h3><a name="03_02">3.2. Флаги</a></h3><a name="03_02">

<p>Последние  два байта заголовка файла содержат флаги, характеризующие 
тип объектного файла.  Флаги  определены  во  включаемом
файле  <samp>&lt;filehdr.h&gt;</samp>;  используемые  флаги  приведены в следующей
таблице:

    </p><p></p><table align="center" border="">
     <tbody><tr><td><b>Обозначение  </b></td>
<td><b>Значение                    </b></td> 
<td><b>Смысл                       </b></td>
    </tr><tr>
     <td><samp>F_RELFLG</samp>       </td>
<td align="center">00001   </td>
<td>Из файла удалена информация о настройке ссылок </td>
    </tr><tr>
     <td><samp>F_EXEC</samp>         </td>
<td align="center">00002   </td>
<td>Файл является выполняемым (в нем нет           
неразрешенных внешних ссылок)                  </td>
    </tr><tr>
     <td><samp>F_LNNO</samp>         </td>
<td align="center">00004   </td>
<td>Из файла удалена информация о номерах строк    </td>
    </tr><tr>
     <td><samp>F_LSYMS</samp>        </td>
<td align="center">00010   </td>
<td>Из файла удалена информация о локальных именах </td>
    </tr><tr>
     <td><samp>F_AR32W</samp>      </td>
<td align="center">0001000   </td>
<td>32-битное слово                                </td>
    </tr></tbody></table>

</a><a name="03_03">
<h3>3.3. Описание заголовка файла</h3>

<p>Ниже  приведено описание C-структуры, соответствующей заголовку
файла. Для включения описания в программу следует  использовать
файл <samp>&lt;filehdr.h&gt;</samp>.
</p><pre>       struct filehdr {
         unsigned short f_magic;  /* Магическое число */
         unsigned short f_nscns;  /* Количество секций */
         long           f_timdat; /* Время и дата создания */
         long           f_symptr; /* Указатель в файле на
                                     таблицу имен */
         long           f_nsyms;  /* Число элементов в таблице
                                     имен */
         unsigned short f_opthdr; /* Размер вспомогательного
                                     заголовка */
         unsigned short f_flags;  /* Флаги */
       };
       
       #define FILHDR  struct filehdr
       #define FILHSZ  sizeof (FILHDR)
</pre>

<p>&nbsp;</p>
</a><a name="04">
<h2>4. ВСПОМОГАТЕЛЬНЫЙ ЗАГОЛОВОК СИСТЕМЫ UNIX</h2>

</a><p><a name="04">Структура  вспомогательного заголовка файла зависит от конкретной 
системы, использующей обычный формат объектных  файлов.  Во
вспомогательный  заголовок  помещается вся зависящая от системы
информация, что дает возможность различным операционным  системам  
получать  доступ к только им необходимым данным, без того,
чтобы в каждом объектном файле обычного формата для каждой операционной 
системы отводить место для таких данных.  Утилиты общего 
назначения (например, дизассемблер, функции, работающие  с
таблицей  имен,  и т.д.) реализованы так, чтобы обеспечить правильную 
работу с любым объектным файлом.  Это  достигается  использованием 
информации, расположенной за вспомогательным заголовком,  длина 
которого хранится в поле <samp>f_opthdr</samp> заголовка файла.

</a><a name="04_01">
</a></p><h3><a name="04_01">4.1. a.out - стандартный заголовок системы UNIX</a></h3><a name="04_01">

<p>По умолчанию, вспомогательный заголовок файлов, создаваемых редактором  
внешних связей системы UNIX, имеет стандартную структуру файлов <samp>a.out</samp>. 
Размер этой структуры - 28 байт. Поля  вспомогательного заголовка описаны в следующей таблице:

</p><p></p><table align="center" border="">
<tbody><tr>
  <td><b>Байты</b></td>
  <td><b>Описание</b></td>
  <td><b>Имя</b></td>
  <td><b>Смысл</b></td>           
</tr>
<tr>
  <td>0-1</td>
  <td><samp>short</samp></td>
  <td><samp>magic</samp></td>
  <td>Магическое число</td>
</tr>
<tr>
<td>2-3</td>
<td><samp>short</samp></td>
<td><samp>vstamp</samp></td>
<td>Метка версии</td>
</tr><tr>
<td>4-7</td>
<td><samp>long int</samp></td>
<td><samp>tsize</samp></td>
<td>Размер секции команд в байтах</td>
</tr><tr>
<td>8-11</td>
<td><samp>long int</samp></td>
<td><samp>dsize</samp></td>
<td>Размер секции инициализированных данных в байтах</td>
</tr><tr>
<td>12-15</td>
<td><samp>long int</samp></td>
<td><samp>bsize</samp></td>
<td>Размер секции неинициализированных данных в байтах</td>
</tr><tr>
<td>16-19</td>
<td><samp>long int</samp></td>
<td><samp>entry</samp></td>
<td>Точка входа</td>
</tr><tr>
<td>20-23</td>
<td><samp>long int</samp></td>
<td><samp>text_start</samp></td>
<td>Адрес начала команд</td>
</tr><tr>
<td>24-27</td>
<td><samp>long int</samp></td>
<td><samp>data_start</samp></td>
<td>Адрес начала данных</td>
</tr></tbody></table>

<p>В то время как магическое число в заголовке файла указывает целевой  
компьютер, магическое число во вспомогательном заголовке
содержит информацию о том, как  операционная  система  на  этом
компьютере  должна выполнять файл. В следующей таблице показаны
магические числа, распознаваемые ОС UNIX.

            </p><p></p><table align="center" border="">
             <tbody><tr><td><b>Значение</b></td>                <td><b>Смысл</b></td>                      
            </tr><tr>
               <td>0410</td>    
<td>Данные располагаются с границы сегмента, 
следующего за сегментом текста.          
Сегмент текста защищен от записи</td></tr>
            </tbody></table>

</a><a name="04_02">
<h3>4.2. Описание вспомогательного заголовка</h3>

<p>Ниже приведено описание C-структуры, соответствующей  заголовку
файла <samp>a.out</samp>. Такая структура вспомогательного заголовка 
используется  в настоящее время системой UNIX. Для включения описания
в программу следует использовать файл <samp>&lt;aouthdr.h&gt;</samp>.
</p><pre>       typedef struct aouthdr {
         short magic;       /* Магическое число */
         short vstamp;      /* Метка версии */
         long  tsize;       /* Размер сегмента команд в байтах
                               */
         long  dsize;       /* Размер секции .data (инициали-
                               зированные данные) */
         long  bsize;       /* Размер секции .bss (неинициали-
                               зированные данные) */
         long  entry;       /* Точка входа */
         long  text_start;  /* Адрес, с которого размещается
                               сегмент команд */
         long  data_start;  /* Адрес, с которого размещается
                               сегмент данных */
       } AOUTHDR;
</pre>

<p>&nbsp;</p>
</a><a name="05">
<h2>5. ЗАГОЛОВКИ СЕКЦИЙ</h2>

<p>В  каждом объектном файле есть таблица заголовков секций, определяющая 
расположение данных в файле.  В  этой  таблице  каждой
секции  соответствует один элемент. В следующей таблице описана
информация, содержащаяся в заголовке секции.

     </p><p></p><table align="center" border="">
      <tbody><tr><td><b>Байты</b></td>     
<td><b>Описание</b></td>        
<td><b>Имя</b></td>                
<td><b>Смысл</b></td>
     </tr><tr>
        <td>0-7  </td>
<td><samp>char</samp>            </td>
<td><samp>s_name</samp>  </td>   
<td>8-символьное имя секции,        
дополненное нулями   </td>           
     </tr><tr>
       <td>8-11  </td>
<td><samp>long int</samp>       </td> 
<td><samp>s_paddr</samp>    </td>
<td>Физический адрес секции         </td>
     </tr><tr>
      <td>12-15  </td>
<td><samp>long int</samp>        </td>
<td><samp>s_vaddr</samp>    </td>
<td>Виртуальный адрес секции        </td>
     </tr><tr>
      <td>16-19  </td>
<td><samp>long int</samp>        </td>
<td><samp>s_size</samp>     </td>
<td>Размер секции в байтах      </td>    
     </tr><tr>
      <td>20-23  </td>
<td><samp>long int</samp>        </td>
<td><samp>s_scnptr</samp>   </td>
<td>Указатель в файле на содержимое 
секции                            </td>
     </tr><tr>
      <td>24-27  </td>
<td><samp>long int</samp></td>        
<td><samp>s_relptr</samp>    </td>
<td>Указатель в файле на информацию 
о настройке ссылок           </td>   
     </tr><tr>
      <td>28-31  </td>
<td><samp>long int</samp>        </td>
<td><samp>s_lnnoptr</samp>           </td>
<td>Указатель в файле на информацию 
о номерах строк                 </td>
     </tr><tr>
      <td>32-33  </td>
<td><samp>unsigned short</samp> </td> 
<td><samp>s_nreloc</samp>   </td>
<td>Число элементов в таблице       
настройки ссылок                </td>
     </tr><tr>
      <td>34-35  </td>
<td><samp>unsigned short</samp> </td> 
<td><samp>s_nlnno</samp>    </td>
<td>Число элементов в таблице       
номеров строк                   </td>
     </tr><tr>
      <td>36-39  </td>
<td><samp>long int</samp>        </td>
<td><samp>s_flags</samp>    </td>
<td>Флаги (см. следующую таблицу)   </td>
     </tr></tbody></table>

</a><p><a name="05">Размер секции увеличивается до ближайшего числа, кратного четырем. 
Указатели в файле - это смещения в байтах, позволяющие определить 
начало данных в этой секции и ее таблиц настройки ссылок  
и  номеров  строк. Указатели могут использоваться функцией
<samp><i>fseek</i></samp>(3S) операционной системы UNIX.

</a><a name="05_01">
</a></p><h3><a name="05_01">5.1. Флаги</a></h3><a name="05_01">

<p>Два младших байта поля флагов определяют тип секции. Флаги описаны 
в следующей таблице:

 </p><p></p><table align="center" border="">
<tbody><tr><td><b>Обозначение  </b></td>
<td><b>Значение   </b></td>
<td><b>Смысл               </b></td>              
 </tr><tr>
  <td><samp>STYP_REG</samp>       </td>
<td>0x00    </td>
<td>Обычная секция (размещаемая, настраиваемая,          
                         загружаемая)  </td>                                       
 </tr><tr>
  <td><samp>STYP_DSECT</samp>     </td>
<td>0x01    </td>
<td>Фиктивная секция (неразмещаемая, настраиваемая,      
                         незагружаемая)</td>                                       
 </tr><tr>
  <td><samp>STYP_NOLOAD</samp>    </td>
<td>0x02    </td>
<td>Незагружаемая секция (размещаемая, настраиваемая,    
                         незагружаемая)</td>                                       
 </tr><tr>
  <td><samp>STYP_GROUP</samp>     </td>
<td>0x04    </td>
<td>Групповая секция (формируется из входных секций)     </td>
 </tr><tr>
  <td><samp>STYP_PAD</samp>       </td>
<td>0x08    </td>
<td>Секция-заполнитель (неразмещаемая, ненастраиваемая,  
                         загружаемая)  </td>                                       
 </tr><tr>
  <td><samp>STYP_COPY</samp>      </td>
<td>0x10    </td>
<td>Секция типа <samp>COPY</samp> (рабочий признак для редактора      
                         связей; неразмещаемая, ненастраиваемая,              
                         загружаемая; таблицы настройки ссылок и              
                         номеров строк обрабатываются обычным образом)</td>
 </tr><tr>
  <td><samp>STYP_TEXT</samp>      </td>
<td>0x20    </td>
<td>Секция содержит выполняемые команды                  </td>
 </tr><tr>
  <td><samp>STYP_DATA</samp>      </td>
<td>0x40    </td>
<td>Секция содержит инициализированные данные            </td>
 </tr><tr>
  <td><samp>STYP_BSS</samp>       </td>
<td>0x80    </td>
<td>Секция содержит только неинициализированные данные   </td>
 </tr><tr>
  <td><samp>STYP_INFO</samp>      </td>
<td>0x200   </td>
<td>Секция комментариев (неразмещаемая, ненастраиваемая, 
                         незагружаемая)</td>                                       
 </tr><tr>
  <td><samp>STYP_OVER</samp>      </td>
<td>0x400   </td>
<td>Оверлейная секция (неразмещаемая, настраиваемая,     
                         незагружаемая)</td>                                       
 </tr><tr>
  <td><samp>STYP_LIB</samp>       </td>
<td>0x800   </td>
<td>Библиотечная секция <samp>.lib</samp> (обрабатывается так же,     
                         как секция комментариев)</td>                             
</tr> </tbody></table>

</a><a name="05_02">
<h3>5.2. Описание заголовка секции</h3>

<p>Ниже  приведено описание C-структуры, соответствующей заголовку
секции. Для включения описания в программу следует использовать
файл <samp>&lt;scnhdr.h&gt;</samp>.
</p><pre>       struct scnhdr {
         char           s_name[8]; /* Имя секции */
         long           s_paddr;   /* Физический адрес */
         long           s_vaddr;   /* Виртуальный адрес */
         long           s_size;    /* Размер секции */
         long           s_scnptr;  /* Указатель в файле на
                                      содержимое секции */
         long           s_relptr;  /* Указатель в файле на
                                      инф. о настр. ссылок */
         long           s_lnnoptr; /* Указатель в файле на
                                      инф. о номерах строк */
         unsigned short s_nreloc;  /* Число ссылок, требующих
                                      настройки */
         unsigned short s_nlnno;   /* Число элементов в таблице
                                      номеров строк */
                           как секция комментариев)                             
</pre>


</a><a name="05_03">
<h3>5.3. Заголовок секции неинициализированных данных</h3>

<p>Единственным отклонением от обычной структуры таблицы  заголовков  
секций  является заголовок для секции неинициализированных
данных <samp>.bss</samp>. Секция <samp>.bss</samp> имеет 
размер, с ней связаны имена, которые ссылаются на нее, и 
имена, которые определены в ней. В то
же время информация о настройке ссылок, таблица номеров строк и
содержимое отсутствуют. Таким образом, секции <samp>.bss</samp> 
соответствует элемент таблицы заголовков секций, но сама она  не  занимает
места  где-либо  еще  в файле. В заголовке секции <samp>.bss</samp> значения
числа элементов в таблицах настройки ссылок и номеров строк,  а
также  значения  всех  указателей равны нулю. То же верно и для
секций типа <samp>STYP_NOLOAD</samp> и <samp>STYP_DSECT</samp>.


</p><p>&nbsp;</p>
</a><a name="06">
<h2>6. СЕКЦИИ</h2>

<p>В  объектном файле обычного формата за таблицей заголовков секций 
следует содержимое секций - соответствующее количество байт команд 
или данных. Содержимое начинается с границы, кратной четырем байтам.

</p><p>Предложение <samp>SECTIONS</samp> управляющего языка редактора  связей  (см.
Руководство  по редактору связей) предоставляет, помимо прочих,
следующие возможности:
</p><ul>
        <li>Определять, как надлежит компоновать входные секции.

        </li><li>Управлять расположением выходных секций.

        </li><li>Переименовывать выходные секции.
</li></ul>

<p>Если предложения <samp>SECTIONS</samp> отсутствуют,  каждая  входная  секция
размещается в одноименной выходной. Например, если редактируются  
связи  набора объектных файлов, в каждом из которых имеется
секция  <samp>.text</samp>,  то  выходной  объектный  файл  будет  содержать
единственную  секцию <samp>.text</samp>, полученную путем объединения 
одноименных входных секций.



</p><p>&nbsp;</p>
</a><a name="07">
<h2>7. ИНФОРМАЦИЯ О НАСТРОЙКЕ ССЫЛОК</h2>

<p>Таблица настройки содержит по одному элементу для каждой ссылки
(среди команд или данных), требующей настройки. Элементы  имеют
следующий формат:

        </p><p></p><table align="center" border="">
         <tbody><tr><td><b>Байты     </b></td>
<td><b>Описание </b></td>       
<td><b>Имя               </b></td>
<td><b>Смысл                      </b></td>
        </tr><tr>
           <td>0-3  </td>
<td><samp>long int</samp></td>        
<td><samp>r_vaddr</samp>      </td>
<td>(Виртуальный) адрес ссылки     </td>
        </tr><tr>
           <td>4-7  </td>
<td><samp>long int</samp></td>        
<td><samp>r_symndx</samp>  </td>
<td>Номер в таблице имен </td>      
        </tr><tr>
           <td>8-9  </td>
<td><samp>unsigned short</samp> </td> 
<td><samp>r_type</samp>    </td>
<td>Тип ссылки </td>                
</tr>        </tbody></table>

<p>Первые  четыре байта элемента содержат виртуальный адрес ссылки
среди команд или данных. В следующем поле находится номер  (начиная 
с нуля) соответствующего элемента таблицы имен. Поле типа
ссылки определяет, как именно ее нужно настраивать. Используются 
следующие типы:

      </p><p></p><table align="center" border="">
       <tbody><tr><td><b>Обозначение  </b></td>
<td><b>Значение               </b></td>
<td><b>Смысл                         </b></td>
      </tr><tr>
       <td><samp>R_ABS</samp>            </td>
<td>0     </td>
<td>Абсолютная ссылка, настройки не требуется. 
                              Элемент игнорируется</td>                       
      </tr><tr>
       <td><samp>R_RELWORD</samp>      </td>
<td>020     </td>
<td>16-битный виртуальный адрес имени       </td>   
      </tr><tr>
       <td><samp>R_RELLONG</samp>      </td>
<td>022     </td>
<td>32-битный виртуальный адрес имени          </td>
</tr>      </tbody></table>

</a><a name="07_01">
<h3>7.1. Описание элемента таблицы настройки ссылок</h3>

<p>Ниже приведено описание C-структуры,  соответствующей  элементу
таблицы  настройки  ссылок.  Для включения описания в программу
следует использовать файл <samp>&lt;reloc.h&gt;</samp>.
</p><pre>       struct reloc {
         long           r_vaddr;  /* Виртуальный адрес ссылки */
         long           r_symndx; /* Номер в таблице имен */
         unsigned short r_type;   /* Тип ссылки */
       };
       #define RELOC  struct reloc
       #define RELSZ  10      /* sizeof(RELOC) */
</pre>


<p>&nbsp;</p>
</a><a name="08">
<h2>8. ИНФОРМАЦИЯ О НОМЕРАХ СТРОК</h2>

<p>Использование  команд  <samp>cc  -g</samp> и <samp>svs +d</samp> приводит 
к тому, что для
каждой строки исходного текста,  на  которую  можно  установить
точка  прерывания, в объектный файл помещается элемент с информацией 
о строке. Эту информацию используют символьные  отладчики,  
такие как <samp><i>sdb</i></samp>(1) и <samp>КРОТ</samp>. В 
пределах секции элементы сгруппированы по 
функциям, как показано в следующей таблице:

                   </p><p></p><table align="center" border="">
                    <tbody><tr><td align="center">Номер в таблице имен       </td>
<td align="center">0       </td>
                   </tr><tr>
                     <td align="center">физический адрес     </td>
<td align="center">номер строки </td>
                   </tr><tr>
                     <td align="center">физический адрес     </td>
<td align="center">номер строки </td>
                   </tr><tr>
                         <td align="center"><samp>.  .  .</samp>            </td>
<td align="center"><samp>.  .  .</samp>    </td>
                   </tr><tr>
                    <td align="center">Номер в таблице имен       </td>
<td align="center">0       </td>
                   </tr><tr>
                     <td align="center">физический адрес     </td>
<td align="center">номер строки</td> 
                   </tr><tr>
                     <td align="center">физический адрес     </td>
<td align="center">номер строки </td>
</tr>                   </tbody></table>

</a><p><a name="08">Первый  элемент в пределах каждой функции содержит 0 в поле номера 
строки и вместо физического адреса хранит  номер  элемента
таблицы имен, содержащего имя этой функции. Последующие элементы 
таблицы номеров строк содержат настоящие номера строк (относительно  
начала функции) и адреса команд, соответствующих этим
строкам. В пределах функции элементы в  таблице  номеров  строк
размещаются в порядке возрастания адресов.

</a><a name="08_01">
</a></p><h3><a name="08_01">8.1. Описание элемента таблицы номеров строк</a></h3><a name="08_01">

<p>Ниже  приведено  описание C-структуры, соответствующей элементу
таблицы номеров строк. Для включения описания в программу  
следует использовать файл <samp>&lt;linenum.h&gt;</samp>.
</p><pre>       struct lineno {
         union {
           long l_symndx; /* Если l_lnno == 0, то номер элемента
                             табл. имен, описывающего функцию */
           long l_paddr;  /* Физический адрес команд, соответст-
                             вующих строке */
         }              l_addr;
         unsigned short l_lnno; /* Номер строки */
       };
       
       #define LINENO  struct lineno
       #define LINESZ  6       /* sizeof(LINENO) */
</pre>

<p>&nbsp;</p>
</a><a name="09">
<h2>9. ТАБЛИЦА ИМЕН</h2>

<p>Порядок имен в этой таблице очень важен для символьной отладки.
Имена размещаются в порядке, показанном в следующей таблице:

                </p><p></p><table align="center" border="">
                                <tbody><tr><td align="center">Имя файла 1                 </td>
                </tr><tr>
                                 <td align="center">Функция 1                  </td>
                </tr><tr>
                       <td align="center">Имена, локальные для функции 1       </td>
                </tr><tr>
                                 <td align="center">Функция 2                  </td>
                </tr><tr>
                       <td align="center">Имена, локальные для функции 2       </td>
                </tr><tr>
                                  <td align="center"><samp>.  .  .</samp>                   </td>
                </tr><tr>
                             <td align="center">Статические имена              </td>
                </tr><tr>
                                <td align="center">Имя файла 2                 </td>
                </tr><tr>
                                 <td align="center">Функция 1                  </td>
                </tr><tr>
                       <td align="center">Имена, локальные для функции 1       </td>
                </tr><tr>
                                  <td align="center"><samp>.  .  .</samp>                   </td>
                </tr><tr>
                             <td align="center">Статические имена              </td>
                </tr><tr>
                                  <td align="center"><samp>.  .  .</samp>                   </td>
                </tr><tr>
                       <td align="center">Определенные глобальные имена        
                </td></tr><tr>
                      <td align="center">Неопределенные глобальные имена       </td>
</tr>                </tbody></table>

</a><p><a name="09">Статическими в приведенной таблице называются имена, определенные 
(в языке C) с классом памяти static вне всех функций.  Таблица  
содержит по меньшей мере один элемент фиксированной длины
для каждого имени, однако для некоторых имен за этим  элементом
может следовать несколько вспомогательных элементов той же длины.  
Элемент таблицы хранит значение имени, тип и другую информацию.

</a><a name="09_01">
</a></p><h3><a name="09_01">9.1. Специальные имена</a></h3><a name="09_01">

<p>В таблицу имен помещаются некоторые специальные имена,  генерируемые  
ассемблером <samp><i>as</i></samp>(1) и другими инструментальными 
средствами. Эти имена перечислены в следующей таблице:

  </p><p></p><table align="center" border="">
   <tbody><tr><td><b>Специальное имя                       </b></td>
<td><b>Смысл                             </b></td>
  </tr><tr>
   <td><samp>.file</samp>            
</td><td>Имя файла                                              
  </td></tr><tr>
   <td><samp>.text</samp>            
</td><td>Адрес секции команд                                    
  </td></tr><tr>
   <td><samp>.data</samp>            
</td><td>Адрес секции инициализированных данных                 
  </td></tr><tr>
   <td><samp>.bss</samp>             
</td><td>Адрес секции неинициализированных данных               
  </td></tr><tr>
   <td><samp>.bb</samp>
</td><td>Адрес начала внутреннего блока                         
  </td></tr><tr>
   <td><samp>.eb</samp></td>
<td>Адрес конца внутреннего блока                          </td>
  </tr><tr>
   <td><samp>.bf</samp>              </td>
<td>Адрес начала функции                                   </td>
  </tr><tr>
   <td><samp>.ef</samp>              </td>
<td>Адрес конца функции                                    </td>
  </tr><tr>
   <td><samp>.target</samp>          </td>
<td>Адрес структуры или объединения, возвращаемых функцией </td>
  </tr><tr>
   <td><samp>.xfake</samp>           </td>
<td>Фиктивное имя структуры, объединения или перечисления  </td>
  </tr><tr>
   <td><samp>.eos</samp>             </td>
<td>Конец структуры, объединения или перечисления          </td>
  </tr><tr>
   <td><samp>etext</samp>            </td>
<td>Ближайший доступный адрес после окончания              
                    выходной секции команд</td>                                 
  </tr><tr>
   <td><samp>edata</samp>            </td>
<td>Ближайший доступный адрес после окончания              
                    выходной секции инициализированных данных              </td>
  </tr><tr>
   <td><samp>end</samp>              </td>
<td>Ближайший доступный адрес после окончания              
                    выходной секции неинициализированных данных            </td>
</tr>  </tbody></table>

<p>Из перечисленных специальных имен шесть появляются парами. Имена 
<samp>.bb</samp> и <samp>.eb</samp> отмечают границы внутренних блоков; 
пара <samp>.bf</samp> и <samp>.ef</samp>
ограничивает каждую функцию. Пара <samp>.xfake</samp> и <samp>.eos</samp> именует 
и определяет границы непоименованных структур, объединений и 
перечислений. Имя <samp>.eos</samp> встречается также в конце 
поименованных  структур, объединений и перечислений.

</p></a><p><a name="09_01">Для непоименованных структур, объединений и перечислений компилятор  
генерирует служебные имена вида <samp>.xfake</samp>, где <samp>x</samp> есть целое
число. Так, если в исходном тексте встречаются  три  непоименованные  
структуры, объединения или перечисления, то они получат
имена <samp>.0fake</samp>, <samp>.1fake</samp> и <samp>.2fake</samp>. 
В основном элементе таблицы хра-
нится различная информация для различных видов имен. За  основным 
элементом могут следовать вспомогательные.

</a><a name="09_02">
</a></p><h3><a name="09_02">9.2. Внутренние блоки</a></h3><a name="09_02">

<p>В языке C блок определяется как составной оператор, заключенный
в  фигурные  скобки,  <samp>{</samp>  и  <samp>}</samp>. Внутренний 
блок определяется как
блок, находящийся внутри функции. Сама функция  также  является
блоком.

</p><p>Если  в  некотором внутреннем блоке определены локальные имена,
то в таблицу имен, непосредственно перед элементом для  первого
такого имени, будет помещен элемент для специального имени <samp>.bb</samp>.
Равным образом, специальное имя .eb помещается сразу после элемента  
для последнего в этом блоке локального имени. Пример такой 
последовательности изображен изображен в следующей таблице:


                 </p><p></p><table align="center" border="">
                              <tbody><tr><td align="center"><samp>.bb</samp></td>
                 </tr><tr>
                  <td align="center">Имена, локальные для этого блока</td>
                 </tr><tr>
                              <td align="center"><samp>.eb</samp></td>                  
    </tr>             </tbody></table>

<p>Поскольку внутренние блоки могут быть вложенными,  пары  <samp>.bb</samp>  и
<samp>.eb</samp> и соответствующие им элементы таблицы имен также могут быть
вложенными. Пусть исходный текст выглядит так:
</p><pre>         {                        /* Блок 1 */
           int i;
           char c;
                . . .
           {                        /* Блок 2 */
             long a;
                  . . .
             {                        /* Блок 3 */
               int x;
                    . . .
             }                        /* блок 3 */
                  . . .
           }                        /* блок 2 */
                . . .
           {                        /* Блок 4 */
             long i;
                  . . .
           }                        /* блок 4 */
                . . .
         }                        /* блок 1 */
</pre>

<p>Структура  соответствующего фрагмента таблицы имен показана ниже:

                            </p><p></p><table align="center" border="">
                                  <tbody><tr><td align="center"><samp>.  .  .</samp></td>
                            </tr><tr>
                               <td align="center"><samp>.bb</samp> для блока 1</td>   
                            </tr><tr>
                                     <td align="center"><samp>i</samp></td>           
                            </tr><tr>
                                     <td align="center"><samp>c</samp></td>           
                            </tr><tr>
                               <td align="center"><samp>.bb</samp> для блока 2</td>   
                            </tr><tr>
                                     <td align="center"><samp>a</samp></td>           
                            </tr><tr>
                               <td align="center"><samp>.bb</samp> для блока 3</td>   
                            </tr><tr>
                                     <td align="center"><samp>x</samp></td>
                            </tr><tr>
                               <td align="center"><samp>.eb</samp> для блока 3</td>   
                            </tr><tr>
                               <td align="center"><samp>.eb</samp> для блока 2</td>   
                            </tr><tr>
                               <td align="center"><samp>.bb</samp> для блока 4</td>   
                            </tr><tr>
                                     <td align="center"><samp>i</samp></td>
                            </tr><tr>
                               <td align="center"><samp>.eb</samp> для блока 4</td>   
                            </tr><tr>
                               <td align="center"><samp>.eb</samp> для блока 1</td>
                            </tr><tr>
                                  <td align="center"><samp>.  .  .</samp></td>
</tr>                            </tbody></table>

</a><a name="09_03">
<h3>9.3. Имена и функции</h3>

<p>В  таблице имен между элементами для имени каждой функции и для
первого локального имени  помещается  элемент,  соответствующий
специальному имени .bf. После последнего элемента для локального  
в  данной функции имени помещается элемент, соответствующий
имени <samp>.ef</samp>. Эта последовательность показана ниже:

                        </p><p></p><table align="center" border="">
                             <tbody><tr><td align="center">Имя функции</td>
                        </tr><tr>
                                <td align="center"><samp>.bf</samp></td>           
                        </tr><tr>
                           <td align="center">Локальные имена    
                        </td></tr><tr>
                                <td align="center"><samp>.ef</samp></td>           
</tr>                        </tbody></table>

</a><a name="09_04">
<h3>9.4. Элементы таблицы имен</h3>

<p>Структура  элементов  таблицы имен одинакова для всех имен и не
зависит от их типа или класса памяти. Размер каждого   элемента
- 18  байт. Описание полей элемента таблицы имен приводится ниже. 
Следует отметить, что элементы таблицы имен (включая  
вспомогательные) нумеруются в возрастающем порядке, начиная с нуля.


     </p><p></p><table align="center" border="">
      <tbody><tr><td><b>Байты     </b></td>
<td><b>Описание       </b></td>
<td><b>Имя                 </b></td>
<td><b>Смысл                </b></td>
     </tr><tr>
        <td>0-7  </td>
<td>см. текст ниже  </td>
<td><samp>_n</samp>      </td>  
<td>Эти восемь байт содержат либо    
                                       текст имени, либо его смещение   
                                       от начала таблицы цепочек</td>        
     </tr><tr>
       <td>8-11  </td>
<td><samp>long int</samp>        </td>
<td><samp>n_value</samp>   </td>
<td>Значение имени, зависящее        
                                       от класса памяти </td>
     </tr><tr>
      <td>12-13  </td>
<td><samp>short</samp>           </td>
<td><samp>n_scnum</samp>   </td>
<td>Номер секции, содержащей имя</td>     
     </tr><tr>
      <td>14-15  </td>
<td><samp>unsigned short</samp>  </td>
<td><samp>n_type</samp>    </td>
<td>Базовый и производные типы имени</td> 
     </tr><tr>
         <td>16  </td>
<td><samp>char</samp> </td>           
<td><samp>n_sclass</samp>  </td>
<td>Класс памяти                     </td>
     </tr><tr>
         <td>17  </td>
<td><samp>char</samp>            </td>
<td><samp>n_numaux</samp>  </td>
<td>Число вспомогательных элементов  </td>
</tr>     </tbody></table>

</a><a name="09_04_01">
<h4>9.4.1. Тексты имен</h4>

<p>Первые  8 байт элемента таблицы имен представляют собой объединение 
массива символов и двух четырехбайтных целых чисел.  Если
длина  текста имени не превышает восьми символов, то здесь хранится 
сам текст, дополненный нулевыми байтами. Если же его длина 
больше восьми символов, то текст хранится в таблице цепочек.
В этом случае в первых восьми байтах элемента таблицы имен  
находятся два целых числа, первое из которых равно нулю, а второе
есть смещение соответствующего элемента таблицы цепочек относительно 
начала этой таблицы. Нули в первых четырех байтах позволяют 
отличить текст от ссылки на него, поскольку никакое имя не
может начинаться с нулевых байт:

     </p><p></p><table align="center" border="">
      <tbody><tr><td><b>Байты  </b></td>
<td><b>Описание              </b></td>
<td><b>Имя                 </b></td>
<td><b>Смысл                     </b></td>
     </tr><tr>
        <td>0-7  </td>
<td><samp>char</samp> </td>     
<td><samp>n_name</samp>    </td>
<td>8-символьный текст имени, дополненный 
                                 нулевыми байтами</td>                      
     </tr><tr>
        <td>0-3  </td>
<td><samp>long</samp> </td>     
<td><samp>n_zeroes</samp>  </td>
<td>Нули в этом поле указывают, что текст 
                                 имени находится в таблице цепочек     </td>
     </tr><tr>
        <td>4-7  </td>
<td><samp>long</samp> </td>     
<td><samp>n_offset</samp>  </td>
<td>Смещение текста имени относительно    
                                 начала таблицы цепочек                </td>
</tr>     </tbody></table>

Специальные  имена, генерируемые C-компилятором, описаны выше в
разделе Специальные имена.

</a><a name="09_04_02">
<h4>9.4.2. Классы памяти</h4>

<p>В поле, указывающем класс памяти, хранится одно из  перечисленных 
ниже значений. Именованные константы определены во включаемом 
файле <samp>&lt;storclass.h&gt;</samp>.

           </p><p></p><table align="center" border="">
            <tbody><tr><td><b>Обозначение  </b></td>
<td><b>Значение         </b></td>
<td><b>Смысл класса памяти         </b></td>
           </tr><tr>
            <td><samp>C_EFCN</samp>          
</td><td>-1     
</td><td>Физический конец функции           
           </td></tr><tr>
            <td><samp>C_NULL</samp>           
</td><td>0                  
</td><td>-                     
           </td></tr><tr>
            <td><samp>C_AUTO</samp>           
</td><td>1     
</td><td>Автоматическая переменная          
           </td></tr><tr>
            <td><samp>C_EXT</samp>            
</td><td>2     
</td><td>Внешнее имя                        
           </td></tr><tr>
            <td><samp>C_STAT</samp>           
</td><td>3     
</td><td>Статический                        
           </td></tr><tr>
            <td><samp>C_REG</samp>            
</td><td>4     
</td><td>Регистровая переменная             
           </td></tr><tr>
            <td><samp>C_EXTDEF</samp>         
</td><td>5     
</td><td>Внешнее определение                
           </td></tr><tr>
            <td><samp>C_LABEL</samp>          </td>
<td>6     </td>
<td>Метка                              </td>
           </tr><tr>
            <td><samp>C_ULABEL</samp>         </td>
<td>7     </td>
<td>Неопределенная метка               </td>
           </tr><tr>
            <td><samp>C_MOS</samp>            </td>
<td>8     </td>
<td>Элемент структуры                  </td>
           </tr><tr>
            <td><samp>C_ARG</samp>            </td>
<td>9     </td>
<td>Аргумент функции</td>                   
           </tr><tr>
            <td><samp>C_STRTAG</samp>       </td> 
<td>10     
</td><td>Начало структуры                   </td>
           </tr><tr>
            <td><samp>C_MOU</samp>           </td>
<td>11     </td>
<td>Элемент объединения                </td>
           </tr><tr>
            <td><samp>C_UNTAG</samp>         </td>
<td>12     </td>
<td>Начало объединения                 </td>
           </tr><tr>
            <td><samp>C_TPDEF</samp>         </td>
<td>13     </td>
<td>Определение типа                   </td>
           </tr><tr>
            <td><samp>C_USTATIC             </samp></td>
       
<td>14     </td>
<td>Неинициализированный статический   </td>
           </tr><tr>
            <td><samp>C_ENTAG</samp>         </td>
<td>15     </td>
<td>Начало перечисления                </td>
           </tr><tr>
            <td><samp>C_MOE</samp>          </td> 
<td>16     </td>
<td>Элемент перечисления               </td>
           </tr><tr>
            <td><samp>C_REGPARM</samp>       </td>
<td>17     </td>
<td>Регистровый параметр               </td>
           </tr><tr>
            <td><samp>C_FIELD</samp>         </td>
<td>18     </td>
<td>Битное поле                        </td>
</tr>           </tbody></table>

           <p></p><table align="center" border="">
            <tbody><tr><td><b>Обозначение  </b></td>
<td><b>Значение         </b></td>
<td><b>Смысл класса памяти         </b></td>
           </tr><tr>
            <td><samp>C_BLOCK</samp>        </td>
<td>100     </td>
<td>Начало или конец блока             </td>
           </tr><tr>
            <td><samp>C_FCN</samp>          </td>
<td>101     </td>
<td>Начало или конец функции           </td>
           </tr><tr>
            <td><samp>C_EOS</samp>          </td>
<td>102     </td>
<td>Конец структуры                    </td>
           </tr><tr>
            <td><samp>C_FILE</samp>         </td>
<td>103     </td>
<td>Имя файла                          </td>
           </tr><tr>
            <td><samp>C_LINE</samp>         </td>
<td>104     </td>
<td>Только для внутреннего пользования </td>
           </tr><tr>
            <td><samp>C_ALIAS</samp>        </td>
<td>105     </td>
<td>Синоним                            </td>
           </tr><tr>
            <td><samp>C_HIDDEN</samp>       </td>
<td>106 </td>    
<td>Аналог статического; используется, 
                                   чтобы избежать конфликта имен</td>
</tr>           </tbody></table>

<p>Все  перечисленные  классы  памяти,  за  исключением  <samp>C_ALIAS</samp> и
<samp>C_HIDDEN</samp>, генерируются при выполнении команд 
<samp><i>cc</i></samp> и <samp><i>as</i></samp>. Класс памяти 
<samp>C_HIDDEN</samp> никакими средствами системы UNIX не используется.

</p></a><p><a name="09_04_02">Некоторые из перечисленных классов памяти предназначены  только
для  внутреннего  использования  C-компилятором. Таковы <samp>C_EFCN</samp>,
<samp>C_EXTDEF</samp>, <samp>C_ULABEL</samp>, <samp>C_USTATIC</samp> и <samp>C_LINE</samp>.

</a><a name="09_04_03">
</a></p><h4><a name="09_04_03">9.4.3. Классы памяти специальных имен</a></h4><a name="09_04_03">

<p>Некоторым специальным именам соответствуют фиксированные классы
памяти. Это соответствие изображено в следующей таблице:

               </p><p></p>&nbsp;
                <table align="center" border=""><tbody><tr><td><b>Специальное имя        </b></td>
<td><b>Класс памяти         </b></td>
               </tr><tr>
                <td><samp>.file</samp>            </td>
<td><samp>C_FILE</samp></td>
               </tr><tr>
                <td><samp>.bb</samp>              </td>
<td><samp>C_BLOCK</samp></td>
               </tr><tr>
                <td><samp>.eb</samp>              </td>
<td><samp>C_BLOCK</samp>                    </td>
               </tr><tr>
                <td><samp>.bf</samp>             </td> 
<td><samp>C_FCN</samp>                      </td>
               </tr><tr>
                <td><samp>.ef</samp>             </td> 
<td><samp>C_FCN</samp>                      </td>
               </tr><tr>
                <td><samp>.target</samp>         </td> 
<td><samp>C_AUTO</samp>                     </td>
               </tr><tr>
                <td><samp>.xfake</samp>          </td> 
<td><samp>C_STRTAG</samp>, <samp>C_UNTAG</samp>, <samp>C_ENTAG</samp> </td>
               </tr><tr>
                <td><samp>.eos</samp>             </td>
<td><samp>C_EOS</samp>                      </td>
               </tr><tr>
                <td><samp>.text</samp>           </td> 
<td><samp>C_STAT</samp>                     </td>
               </tr><tr>
                <td><samp>.data</samp>           </td> 
<td><samp>C_STAT</samp>                     </td>
               </tr><tr>
                <td><samp>.bss</samp>             </td>
<td><samp>C_STAT</samp>                     </td>
</tr>               </tbody></table>

<p>Обратно, существуют классы памяти,  используемые  исключительно
для  определенных специальных имен. Это соответствие изображено
ниже:

                      </p><p></p><table align="center" border="">
                       <tbody><tr><td><b>Класс памяти  </b></td>
<td><b>Специальное имя </b></td>
                      </tr><tr>
                       <td><samp>C_BLOCK</samp>       </td>
<td><samp>.bb</samp>, <samp>.eb</samp>        </td>
                      </tr><tr>
                       <td><samp>C_FCN</samp>      </td>   
<td><samp>.bf</samp>, <samp>.ef</samp>        </td>
                      </tr><tr>
                       <td><samp>C_EOS</samp>      </td>   
<td><samp>.eos</samp>            </td>
                      </tr><tr>
                       <td><samp>C_FILE</samp>        </td>
<td><samp>.file</samp>           </td>
</tr>                      </tbody></table>

</a><a name="09_04_04">
<h4>9.4.4. Поле значения имени</h4>

<p>Смысл величины, хранящейся в поле значения, зависит  от  класса
памяти  соответствующего  имени.  Эту  зависимость иллюстрирует
следующая таблица:

             </p><p></p>&nbsp;
              <table align="center" border=""><tbody><tr><td><b>Класс памяти  </b></td>
<td><b>Смысл значения имени           </b></td>
             </tr><tr>
              <td><samp>C_AUTO</samp>        </td>
<td>Смещение в стеке (в байтах)    </td>
             </tr><tr>
              <td><samp>C_EXT</samp>    </td>     
<td>Настраиваемый адрес            </td>
             </tr><tr>
              <td><samp>C_STAT</samp>   </td>     
<td>Настраиваемый адрес            </td>
             </tr><tr>
              <td><samp>C_REG</samp>    </td>     
<td>Номер регистра                 </td>
             </tr><tr>
              <td><samp>C_LABEL</samp>  </td>     
<td>Настраиваемый адрес            </td>
             </tr><tr>
              <td><samp>C_MOS</samp>    </td>     
<td>Смещение в байтах              </td>
             </tr><tr>
              <td><samp>C_ARG</samp>    </td>     
<td>Смещение в стеке (в байтах)    </td>
             </tr><tr>
              <td><samp>C_STRTAG</samp> </td>     
<td>0                              </td>
             </tr><tr>
              <td><samp>C_MOU</samp>    </td>     
<td>0                              </td>
             </tr><tr>
              <td><samp>C_UNTAG</samp>  </td>     
<td>0                              </td>
             </tr><tr>
              <td><samp>C_TPDEF</samp>  </td>     
<td>0                              </td>
             </tr><tr>
              <td><samp>C_ENTAG</samp>  </td>     
<td>0                              </td>
             </tr><tr>
              <td><samp>C_MOE</samp>    </td>     
<td>Значение элемента перечисления </td>
             </tr><tr>
              <td><samp>C_REGPARM</samp></td>     
<td>Номер регистра                 </td>
             </tr><tr>
              <td><samp>C_FIELD</samp>  </td>     
<td>Смещение в битах               </td>
             </tr><tr>
              <td><samp>C_BLOCK</samp>  </td>     
<td>Настраиваемый адрес            </td>
             </tr><tr>
              <td><samp>C_FCN</samp>    </td>     
<td>Настраиваемый адрес            </td>
             </tr><tr>
              <td><samp>C_EOS</samp>    </td>     
<td>Длина                          </td>
             </tr><tr>
              <td><samp>C_FILE</samp>   </td>     
<td>См. текст ниже                 </td>
             </tr><tr>
              <td><samp>C_ALIAS</samp>  </td>     
<td>Номер синонима                 </td>
             </tr><tr>
              <td><samp>C_HIDDEN</samp>      </td>
<td>Настраиваемый адрес            </td>
</tr>             </tbody></table>

<p>Для имен с классом памяти <samp>C_FILE</samp> в  поле  значения  указывается
номер  следующего  элемента для специального имени <samp>.file</samp>. Таким
образом, в таблице имен элементы <samp>.file</samp> образуют  
однонаправленный  список. В поле значения последнего элемента <samp>.file</samp> хранится
номер элемента таблицы имен,  отвечающего  первому  глобальному
имени.

</p></a><p><a name="09_04_04">Настраиваемые  имена имеют значение, равное виртуальному адресу
соответствующих команд или данных. Эти значения изменяются  при
обработке секции редактором связей.

</a><a name="09_04_05">
</a></p><h4><a name="09_04_05">9.4.5. Поле номера секции</a></h4><a name="09_04_05">

<p>Ниже перечислены допустимые номера секций:

 </p><p></p><table align="center" border="">
  <tbody><tr><td><b>Обозначение  </b></td>
<td><b>Номер секции                     </b></td>
<td><b>Смысл                     </b></td>
 </tr><tr>
  <td><samp>N_DEBUG</samp>              </td>
<td>-2    </td>
<td>Специальное имя для символьной отладки       </td>
 </tr><tr>
  <td><samp>N_ABS</samp>                </td>
<td>-1    </td>
<td>Абсолютное имя</td>                               
 </tr><tr>
  <td><samp>N_UNDEF</samp>               </td>
<td>0    </td>
<td>Неопределенное внешнее имя                   </td>
 </tr><tr>
  <td><samp>N_SCNUM</samp>        </td>
<td>1-077777    </td>
<td>Номер той секции, в которой имя определяется </td>
</tr> </tbody></table>

<p>Специальный  номер секции -2 применяется для имен, используемых
при символьной отладке. Таковы имена, отмечающие начало  
структуры,  объединения  или  перечисления; определения типов; имена
файлов. Номер секции -1 отмечает имена, имеющие ненастраиваемые
значения. Такими именами являются, в частности,  автоматические
и регистровые переменные, аргументы функций и специальные имена
<samp>.eos</samp>.

</p></a><p><a name="09_04_05">За  единственным исключением, нулевой номер секции используется
для настраиваемых внешних имен, не определенных в данном файле.
Единственное же исключение - это повторно определяемое  внешнее
имя (например, COMMON-блок Фортрана или же неинициализированная
переменная, определенная в функции языка C как внешняя). В таблице 
имен каждого файла, в котором определено такое имя, в поле
номера  секции соответствующего элемента помещается 0, а в поле
значения - положительное число, равное размеру данных для этого
имени. Когда же эти файлы объединяются для получения  выполняемого  
объектного  файла,  редактор внешних связей из всех таких
одинаковых входных имен строит одно имя, с номером секции  
неинициализированных  данных.  Максимальный размер данных для всех
таких входных имен используется при отведении места под  данные
для выходного имени. Значением выходного имени становится 
соответствующий виртуальный адрес. Таков единственный случай, когда
имя имеет нулевой номер секции и ненулевое значение.

</a><a name="09_04_06">
</a></p><h4><a name="09_04_06">9.4.6. Номера секций и классы памяти</a></h4><a name="09_04_06">

<p>Существует  соответствие  между классами памяти и номерами 
секций, возможными у имен с такими классами. Это соответствие  
показано в следующей таблице:

                </p><p></p><table align="center" border="">
                 <tbody><tr><td><b>Класс памяти  </b></td>
<td><b>Возможный номер секции  </b></td>
                </tr><tr>
                 <td><samp>C_AUTO</samp>        </td>
<td><samp>N_ABS</samp>                   </td>
                </tr><tr>
                 <td><samp>C_EXT</samp>       </td>  
<td><samp>N_ABS</samp>, <samp>N_UNDEF</samp>, <samp>N_SCNUM</samp> </td>
                </tr><tr>
                 <td><samp>C_STAT</samp>      </td>  
<td><samp>N_SCNUM</samp>                 </td>
                </tr><tr>
                 <td><samp>C_REG</samp>       </td>  
<td><samp>N_ABS</samp>                   </td>
                </tr><tr>
                 <td><samp>C_LABEL</samp>       </td>
<td><samp>N_UNDEF</samp>, <samp>N_SCNUM</samp>     </td>   
                </tr><tr>
                 <td><samp>C_MOS</samp>       </td>  
<td><samp>N_ABS</samp>                   </td>
                </tr><tr>
                 <td><samp>C_ARG</samp>         </td>
<td><samp>N_ABS</samp>   </td>                
                </tr><tr>
                 <td><samp>C_STRTAG</samp>    </td>  
<td><samp>N_DEBUG</samp>                 </td>
                </tr><tr>
                 <td><samp>C_MOU</samp>         </td>
<td><samp>N_ABS</samp>   </td>                
                </tr><tr>
                 <td><samp>C_UNTAG</samp>     </td>  
<td><samp>N_DEBUG</samp>                 </td>
                </tr><tr>
                 <td><samp>C_TPDEF</samp>          </td>
<td><samp>N_DEBUG</samp>                 </td>
                </tr><tr>
                 <td><samp>C_ENTAG</samp>     </td>  
<td><samp>N_DEBUG</samp>                 </td>
                </tr><tr>
                 <td><samp>C_MOE</samp>       </td>  
<td><samp>N_ABS</samp>                   </td>
                </tr><tr>
                 <td><samp>C_REGPARM</samp>   </td>  
<td><samp>N_ABS</samp>                   </td>
                </tr><tr>
                 <td><samp>C_FIELD</samp>     </td>  
<td><samp>N_ABS</samp>                   </td>
                </tr><tr>
                 <td><samp>C_BLOCK</samp>     </td>  
<td><samp>N_SCNUM</samp>                 </td>
                </tr><tr>
                 <td><samp>C_FCN</samp>       </td>  
<td><samp>N_SCNUM</samp>                 </td>
                </tr><tr>
                 <td><samp>C_EOS</samp>       </td>  
<td><samp>N_ABS</samp>                   </td>
                </tr><tr>
                 <td><samp>C_FILE</samp>      </td>  
<td><samp>N_DEBUG</samp>                 </td>
                </tr><tr>
                 <td><samp>C_ALIAS</samp>       </td>
<td><samp>N_DEBUG</samp>                 </td>
</tr>                </tbody></table>

</a><a name="09_04_07">
<h4>9.4.7. Поле типа</h4>

<p>Поле типа элемента таблицы имен содержит информацию о базовом и
производных  типах  соответствующего  имени. Компилятор языка C
заполняет эти поля только при указании  опции  <samp>-g</samp>.  Производных
типов  может быть несколько, но каждое имя имеет ровно один 
базовый тип. Формат 16-битного поля типа таков:

               </p><p></p><table align="center" border="">
<tbody><tr><td><samp>d6</samp>  </td>
<td><samp>d5</samp>  </td>
<td><samp>d4</samp>  </td>
<td><samp>d3</samp>  </td>
<td><samp>d2</samp>  </td>
<td><samp>d1</samp>  </td>
<td>базовый тип </td>
</tr>               </tbody></table>

Биты с 0-го по 3-й кодируют базовый тип:

          <p></p><table align="center" border="">
           <tbody><tr><td><b>Обозначение  </b></td>
<td><b>Значение           </b></td>
<td><b>Базовый тип            </b></td>
          </tr><tr>
           <td><samp>T_NULL</samp>           </td>
<td>0     </td>
<td>Тип не назначен                 </td>
          </tr><tr>
           <td><samp>T_VOID</samp>           </td>
<td>1     </td>
<td>Пустой тип                      </td>
          </tr><tr>
           <td><samp>T_CHAR</samp>           </td>
<td>2     </td>
<td>Символ                          </td>
          </tr><tr>
           <td><samp>T_SHORT</samp>          </td>
<td>3     </td>
<td>Короткое целое                  </td>
          </tr><tr>
           <td><samp>T_INT</samp>            </td>
<td>4     </td>
<td>Целое      </td>                     
          </tr><tr>
           <td><samp>T_LONG</samp>           </td>
<td>5     </td>
<td>Длинное целое                   </td>
          </tr><tr>
           <td><samp>T_FLOAT</samp>      </td>    
<td>6     </td>
<td>Вещественное одинарной точности </td>
          </tr><tr>
           <td><samp>T_DOUBLE</samp>     </td>    
<td>7     </td>
<td>Вещественное двойной точности   </td>
          </tr><tr>
           <td><samp>T_STRUCT</samp>     </td>    
<td>8     
</td><td>Структура                       </td>
          </tr><tr>
           <td><samp>T_UNION</samp>          </td>
<td>9     </td>
<td>Объединение</td>                     
          </tr><tr>
           <td><samp>T_ENUM</samp>          </td>
<td>10     </td>
<td>Перечисление</td>                    
          </tr><tr>
           <td><samp>T_MOE</samp>           </td>
<td>11     </td>
<td>Элемент перечисления            </td>
          </tr><tr>
           <td><samp>T_UCHAR</samp>      </td>   
<td>12     </td>
<td>Символ без знака                </td>
          </tr><tr>
           <td><samp>T_USHORT</samp>     </td>   
<td>13     </td>
<td>Короткое целое без знака        </td>
          </tr><tr>
           <td><samp>T_UINT</samp>          </td>
<td>14     </td>
<td>Целое без знака                 </td>
          </tr><tr>
           <td><samp>T_ULONG</samp></td>
<td>15     </td>
<td>Длинное целое без знака         </td>
</tr>          </tbody></table>

<p>Биты с 4-го по 15-й разделены на шесть двухбитных полей, обозначаемых  
<samp>d1..d6</samp>.  Эти поля представляют уровни производных 
типов, перечисленых ниже:

          </p><p></p>&nbsp;&nbsp;
           <table align="center" border=""><tbody><tr><td><b>Обозначение  </b></td>
<td><b>Значение       </b></td>
<td><b>Производный тип        </b></td>
          </tr><tr>
           <td><samp>DT_NON</samp>          </td>
<td>0      </td>
<td>Производный тип отсутствует </td>
          </tr><tr>
           <td><samp>DT_PTR</samp>          </td>
<td>1      </td>
<td>Указатель                   </td>
          </tr><tr>
           <td><samp>DT_FCN</samp>          </td>
<td>2      </td>
<td>Функция                     </td>
          </tr><tr>
           <td><samp>DT_ARY</samp>          </td>
<td>3      </td>
<td>Массив                      </td>
</tr>          </tbody></table>

<p>В следующих примерах иллюстрируется представление типа  в  
элементе таблицы имен.
</p><pre>       char *func();
</pre>

<p>Здесь  <samp>func</samp> есть имя функции, возвращающей указатель на символ.
Базовый тип имени <samp>func</samp> есть 2 (символ), в поле <samp>d1</samp> 
будет помещено число 2 (функция), а в поле <samp>d2</samp> - 1 (указатель). 
Таким  образом, в поле типа элемента <samp>func</samp> будет находиться 
шестнадцатеричное  значение  <samp>0x62</samp>,  которое  и  интерпретируется как функция,
возвращающая указатель на символ.
</p><pre>       short *tabptr [10] [25] [3];
</pre>

</a><p><a name="09_04_07">Здесь <samp>tabptr</samp> есть трехмерный массив указателей на короткие  
целые.  Базовый  тип для <samp>tabptr</samp> есть 3 (короткое целое); в каждое
из полей <samp>d1</samp>, <samp>d2</samp>, <samp>d3</samp> будет помещено число 3 (массив), а  в  поле
<samp>d4</samp> - 1 (указатель). Таким образом, для трехмерного массива 
указателей на короткие целые в поле типа соответствующего элемента
таблицы имен будет храниться шестнадцатеричное значение <samp>0xff3</samp>.

</a><a name="09_04_08">
</a></p><h4><a name="09_04_08">9.4.8. Связь между типом и классом памяти</a></h4><a name="09_04_08">

<p>Ниже перечислены типы, допустимые для каждого класса памяти.

</p><p></p><table align="center" border="">
<tbody><tr><td rowspan="2"><b>Класс памяти</b></td>    
<td colspan="3" align="center"><b>d-поля</b></td>                                          
<td rowspan="2"><b>Базовый тип</b></td>
</tr><tr>         
<td><b>Функция?</b></td>  
<td><b>Массив?</b></td>
<td><b>Указатель?</b></td>
  </tr><tr>
   <td><samp>C_AUTO</samp>     </td>
<td>нет</td>       
<td>да</td>       
<td>да</td>          
<td>Любой, кроме <samp>T_MOE</samp> </td>
  </tr><tr>
   <td><samp>C_EXT</samp>      </td>
<td>да</td>        
<td>да</td>       
<td>да</td>          
<td>Любой, кроме <samp>T_MOE</samp> </td>       
  </tr><tr>
   <td><samp>C_STAT</samp>     </td>
<td>да</td>        
<td>да</td>       
<td>да</td>          
<td>Любой, кроме <samp>T_MOE</samp>        </td>
  </tr><tr>
   <td><samp>C_REG</samp>      </td>
<td>нет</td>       
<td>нет</td>      
<td>да</td>          
<td>Любой, кроме <samp>T_MOE</samp> </td>       
  </tr><tr>
   <td><samp>C_LABEL</samp>    </td>
<td>нет</td>       
<td>нет</td>      
<td>нет</td>         
<td><samp>T_NULL</samp>                    </td>
  </tr><tr>
   <td><samp>C_MOS</samp>      </td>
<td>нет</td>       
<td>да</td>       
<td>да</td>          
<td>Любой, кроме <samp>T_MOE</samp> </td>       
  </tr><tr>
   <td><samp>C_ARG</samp>      </td>
<td>да</td>        
<td>нет</td>      
<td>да</td>          
<td>Любой, кроме <samp>T_MOE</samp> </td>       
  </tr><tr>
   <td><samp>C_STRTAG</samp>   </td>
<td>нет</td>       
<td>нет</td>      
<td>нет</td>         
<td><samp>T_STRUCT</samp>                  </td>
  </tr><tr>
   <td><samp>C_MOU</samp>      </td>
<td>нет</td>       
<td>да</td>       
<td>да</td>          
<td>Любой, кроме <samp>T_MOE</samp> </td>       
  </tr><tr>
   <td><samp>C_UNTAG</samp>    </td>
<td>нет</td>       
<td>нет</td>      
<td>нет</td>         
<td><samp>T_UNION</samp>            </td>       
  </tr><tr>
   <td><samp>C_TPDEF</samp>    </td>
<td>нет</td>       
<td>да</td>       
<td>да</td>          
<td>Любой, кроме <samp>T_MOE</samp> </td>       
  </tr><tr>
   <td><samp>C_ENTAG</samp>    </td>
<td>нет</td>       
<td>нет</td>      
<td>нет</td>         
<td><samp>T_ENUM</samp>             </td>       
  </tr><tr>
   <td><samp>C_MOE</samp>      </td>
<td>нет</td>       
<td>нет</td>      
<td>нет</td>         
<td><samp>T_MOE</samp>                     </td>
  </tr><tr>
   <td><samp>C_REGPARM</samp>       </td>
<td>нет</td>       
<td>нет</td>      
<td>да</td>          
<td>Любой, кроме <samp>T_MOE</samp>        </td>
  </tr><tr>
   <td><samp>C_FIELD</samp>    </td>
<td>нет</td>       
<td>нет</td>      
<td>нет</td>         
<td><samp>T_ENUM</samp>, <samp>T_UCHAR</samp>, <samp>T_USHORT</samp>, 
                                             <samp>T_UINT</samp>, <samp>T_ULONG</samp></td>
  </tr><tr>
   <td><samp>C_BLOCK</samp>    </td>
<td>нет</td>       
<td>нет</td>      
<td>нет</td>         
<td><samp>T_NULL</samp>             </td>       
  </tr><tr>
   <td><samp>C_FCN</samp>      </td>
<td>нет</td>       
<td>нет</td>      
<td>нет</td>         
<td><samp>T_NULL</samp>             </td>       
  </tr><tr>
   <td><samp>C_EOS</samp>      </td>
<td>нет</td>       
<td>нет</td>      
<td>нет</td>         
<td><samp>T_NULL</samp>             </td>       
  </tr><tr>
   <td><samp>C_FILE</samp>     </td>
<td>нет</td>       
<td>нет</td>      
<td>нет</td>         
<td><samp>T_NULL</samp>                    </td>
  </tr><tr>
   <td><samp>C_ALIAS</samp>    </td>
<td>нет</td>       
<td>нет</td>      
<td>нет</td>         
<td><samp>T_STRUCT</samp>, <samp>T_UNION</samp>, <samp>T_ENUM</samp> </td>
</tr>  </tbody></table>

<p>Условия относительно d-полей касаются всех полей <samp>d1..d6</samp>  с  тем
исключением,  что не может быть двух последовательных производных типов функция.

</p></a><p><a name="09_04_08">Хотя  аргументы функции и могут быть объявлены как массивы, они
все равно трактуются как указатели. Поэтому аргумент функции не
может иметь массив в качестве своего первого производного типа.


</a><a name="09_04_09">
</a></p><h4><a name="09_04_09">9.4.9. Описание элемента таблицы имен</a></h4><a name="09_04_09">

<p>Ниже приведено описание C-структуры,  соответствующей  элементу
таблицы  имен.  Для  включения описания в программу следует 
использовать файл <samp>lt;syms.h&gt;</samp>.
</p><pre>       #define SYMNMLEN  8  /* Максимальное количество символов
                               в тексте имени */

       struct syment {
         union {        /* Все способы описать текст имени */
           char _n_name [SYMNMLEN]; /* Текст имени */
           struct {
             long _n_zeroes; /* Если == 0, то в таблице цепочек */
             long _n_offset; /* Смещение в табл. цепочек */
           }    _n_n;
           char *_n_nptr [2];
         }              _n;
         long           n_value;   /* Значение имени */
         short          n_scnum;   /* Номер секции */
         unsigned short n_type;    /* Тип и производный тип */
         char           n_sclass;  /* Класс памяти */
         char           n_numaux;  /* Число вспомогательных
                                      элементов */
       };

       #define n_name    _n._n_name
       #define n_zeroes  _n._n_n._n_zeroes
       #define n_offset  _n._n_n._n_offset
       #define n_nptr    _n._n_nptr [1]

       #define SYMENT  struct syment
       #define SYMESZ  18      /* sizeof(SYMENT) */
</pre>

</a><a name="09_05">
<h3>9.5. Вспомогательные элементы таблицы имен</h3>

<p>Вспомогательные элементы имеют тот же размер, что  и  основные,
однако  их структура зависит от типа имени и класса памяти. Эта
зависимость показана в следующей таблице:

</p><p></p><table align="center" border="">
<tbody><tr><td rowspan="2"><b>Имя</b></td>
<td rowspan="2"><b>Класс памяти</b></td>
<td colspan="2"><b>Тип</b></td>
<td rowspan="2"><b>Формат вспомогательного элемента</b></td>
</tr><tr>
<td><b>d1</b></td>
<td><b>Базовый тип</b></td>
  </tr><tr>
   <td><samp>.file</samp>             </td>
<td><samp>C_FILE</samp>         </td>
<td><samp>DT_NON</samp>   </td>
<td><samp>T_NULL</samp>       </td>
<td>Имя файла         </td>
  </tr><tr>
   <td><samp>.text</samp>, <samp>.data</samp>, <samp>.bss</samp></td>
<td><samp>C_STAT</samp>         </td>
<td><samp>DT_NON</samp>   </td>
<td><samp>T_NULL</samp>      </td> 
<td>Секция            </td>
  </tr><tr>
   <td>Имя структуры,объединения или  перечисления      </td>
<td><samp>C_STRTAG</samp>, <samp>C_UNTAG</samp>, <samp>C_ENTAG</samp>                  </td>
<td><samp>DT_NON</samp>   </td>
<td><samp>T_NULL</samp>       </td>
<td>Начало структуры, объединения или перечисления      </td>
  </tr><tr>
   <td><samp>.eos</samp>              </td>
<td><samp>C_EOS</samp>          </td>
<td><samp>DT_NON</samp>   </td>
<td><samp>T_NULL</samp>       </td>
<td>Конец структуры   </td>
  </tr><tr>
   <td>Имя функции       </td>
<td><samp>C_EXT</samp>, <samp>C_STAT</samp>  </td>
<td><samp>DT_FCN</samp>   </td>
<td>Кроме <samp>T_MOE</samp>  </td>
<td>Функция           </td>
  </tr><tr>
   <td>Имя массива         </td>
<td><samp>C_AUTO</samp>, <samp>C_STAT</samp>, <samp>C_MOS</samp>, <samp>C_MOU</samp>, <samp>C_TPDEF</samp></td>
<td><samp>DT_ARR</samp>   </td>
<td>Кроме <samp>T_MOE</samp>   </td>
<td>Массив            </td>
  </tr><tr>
   <td><samp>.bb</samp>, <samp>.eb</samp>          </td>
<td><samp>C_BLOCK</samp>        </td>
<td><samp>DT_NON</samp>   </td>
<td><samp>T_NULL</samp>       </td>
<td>Начало и конец блока             </td>
  </tr><tr>
   <td><samp>.bf</samp>, <samp>.ef</samp>          </td>
<td><samp>C_FCN</samp>          </td>
<td><samp>DT_NON</samp>   </td>
<td><samp>T_NULL</samp>       </td>
<td>Начало и конец функции           </td>
  </tr><tr>
   <td>Имя, связанное со структурой, объединением или перечислением     </td>
<td><samp>C_AUTO</samp>, <samp>C_STAT</samp>, <samp>C_MOS</samp>, <samp>C_MOU</samp>, <samp>C_TPDEF</samp></td>
<td><samp>DT_PTR</samp>, <samp>DT_ARR</samp>, <samp>DT_NON</samp>   </td>
<td><samp>T_STRUCT</samp>, <samp>T_UNION</samp>, <samp>T_ENUM</samp></td>
<td>Имя, связанное    
со структурой,    
объединением или  
перечислением    </td>
</tr>  </tbody></table>

<p>Здесь имя структуры, объединения или перечисления включает также 
специальные имена <samp>.xfake</samp>. Если имя удовлетворяет  нескольким
из перечисленных условий, то его вспомогательный элемент должен
иметь формат объединения.

</p><p><u>Примечание</u>
</p><dir>
        Было бы  ошибкой  полагаться  на  какие-либо  априорные
        предположения  о числе вспомогательных элементов. Число
        вспомогательных элементов для  имени  хранится  в  поле
        n_numaux  соответствующего  основного элемента и должно
        извлекаться только оттуда.
</dir>

</a><p><a name="09_05">В  следующих пунктах описывается структура вспомогательных элементов.

</a><a name="09_05_01">
</a></p><h4><a name="09_05_01">9.5.1. Имя файла</a></h4><a name="09_05_01">

</a><p><a name="09_05_01">Вспомогательный элемент для имени файла в байтах с 0-го по 13-й
содержит 14-символьное имя файла, дополненное нулями.

</a><a name="09_05_02">
</a></p><h4><a name="09_05_02">9.5.2. Секция</a></h4><a name="09_05_02">

<p>Вспомогательные  элементы для секций имеют формат, изображенный
в следующей таблице:

   </p><p></p><table align="center" border="">
    <tbody><tr><td><b>Байты     </b></td>
<td><b>Описание       </b></td>
<td><b>Имя                   </b></td>
<td><b>Смысл                </b></td>
   </tr><tr>
      <td>0-3  </td>
<td><samp>long int</samp>        </td>
<td><samp>x_scnlen</samp>  </td>
<td>Длина секции                       </td>
   </tr><tr>
      <td>4-5  </td>
<td><samp>unsigned short</samp>  </td>
<td><samp>x_nreloc</samp>             </td>
<td>Число элементов в таблице          
                                     настройки ссылок</td>                   
   </tr><tr>
      <td>6-7  </td>
<td><samp>unsigned short</samp>  </td>
<td><samp>x_nlinno</samp>             </td>
<td>Число элементов в таблице          
                                     номеров строк</td>                      
   </tr><tr>
     <td>8-17  </td>
<td>-     </td>          
<td>-</td>         
<td>Не используются (заполнены нулями) </td>
</tr>   </tbody></table>

</a><a name="09_05_03">
<h4>9.5.3. Начало структуры, объединения или перечисления</h4>

<p>Вспомогательные элементы для таких имен имеют следующий формат:


   </p><p></p><table align="center" border="">
    <tbody><tr><td><b>Байты     </b></td>
<td><b>Описание       </b></td>
<td><b>Имя                  </b></td>
<td><b>Смысл                 </b></td>
   </tr><tr>
      <td>0-5  </td>
<td>-  </td>             
<td>-  </td>       
<td>Не используются (заполнены нулями) </td>
   </tr><tr>
      <td>6-7  </td>
<td><samp>unsigned short</samp> </td> 
<td><samp>x_size</samp>    </td>
<td>Размер структуры, объединения или  
                                     перечисления</td>
   </tr><tr>
     <td>8-11  </td>
<td>-</td>               
<td>-</td>         
<td>Не используются (заполнены нулями) </td>
   </tr><tr>
    <td>12-15  </td>
<td><samp>long int</samp>        </td>
<td><samp>x_endndx</samp></td>
<td>Номер элемента, следующего за      
                                     элементами для этой структуры,     
                                     объединения, или перечисления</td>
   </tr><tr>
    <td>16-17  </td>
<td>-               </td>
<td>-         </td>
<td>Не используются (заполнены нулями) </td>
</tr>   </tbody></table>

</a><a name="09_05_04">
<h4>9.5.4. Конец структуры</h4>

<p>Формат вспомогательного элемента для конца структуры  изображен
в следующей таблице:

   </p><p></p><table align="center" border="">
    <tbody><tr><td><b>Байты     </b></td>
<td><b>Описание       </b></td>
<td><b>Имя                  </b></td>
<td><b>Смысл                  </b></td>
   </tr><tr>
      <td>0-3  </td>
<td><samp>long int</samp>        </td>
<td><samp>x_tagndx</samp>  </td>
<td>Номер элемента для начала структуры </td>
   </tr><tr>
      <td>4-5  </td>
<td>-               </td>
<td>-         </td>
<td>Не используются (заполнены нулями)  </td>
   </tr><tr>
     <td> 6-7  </td>
<td><samp>unsigned short</samp> </td> 
<td><samp>x_size</samp>    </td>
<td>Размер структуры, объединения или   
                                     перечисления</td>
   </tr><tr>
     <td>8-17  </td>
<td>-     </td>          
<td>-</td>         
<td>Не используются (заполнены нулями)  </td>
</tr>   </tbody></table>

</a><a name="09_05_05">
<h4>9.5.5. Функция</h4>

<p>Вспомогательные элементы для функций имеют следующий формат:

  </p><p></p><table align="center" border="">
   <tbody><tr><td><b>Байты     </b></td>
<td><b>Описание        </b></td>
<td><b>Имя                  </b></td>
<td><b>Смысл                   </b></td>
  </tr><tr>
     <td>0-3  </td>
<td><samp>long int</samp>        </td>
<td><samp>x_tagndx</samp>   </td>
<td>Номер основного элемента для функции</td> 
  </tr><tr>
     <td>4-7  
</td><td><samp>long int</samp>        </td>
<td><samp>x_fsize</samp>    </td>
<td>Размер функции в байтах              </td>
  </tr><tr>
    <td>8-11  </td>
<td><samp>long int</samp>        </td>
<td><samp>x_lnnoptr</samp>  </td>
<td>Указатель в файле                    
                                     на соответствующий элемент           
                                     таблицы номеров строк</td>
  </tr><tr>
   <td>12-15  </td>
<td><samp>long int</samp>        </td>
<td><samp>x_endndx</samp>             </td>
<td>Номер элемента, следующего за        
                                     элементами для этой функции</td>          
  </tr><tr>
   <td>16-17  </td>
<td><samp>unsigned short</samp>  </td>
<td><samp>x_tvndx</samp>    </td>
<td>Номер адреса функции                 
                                     в таблице адресов переходов          
                                     (в ОС UNIX не используется)</td>
</tr>  </tbody></table>

</a><a name="09_05_06">
<h4>9.5.6. Массив</h4>

<p>Формат вспомогательного элемента для массива изображен в следующей 
таблице. Попытка определения массива с количеством измерений, 
превышающим 4, приводит к выдаче предупреждения.

  </p><p></p><table align="center" border="">
   <tbody><tr><td><b>Байты     </b></td>
<td><b>Описание         </b></td>
<td><b>Имя                     </b></td>
<td><b>Смысл                 </b></td>
  </tr><tr>
     <td>0-3  </td>
<td><samp>long int</samp>        </td>
<td><samp>x_tagndx</samp>     </td>
<td>Номер основного элемента для массива</td> 
  </tr><tr>
     <td>4-5  </td>
<td><samp>unsigned short</samp>  </td>
<td><samp>x_lnno</samp>       </td>
<td>Номер строки с описанием массива</td>     
  </tr><tr>
     <td>6-7  </td>
<td><samp>unsigned short</samp>  </td>
<td><samp>x_size</samp>               </td>
<td>Размер массива                       </td>
  </tr><tr>
     <td>8-9  </td>
<td><samp>unsigned short</samp>  </td>
<td><samp>x_dimen [0]</samp>  </td>
<td>Первое измерение</td>                     
  </tr><tr>
   <td>10-11  </td>
<td><samp>unsigned short</samp>    </td>
<td><samp>x_dimen [1]</samp>  </td>
<td>Второе измерение</td>                     
  </tr><tr>
   <td>12-13  </td>
<td><samp>unsigned short</samp>    </td>
<td><samp>x_dimen [2]</samp>  </td>
<td>Третье измерение</td>                     
  </tr><tr>
   <td>14-15  </td>
<td><samp>unsigned short</samp>    </td>
<td><samp>x_dimen [3]</samp>  </td>
<td>Четвертое измерение                  </td>
  </tr><tr>
   <td>16-17  </td>
<td>-               </td>
<td>-</td>            
<td>Не используются (заполнены нулями)   </td>
</tr>  </tbody></table>

</a><a name="09_05_07">
<h4>9.5.7. Конец блока или функции</h4>

<p>Вспомогательные элементы для конца блока или функции имеют следующий формат:

     </p><p></p><table align="center" border="">
      <tbody><tr><td><b>Байты     </b></td>
<td><b>Описание      </b></td>
<td><b>Имя                </b></td>
<td><b>Смысл                  
     </b></td></tr><tr>
        <td>0-3  </td>
<td>-               </td>
<td>-       </td>
<td>Не используются (заполнены нулями) </td>
     </tr><tr>
        <td>4-5  </td>
<td><samp>unsigned short</samp>  </td>
<td><samp>x_lnno</samp>  </td>
<td>Номер строки исходного текста      </td>
     </tr><tr>
       <td>6-17   </td>
<td>-        </td>       
<td>-   </td>    
<td>Не используются (заполнены нулями) </td>
</tr>     </tbody></table>

</a><a name="09_05_08">
<h4>9.5.8. Начало блока или функции</h4>

<p>Формат вспомогательных элементов для начала блока  или  функции
изображен ниже:

    </p><p></p><table align="center" border="">
     <tbody><tr><td><b>Байты     </b></td>
<td><b>Описание       </b></td>
<td><b>Имя                 </b></td>
<td><b>Смысл                  </b></td>
    </tr><tr>
       <td>0-3     </td>
<td>-               </td>
<td>-         </td>
<td>Не используются (заполнены нулями) </td>
    </tr><tr>
       <td>4-5  </td>
<td><samp>unsigned short</samp>  </td>
<td><samp>x_lnno</samp>    </td>
<td>Номер строки исходного текста</td>      
    </tr><tr>
      <td>6-11  </td>
<td>-                </td>
<td>-         </td>
<td>Не используются (заполнены нулями) </td>
    </tr><tr>
     <td>12-15</td>  
<td><samp>long int</samp>        </td>
<td><samp>x_endndx</samp>  </td>
<td>Номер элемента, следующего         
                                      за элементами для этого блока</td>
    </tr><tr>
     <td>16-17 </td> 
<td>-     </td>          
<td>-</td>         
<td>Не используются (заполнены нулями) </td>
    </tr></tbody></table>

</a><a name="09_05_09">
<h4>9.5.9. Имена, связанные со структурой,
      объединением или перечислением</h4>

<p>Формат  вспомогательных элементов для имен, связанных со структурой, 
объединением или  перечислением,  приведен  в  следующей
таблице:

   </p><p></p><table align="center" border="">
    <tbody><tr><td><b>Байты     </b></td>
<td><b>Описание       </b></td>
<td><b>Имя                 </b></td>
<td><b>Смысл                   </b></td>
   </tr><tr>
      <td>0-3  </td>
<td><samp>long int</samp>        </td>
<td><samp>x_tagndx</samp>  </td>
<td>Номер элемента для начала структуры </td>
   </tr><tr>
      <td>4-5  </td>
<td>-               </td>
<td>-         </td>
<td>Не используются (заполнены нулями)  </td>
   </tr><tr>
      <td>6-7  </td>
<td><samp>unsigned short</samp> </td> 
<td><samp>x_size</samp>    </td>
<td>Размер структуры, объединения       
                                     или перечисления</td>
   </tr><tr>
     <td>8-17     </td>
<td>-        </td>       
<td>-   </td>      
<td>Не используются (заполнены нулями)  </td>
</tr>   </tbody></table>

<p>Имена, определенные в операторах <samp><i>typedef</i></samp>, могут иметь, но могут
и не иметь вспомогательных элементов. Пример:
</p><pre>       typedef struct people  STUDENT;
       
       struct people {
         char name [20];
         long id;
       };
       
       typedef struct people  EMPLOYEE;
</pre>

</a><p><a name="09_05_09">Имя  <samp>EMPLOYEE</samp>  будет  иметь  вспомогательный  элемент в таблице
имен, а имя <samp>STUDENT</samp> - нет, поскольку его описание  предшествует
описанию структуры.

</a><a name="09_05_10">
</a></p><h4><a name="09_05_10">9.5.10. Описание вспомогательного элемента</a></h4><a name="09_05_10">

<p>Ниже  приведено описание C-структуры, соответствующей вспомогательному 
элементу таблицы имен. Для включения описания в  программу 
следует использовать файл <samp>&lt;syms.h&gt;</samp>.
</p><pre>       #define SYMNMLEN 8  /* Максимальное количество символов
                              в тексте имени */
       #define FILNMLEN 14 /* Максимальное количество символов
                              в имени файла */
       #define DIMNUM   4  /* Размерность массива во вспомога-
                              тельном элементе */

       union auxent {
         struct {
           long x_tagndx; /* Номер в таблице имен начала структуры,
                             объединения или перечисления */
           union {
             struct {
               unsigned short x_lnno; /* Номер строки
                                         определения */
               unsigned short x_size; /* Размер массива, структуры
                                         или объединения */
             } x_lnsz;
             long x_fsize; /* Размер функции */
           } x_misc;
           union {
             struct {
               long x_lnnoptr;
               long x_endndx;
             } x_fcn;
             struct { /* Если массив, то его размерности (до 4) */
               unsigned short x_dimen [DIMNUM];
             } x_ary;
           } x_fcnary;
           unsigned short x_tvndx;
         } x_sym;
         struct {
           char x_fname [FILNMLEN]; /* Имя файла (занимает весь
                                       элемент) */
         } x_file;
         struct {
           long           x_scnlen; /* Длина секции */
           unsigned short x_nreloc; /* Число  элем. с инф. о
                                       настройке ссылок */
           unsigned short x_nlinno; /* Число  элем. с инф. о
                                       номерах строк */
         } x_scn;
         struct {
           long           x_tvfill;
           unsigned short x_tvlen;
           unsigned short x_tvran[2];
         } x_tv;
       };

       #define AUXENT  union auxent
</pre>


<p>&nbsp;</p>
</a><a name="10">
<h2>10. ТАБЛИЦА ЦЕПОЧЕК</h2>

<p>Тексты имен, состоящие более чем из восьми символов, размещаются  
последовательно  в таблице цепочек, причем каждый текст завершается 
нулевым байтом. Первые четыре байта  таблицы  цепочек
содержат  размер этой таблицы в байтах; таким образом, смещения
всех имен из этой таблицы больше или равны 4.


</p><p>&nbsp;</p>
</a><a name="11">
<h2>11. ПРОГРАММЫ ДОСТУПА
         К ОБЪЕКТНЫМ ФАЙЛАМ ОБЫЧНОГО ФОРМАТА</h2>

<p>Операционная  система UNIX предоставляет набор инструментальных
средств для доступа к различным частям  объектных  файлов.  Эти
средства  избавляют  использующую их программу от необходимости
знать общую структуру объектного файла, хотя строение обрабатываемых 
частей программа должна знать в деталях.

</p><p>Средства доступа можно разделить на четыре категории:
</p><ul>
        <li>Открытие и закрытие объектного файла.

        </li><li>Чтение заголовков, данных из таблицы имен и  информации
        о номерах строк.

        </li><li>Поиск  начала секции, информации о настройке ссылок или
        таблицы номеров строк, относящихся к определенной  секции.

        </li><li>Получение  номера элемента таблицы имен объектного файла.
</li></ul>

<p>Функции  доступа хранятся в библиотеке <samp>libld.a</samp> и описаны в 
разделе 3 Справочника программиста. Статья с обзором этих  функций
помещена в разделе 4 Справочника программиста, см. <samp><i>ldfcn</i></samp>(4).

</p><p></p><hr>
<table cellpadding="10">
<tbody><tr><td><a href="http://khpi-iip.mipk.kharkiv.edu/library/extent/os/ruprog/p05.html">Назад</a></td><td><a href="http://khpi-iip.mipk.kharkiv.edu/library/extent/os/ruprog/index.html">Оглавление</a></td><td><a href="http://khpi-iip.mipk.kharkiv.edu/library/extent/os/ruprog/p07.html">Вперед</a></td></tr>
</tbody></table>
<table cellpadding="10">
<tbody><tr><td><a href="http://khpi-iip.mipk.kharkiv.edu/library/index.htm">Каталог</a></td><td><a href="http://khpi-iip.mipk.kharkiv.edu/library/extent/os/index.htm">Индекс раздела</a></td><td></td></tr>
</tbody></table>
<p></p>


</a></body></html>