\labworkC{%Источник без памяти. 
Исследование статистических характеристик исходных текстов (как бинарных файлов, так и~файлов в~формате простого текста). Работа с кодовыми таблицами русского языка}
{Частотность. Кодировки русского языка}

Максимальная оценка ПИН  обязательной части "--- $\bsingle$ баллов. Максимум графы $%\bdouble = 
\bsingle+\bsingle$ баллов включает бонусное задание \ref{lab_task_markov1_stat}.

\taskabsencepenalty{3}


\label{lab_otik_letters_stat}
\label{lab_freq}

% Обратите внимание, что это "--- \emph{единственная} лабораторная работа, где
% символ кодирования не обязательно является байтом, а~под исходным текстом не всегда понимается произвольный бинарный файл.
% 
% \medskip


\beforetasks

%     \warningframebox{    
%     \textbf{Штраф $\mathbf{-2}$ балла,} если ЯВУ не совпадает с~\ref{task_lab_sizeof_otik}.
%     }

\begin{tasks}[before={}]


\item 
\label{lab_task_letters_stat}
% В~

Разработайте программу или используйте набор программ (в~частности, это может быть набор скриптов-однострочников, использующий стандартные утилиты GNU/Linux), который
обрабатывает заданный файл $Q$.

Символом% кодирования
, как всегда, является \emph{байт} (для %с~учётом использования 
% архитектуры 
x86/amd64 это 8 бит, \emph{октет}), первичным алфавитом $A_1 = \{a_1, \ldots, a_{|A_1|}\}$ "--- множество возможных значений байта 
% ($0 \ldots 255$).
$\{\hex{00}, \ldots, \hex{FF}\}$ или, что то же самое, $\{0, \ldots, 255\}$.
% То есть $a_j = j-1$. %, а~если нумеровать алфавит с~нуля, то $a_j = j$.

\medskip

Программа рассчитывает для $Q$:
\begin{itemize}
\item $n$ "--- длину файла~$Q$ в~символах первичного алфавита $A_1$ (в~байтах, так как символ = 8-битный байт x86/amd64);

% \item целочисленную частоту $\nu_i$ каждого из символов $a_j \in A_1$ алфавита (общее количество вхождений $a_j$ в~$Q$);
% \item $\nu_i$ "--- общее количество вхождений каждого из символов $a_j \in A_1$ в~$Q$ (целочисленную частоту $a_j$);
\item $count(a_j)$ "--- общее количество вхождений каждого из символов $a_j \in A_1$ в~$Q$ (ненормированную целочисленную частоту $\nu_{\text{ненорм}}(a_j)$);
\end{itemize}
% и~оценивает, считая файл 
% $Q = c_1 \ldots c_n$ из символов $c_i \in A_1$ первичного алфавита порождённым \emph{источником без памяти} (без учёта контекста):
и~оценивает, строя модель источника символов 
%$c_i \in A_1$ первичного алфавита 
по файлу $Q = c_1 \ldots c_n$ в~виде \emph{источника без памяти} (модель для сжатия без учёта контекста):
\begin{itemize}
\item $p_{\text{БП}}(a_j) = \frac{count(a_j)}{n}$ "--- вероятность каждого из символов $a_j \in A_1$;
\item $I_{\text{БП}}(a_j) = -\log_2 \Big(p_{\text{БП}}(a_j)\Big)$ [бит] "--- количество информации в~каждом символе $a_j \in A_1$;
\item 
% $I_{\text{БП}}(Q)$ 
$\displaystyle I_{\text{БП}}(Q) = \sum_{i=1}^{n} I_{\text{БП}}(c_i)$ [бит], $c_i \in Q$
"---
суммарное количество информации в~файле~$Q$ (не~среднее на символ, которое в~$n$ раз меньше, а~именно суммарное!). 
% в~битах.
% и~байтах;
\end{itemize}

% Сравните для каждого файла его длину в~байтах $n$ и~количество информации $I_{\text{БП}}(Q)$ в~байтах $\frac{}{}$
Сравните:
\begin{anumerate}
\item 
% длину файла $Q$ в~битах $n\cdot 8$ и~оценку $I_{\text{БП}}(Q)$ в~битах (печатайте оценку $I_{\text{БП}}(Q) \text{~[бит]}$ с~двумя знаками после запятой, а~также её дробную часть $\{I_{\text{БП}}(Q) \text{~[бит]}\}$ в~экспоненциальной форме);
длину $L(Q)\text{~[бит]} = n\cdot 8$ файла $Q$ в~битах
и~оценку $I_{\text{БП}}(Q) \text{~[бит]}$ суммарного количества информации в~$Q$  в~битах;
\mbox{для~$I_{\text{БП}}(Q) \text{~[бит]}$ печатать:}
\begin{itemize}
\item саму оценку $I_{\text{БП}}(Q) \text{~[бит]}$ с~двумя знаками после запятой;
\item её дробную часть $\{I_{\text{БП}}(Q) \text{~[бит]}\}$ в~экспоненциальной форме.
\end{itemize}
\bottompagebreak

\item длину $L(Q)\text{~[октетов]} = n$ файла $Q$ в~октетах (8"=битных байтах  x86/amd64) и~оценку в~октетах:
\begin{itemize}
\item 
% количества информации в~$Q$ по модели без памяти\\ 
$I_{\text{БП}}(Q) \text{~[октетов]} =
\frac{I_{\text{БП}}(Q) \text{~[бит]}}{8}$ 
% (либо печатайте с~двумя знаками после запятой, либо округляйте вверх, до $\left\lceil \frac{I_{\text{БП}}(Q)}{8} \right\rceil$);
(%печатайте 
с~двумя знаками после запятой);
\end{itemize}
а~также \emph{оценки снизу} %(больше "--- бывает) 
длин в~октетах для сжатия без учёта контекста:
\begin{itemize}
\item длины $E \text{~[октетов]} = \left\lceil I_{\text{БП}}(Q) \text{~[октетов]} \right\rceil 
%= \left\lceil \frac{I_{\text{БП}}(Q) \text{~[бит]}}{8} \right\rceil
$ только сжатого текста, без информации, необходимой для его декодирования;

% \medskip

\item длины 
 $G_{64} \text{~[октетов]} = E + 256\cdot 8$
архива, где к~сжатому тексту 
% (оценка длины снизу $\left\lceil \frac{I_{\text{БП}}(Q)}{8} \right\rceil$ октетов)
добавляется таблица $\left(\nu(\hex{00}), \ldots,  \nu(\hex{FF})\right)$ из  256 ненормированных 64"=битных частот $\nu_{\text{ненорм}}(j) = count(j)$;

% \medskip

\item длины 
 $G_{8} \text{~[октетов]} = E + 256\cdot 1$
архива, где к~сжатому тексту
добавляется таблица из 256 нормированных 8"=битных частот $\nu_{\text{норм}}(j)$.
%  $\nu_i$(однооктетных, $\forall i, j{:} ~~ \nu_i:\nu_j \approx count(a_j):count(a_j)$).
\end{itemize}
\end{anumerate}

% Найдите разницу (и~в~октетах, и~в~битах).
% Выгодно ли применять файлу $Q$ сжатие без учёта контекста (длина сжатого текста стремится к~рассчитанной оценке $I_{\text{БП}}(Q)$ без памяти), 
% если к~сжатому тексту будет необходимо добавить таблицу ненормированных 64"=битных частот $count(a_j)$?
% А если нормировать частоты до 8"=битных значений?

% \medskip

Все полученные величины необходимо напечатать на экране или сохранить в~виде текстового файла-отчёта; 
причём таблица характеристик символов алфавита 
$j \in A_1$ (символ, то есть байт $j$ "--- в~виде шестнадцатеричного значения байта, а~не~ASCII-символа; 
ненормированная частота $count(j);$ оценки вероятности $p(j)$ и~количества информации $I(j)$) должна либо печататься дважды:
\begin{itemize}
\item отсортированной по алфавиту (по значению $j$); 
\item отсортированной по убыванию 
% частоты $\nu_i$.
$count(j)$;
\end{itemize}
либо в~программе необходимо предусмотреть пересортировку.
\medskip

Проверьте разработанную программу на файлах различного формата (не только простом тексте; в~том числе и~на бинарных).

Выгодно ли применять к~проанализированным файлам сжатие без учёта контекста?
Нужно ли нормировать частоты?

\medskip

Для побайтового чтения используйте $fread()$ или её аналог в~используемом языке программирования.

Для проверки корректности используйте файлы с~заранее известным $I_{\text{БП}}(Q)$: для четырёх разных произвольных октетов $a$, $b$, $c$, $d$ %и~модели без памяти 
верно
$I_{\text{БП}}(a) = 0$ бит,
$I_{\text{БП}}(ab) = 2$ бита, $I_{\text{БП}}(abcd) = 4\cdot2 = 8$ бит (1 байт x86) и т.\,п.

\bigskip

\item \bonus{+3 балла для пар и~НБ, обязательное для ПИН-троек} 
\label{lab_task_letters_stat_utf8}
% 
Разработайте программу, аналогичную \ref{lab_task_letters_stat}, но считающую символом кодирования \emph{печатный или управляющий символ Unicode,} а~первичным алфавитом $A_1$ "--- множество символов Unicode (строчных букв, заглавных букв, цифр, различных пробельных символов, знаков препинания и~т.\,п) в~файле $Q$.


\medskip

\warningframebox{
Обратите внимание, что \ref{lab_task_letters_stat_utf8} и~связанное с~ним \ref{lab_task_markov1_stat_utf8} "--- \emph{единственные} задания %лабораторных работ
курса ОТИК, где
символ кодирования не обязательно является байтом, а~под исходным текстом не всегда понимается произвольный бинарный файл.
}

\medskip

При оценивании длины архива учитывайте, что первичный алфавит $A_1$  \ref{lab_task_letters_stat_utf8},
в~отличие от \ref{lab_task_letters_stat}, имеет переменные длину и~состав.
Соответственно, сохранять в~архиве нужно не массив из 256 частот 
% $\Big(\nu(0), ...,  \nu({255})\Big)$, 
$\Big(\nu(\hex{00}), ...,  \nu(\hex{FF})\Big)$, 
а:
\begin{itemize}
\item 64"=битную длину $|A_1|$ алфавита;
\item массив из  $|A_1|$ {пар} символ-частота: $\Big(\big(a_1, \nu(a_1)\big), ...,  \big(a_{|A_1|}, \nu(a_{|A_1|})\big)\Big)$,
где либо в~каждой паре символ $a_j \in A_1 \subseteq \mathrm{Unicode}$ имеет переменную длину (UTF-8 или UTF-16) либо в~каждой паре 32"=битен (UTF-32).
\end{itemize}
Какой будет длина в~октетах этих данных для исследуемых файлов?

\medskip

Какой была бы длина в~октетах, если бы сохранялись частоты не для символов файла $A_1 \subseteq \mathrm{Unicode}$, а~для всего Unicode (длина и~состав алфавита постоянны, сохраняются только частоты  $\Big(\nu(0), ...,  \nu\big(|\mathrm{Unicode}|-1\big)\Big)$)?


\medskip

% Рассчитайте две оценки количества информации в~длинном текстовом файле в~кодировке UTF-8 программами \ref{lab_task_letters_stat} и~\ref{lab_task_letters_stat_utf8}.
% Сравните результаты.

Исследуйте один и~тот же длинный текстовый файл в~кодировке UTF-8 программами \ref{lab_task_letters_stat} и~\ref{lab_task_letters_stat_utf8}.
Как выбор первичного алфавита %(байты или Unicode) 
влияет на:
\begin{itemize}
\item оценку $I_{\text{БП}}(Q)$ без учёта контекста;
\item оценку снизу длин архива для сжатия без учёта контекста?
\end{itemize}
Повторите анализ для других длинных текстовых файлов в~кодировке UTF-8.

\bigskip




\item 
\label{lab_task_letters_stat_ruenc}
{
Рассчитайте, используя программу \ref{lab_task_letters_stat}, частоты  октетов в~файлах, являющихся  простым текстом в~различных кодировках 
% (см. «\LABFILETEXTSPATH»).
(папка {\LABFILESCODEPAGESPATH}).
Исследуйте 
% разные языки, 
% несколько разных осмысленных текстов для каждого языка %(алфавит не подходит) 
несколько разных осмысленных русскоязычных текстов
и~все представленные кодировки.
\sloppy
% 
Определите 4 наиболее частых октета среди всех используемых и 4 наиболее частых октета, не являющихся кодами печатных символов ASCII. Обратите внимание на распределение октетов многобайтовых кодировок.

}


Рассчитайте частоты  октетов в~файле, соответствующем варианту $(\text{№}-1)\% 9$ в~папке 
% «\LABVARIANTSPATH/L\arabic{section}» 
{\LABFILESVARIANTCODEPAGESPATH}
(далее "--- файл $W$). 

Определите, является ли $W$  простым русскоязычным текстом в одной из стандартных кодировок (один из вариантов представляет собой нерусскоязычный текст); если да "--- определите кодировку.
%и декодируйте в UTF-8.

\bigskip


\item \lbonus[{} "--- источник с~памятью]{$+\bsingle$}
\label{lab_task_markov1_stat}

Разработайте программу, которая по заданному файлу $Q$ рассчитывает:
\begin{itemize}
% \item длину $n$ файла~$Q$ в~символах первичного алфавита $A_1$;
% % \item $\nu_i$ "--- общее количество вхождений каждого из символов $a_j \in A_1$ в~$Q$;
\item %$\nu_{ij}$ 
$count(a_j a_k)$
"--- количество вхождений подстрок $a_j a_k$;
\item %$\nu_{*j}$ 
$count(a_j *)$
"--- общее количество вхождений любых двухсимвольных подстрок, начинающихся с~$a_j$ (для всех символов, кроме последнего символа файла, 
% $\nu_{*j} = \nu_j$);
$count(a_j *) = count(a_j)$;
\end{itemize}
% и~оценивает, считая файл $Q$ порождённым \emph{стационарным источником Маркова первого порядка:}
и~оценивает, строя модель источника символов 
по файлу $Q = c_1 \ldots c_n$ в~виде \emph{стационарного источника Маркова первого порядка:}

\begin{itemize}
\item условную вероятность $p(a_k|a_j)
= \frac{count(a_j a_k)}{\sum_k count(a_j a_k)}
= \frac{count(a_j a_k)}{count(a_j *)}
$ каждой пары символов $a_j, a_k \in A_1$;
% \item безусловную вероятность 
% $p(a_j) = p_{\text{БП}}(a_j)
% $ 
% % $p(a_j)  = \frac{count(a_j *)}{\sum count(a_j *)} = \frac{count(a_j *)}{n-1}$
% каждого из символов $a_j \in A_1$;
\item суммарное количество информации $I_{\text{СМ1}}(Q)$ в~файле~$Q$ в~битах и~байтах
(безусловную вероятность $p(c_1 = a_j)$ считайте равной 
% $p_{\text{БП}}(a_j)$);
$\frac{1}{256}$);
\end{itemize}
% символом кодирования, как всегда, является \emph{байт} (с~учётом использования архитектуры x86 "--- октет), первичным алфавитом $A_1$ "--- множество возможных значений байта ($0 \ldots 255$).
% 
% Полученные величины необходимо вывести на экран или сохранить в~виде отчёта.
аналогично~\ref{lab_task_letters_stat} (символ кодирования = байт, как всегда).

\medskip

Для проверки корректности используйте файлы с~заранее известным $I_{\text{СМ1}}(Q)$: 
% для четырёх разных произвольных октетов $a$, $b$, $c$, $d$ %и~модели без памяти 
% верно:
\\
$I_{\text{СМ1}}(a) = I_{\text{СМ1}}(ab) = I_{\text{СМ1}}(abcd) = I_{\text{СМ1}}(abab) 
% = I_{\text{СМ1}}(aaaa) 
=  8$ бит (1 байт x86);
\\
$I_{\text{СМ1}}(abac) = 10$ бит ($1,25$ байтa x86);
~
$I_{\text{СМ1}}(aabacad) = 16$ бит ($2$ байтa x86).



\medskip



Проверьте разработанную программу на файлах различного формата (не только простом тексте; в~том числе и~на бинарных).
%
Сопоставьте результат с~\ref{lab_task_letters_stat}.

Таблицу частот какого размера нужно сохранить вместе со~сжатым текстом длины $I_{\text{СМ1}}(Q)$, чтобы успешно его декодировать?
% , если размер сжатого текста сопоставим с~найденной оценкой  $I_{\text{СМ1}}(Q)$?
Выгодно ли такое сжатие?

\medskip

\item\bonus{+3 балла}%
\label{lab_task_markov1_stat_utf8}%
Разработайте программу, аналогичную \ref{lab_task_markov1_stat}, но считающую символом кодирования \emph{печатный или управляющий символ Unicode,} аналогично \ref{lab_task_letters_stat_utf8}.

Проверьте разработанную программу,
сопоставьте результат с~\ref{lab_task_markov1_stat} и~\ref{lab_task_letters_stat_utf8}.


\end{tasks}

\subsection{О терминах}
\label{codes_termin_text_1}

\textbf{Символ кодирования} в~ТИ есть элемент (квант) качественной информации. В~кодировании (то есть сжатии, защите от помех или шифровании) символом является, как правило, \textbf{байт} (для x86 "--- октет); изредка "--- отдельный бит (символ вторичного алфавита Хаффмана или первичного алфавита Хэмминга) или битовый блок отличной от байта длины; и~никогда "--- печатный символ  ASCII, KOI-8, Unicode etc (технически реализовать можно, как показывают задания~\ref{lab_task_letters_stat_utf8}/\ref{lab_task_markov1_stat_utf8}, но смысла в~этом нет).

\textbf{Текст, строка}  "--- последовательность символов в~указанном выше смысле (в~общем случае бинарный файл и~его фрагменты).
\textbf{Алфавит}  "--- множество всех возможных символов в~указанном выше смысле.


Не обманывайтесь принятой в~кодировании терминологией! 

Кто обманется и~воспользуется функцией $fgetc()$ (или, тем более, $readLine()$, $split()$ и~т.\,п.) где-то, кроме~\ref{lab_task_letters_stat_utf8}/\ref{lab_task_markov1_stat_utf8} "--- минус 2 балла.

\subsection{Об округлении}

Если количество информации или оценка длины чего-либо округляется до целого числа битов/октетов,
округление должно выполняться \textbf{вверх.}
Для хранения десяти полных байтов и~ещё одного бита понадобится одиннадцать байтов.



\subsection{О единицах измерения}

% Единственной безразмерной величиной в~\ref{lab_freq} является вероятность $p$ и~её оценки.
Единственная безразмерная величина в~\ref{lab_freq} "--- вероятность $p$ и~её оценки.

% Длина файла в~байтах $L(Q) = n$ и~ненормированные частоты $count(a_j)$ измеряются в~\textbf{байтах.}

Количество информации, как и~длина файла, может быть измерено как в~битах, так и~в кратных единицах: байтах% (байт x86/amd64 = октет)
, килобайтах и~др.;
диадах, триадах, тетрадах, октетах и~др.
% 
Значение $n$ (длина файла в~байтах) измеряется в~{байтах} x86/amd64, то есть~\textbf{октетах.} 
% 
% Длина файла $n$ измеряется в~{байтах} x86/amd64, то есть~\textbf{октетах.} 
Количество информации, рассчитываемое по формуле $I = -\log_2 p$, измеряется в~\textbf{битах} "--- 
в~октеты рассчитанное значение либо необходимо переводить ($I ~\text{[октетов]} = \frac{I \text{~[бит]}}{8}$),
либо изначально использовать формулу Шеннона в~виде $I ~\text{[октетов]} = -\log_{256} p = -\frac{\log_2 p}{8}$.

% Для того, чтобы количество информации  было выражено в~октетах, его надо 
% либо изначально рассчитывать по формуле $I = -\log_{256} p = \frac{-\log_2 p}{8} ~\text{[октетов]}$,
% либо после расчёта $I \text{~[бит]}$ переводить из битов в~октеты: $I ~\text{[октетов]} = \frac{I \text{~[бит]}}{8}$.
% 
% % Аналогично, для того, чтобы полученное при помощи 



Если кто-то станет сравнивать численное значение $n$ [октетов] с~численным значением $I$ [бит] и~делать из соотношения этих чисел какие-то выводы
"--- 
\ref{lab_freq} не~будет засчитана, пока команда не разберётся с~используемыми единицами измерения.


% Чтобы корректно сравнивать между собой длину файла и~количество информации в~нём, обе величины должны быть выражены в~одних единицах:
% \begin{itemize}
% \item в~битах: длина файла $L(Q) \text{[бит]} = n\cdot 8$ и~$I(Q)$ [бит];
% \item в~октетах: длина файла $L(Q) \text{[октетов]} = n$ и~$I(Q) \text{[октетов]} = \frac{I_{\text{БП}}(Q) \text{~[бит]}}{8}$;
% 
% \end{itemize}

