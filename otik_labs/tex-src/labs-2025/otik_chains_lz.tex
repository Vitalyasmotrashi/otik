% \labwork{Алгоритмы сжатия данных с учётом контекста}
% \labwork{Источник Маркова. Алгоритмы сжатия данных с~учётом контекста}
\labwork{Сжатие данных с учётом контекста}

\label{lab_otik_chains_lz}
\label{lab_markov}

% % Максимальная оценка обязательной части "--- $\bdouble$ баллов. Максимум графы $\bdouble+\bdouble$ включает бонусное задание \ref{lab_task_codec_lz77}.
% Максимальная оценка ПИН обязательной части "--- $\bdouble$ баллов. Максимум графы 
% % $\bdouble+\bdouble$ включает %бонусное задание 
% % \ref{lab_task_codec_lz77}.
% $\bdoubleWithbonus=\bdouble+\bdoublebonus$ включает все бонусные задания и~бонус за качество исполнения.
% 
% Для НБ "--- бонус $+16$ полная, $+8$ упрощённая.
\doubleLab{}


\taskabsencepenalty{3}

\begingroup

% https://latex-tutorial.com/wp-content/uploads/2021/05/Mathmode.pdf
% LATEX defines the three math lengths12with the following values13:1\thinmuskip=3mu2\medmuskip=4mu plus 2mu minus 4mu3\thickmuskip=5mu plus 5mu

\thinmuskip=10mu % после запятой
\medmuskip=2mu plus 2mu minus 2mu % вокруг минуса
\thickmuskip=3mu plus 2mu minus 3mu % вокруг :

\newcommand\compact{\thinmuskip=3mu}
\let\oldldots\ldots
% \def\ldots{ {\compact{\oldldots}} }
\def\ldots{ {...} }


\utask{$\BU{}$}

Разработайте кодер и~декодер «наивного» RLE.
Продемонстрируйте работу кодера и~декодера.

\textbf{Штраф $\mathbf{-3}$ балла}  за текстовое представление архива или если кодер обрабатывает только файлы в~текстовом представлении "--- см.~раздел~\ref{codes_termin_text}.


\medskip

Засчитывается только в~том случае, если все студенты команды знают:
\begin{anumerate}
\item сколько байтов %(и~соответственно, сколько бит) 
они отводят на код $\widetilde{L}$ длины цепочки $L$;
\item в~каком виде записывают длину цепочки $L \geqslant 1$ в~эти байты: $\widetilde{L}  = L-1$ или $\widetilde{L}  = L$;
\item какое максимально допустимое значение $L_{\max}$ для длины цепочки $L$ следует из сделанного ими выбора (а) и~(б);
\item в~каком порядке  записывают код цепочки «наивного» RLE: $(\widetilde{L}, c)$ или $(c, \widetilde{L})$; 
\end{anumerate}
и~если они корректно обрабатывают б\'{o}льшее, чем $L_{\max}$, количество повторений подряд одного символа $c$ в~файле.


\begin{tasks}



\item 
\label{lab_task_codec_rle}
Разработайте программу-кодек, реализующую сжатие/разжатие файла методом  RLE
согласно варианту (таблица~\ref{tab_labs_rle_variants}).
\begin{table}[!ht]
\caption{Варианты кодов семейства RLE}
\label{tab_labs_rle_variants}
\begin{variants}{tab_labs_rle_variants}
флаг-бит сжатая/несжатая цепочка;
цепочка \mbox{из $L\geqslant 3$ одинаковых} символов $c\ldots c$  как $\Big(1:1, (L-3):7, c:8\Big)$, \mbox{из  $L\geqslant 1$ разных} $c_1\ldots c_L$ "--- как $\Big(0:1, (L-1):7, c_1:8, {\ldots} ~ c_L:8\Big)$
\next

префикс $p$;
\mbox{цепочка из $L\geqslant 4$ одинаковых} символов $c\ldots c, c \neq p$  как $\Big(p:8, (L-3):8, c:8\Big)$,
\mbox{цепочка из $L\geqslant 2$ символов $p\ldots p$  как $\Big(p:8, (L-1):8, p:8\Big)$,}
одиночный $p$ как $(p:8, 0:8)$
\next

префикс $p$;
\mbox{цепочка из $L\geqslant 4$ одинаковых} символов $c\ldots c, c \neq p$  как $\Big(p:8, (L-4):8, c:8\Big)$,
\mbox{цепочка из $L\geqslant 1$ символов $p\ldots p$  как $\Big(p:8, (L-1):8, p:8\Big)$,} в~том числе
одиночный $p$ как $(p:8, 0:8, p:8)$
\end{variants}
\end{table}%
Здесь и~далее в~разных вариантах используются разные коды/алгоритмы, реализующие один заданный метод "--- семейство кодов и~алгоритмов.
% 
Если вы не поняли, какой код нужно реализовать в~вашем варианте "--- спрашивайте.
«Какая-нибудь» реализация заданного метода, не соответствующая варианту "--- не засчитывается.

\medskip

Вычислите минимальные и~максимальные возможные значения $L$ для своего варианта (для всех возможных случаев).


Сопоставьте длину сжатых данных с~оценкой количества информации в~исходном файле по модели Маркова (\ref{lab_task_markov1_stat}), а~также с~объёмом таблицы частот в~\ref{lab_task_markov1_stat}.


\item 
\label{lab_task_codec_lz78}
Разработайте программу-кодек, реализующую сжатие/разжатие файла методом  LZ78
согласно варианту (таблица~\ref{tab_labs_lz77_variants}).
\begin{table}[!ht]
\caption{Варианты кодов семейства LZ78}
\label{tab_labs_lz78_variants}
\begin{variants}{tab_labs_lz78_variants}
концепт Зива и~Лемпеля 1978 года 
\next
LZW
\end{variants}


\end{table}%





\item  \lbonus{$+\bdouble$}
\label{lab_task_codec_lz77}
Разработайте программу-кодек, реализующую сжатие/разжатие файла методом  LZ77
согласно варианту (таблица~\ref{tab_labs_lz77_variants}).
\begin{table}[!ht]
\caption{Варианты кодов семейства LZ77}
\label{tab_labs_lz77_variants}
\begin{variants}{tab_labs_lz77_variants}
% концепт Зива и~Лемпеля (строгое чередование ссылок $\compact\{S, L\}$ и~несжатых символов);
% ссылка $\compact\{S, L\}$ записывается следующим образом: сначала 10 бит $S$, затем 6 бит $L$ (далее обозначаем это $(S:10, L:6)$)
концепт Зива и~Лемпеля; 
ссылка $\compact\{S, L\}$  как $(S:10, L:6)$
\next
концепт Зива и~Лемпеля; 
ссылка $\compact\{S, L\}$  как $(L:6, S:10)$

\next
флаг-бит ссылка/цепочка;
ссылка $\compact\{S, L\}$  как $\Big(1:1, (L-3):7, (S-1):8\Big)$, \mbox{цепочка $c_1\ldots c_L$  как $\Big(0:1, (L-1):7, c_1:8, {\ldots} ~ c_L:8\Big)$,}




% \next
% % выходной файл рассматривается как битовый поток, 
% % каждая ссылка или символ предваряется флаг-битом:
% % символ $c$ как $(0:1, c:8)$, ссылка $\compact\{S, L\}$ как $\Big(1:1, (S-1):9, (L-1):8\Big)$
% флаг-бит ссылка/символ;
% ссылка $\compact\{S, L\}$  как $\Big(1:1, (S-1):9, (L-1):8\Big)$, символ $c$ "--- как $(0:1, c:8)$
% \next
% % выходной файл рассматривается как битовый поток, каждая ссылка или символ предваряется флаг-битом:
% % символ $c$ как $(0:1, c:8)$, ссылка $\compact\{S, L\}$ как $\Big(1:1, (S-1):10, (L-2):7\Big)$
% флаг-бит ссылка/символ;
% ссылка $\compact\{S, L\}$  как $\Big(1:1, (S-1):10, (L-2):7\Big)$, символ $c$ "--- как $(0:1, c:8)$
\next
флаг-биты ссылка/символ группируются во флаг-байты; 
ссылка $\compact\{S, L\}$ записывается как $\Big(S:10, (L-3):6\Big)$ "--- LZJB
\next
флаг-биты ссылка/символ группируются во флаг-байты; 
ссылка $\compact\{S, L\}$ записывается как $\Big((L-3):6, S:10\Big)$ 
% \next
% флаг-биты ссылка/символ группируются во флаг-байты; 
% ссылка $\compact\{S, L\}$ записывается как $\Big((L-3):6, (S-1):10\Big)$ 
\next
префикс $p$; ссылка $\compact\{S, L\}$ как $\Big(p:8, S:10, (L-4):6\Big)$, символ $c=p$ в~тексте "--- как $\Big(p:8, 0:8, 0:8\Big)$
\next
префикс $p$; ссылка $\compact\{S, L\}$  как $\Big(p:8, (L-3):6, (S-1):10\Big)$, символ $c=p$ в~тексте "--- как $\Big(p:8, 0:8\Big)$
\end{variants}


\end{table}%

Запись в~таблице $(S:10, L:6)$ обозначает: сначала записывается 10 бит $S$, затем 6 бит $L$.
% Для вариантов с~флаг-битом выходной поток \emph{битовый.}
%
Для концепта Зива и~Лемпеля символ $c$ записывается как $(c:8)$ (то есть просто как байт $c$); для реализации с~односимвольным префиксом $p$ символ $c\neq p$ также записывается как  $(c:8)$.
%
Если ссылка отделяется от несжатого текста односимвольным префиксом $p$, значение $p$ выбирать для каждого исходного текста $Q$ отдельно, исходя из частот символов в~$Q$.

Вычислите минимальные и~максимальные возможные значения $S$ и~$L$ для своего варианта.




\item \bonus{+2 балла для пар, обязательное для троек} 
\label{lab_task_codec_lz_univ_update}
Доработайте универсальный декодер из задания~\ref{lab_task_decoder_univ} и~кодер из задания~\ref{lab_task_coder_min}
с~учётом всех реализованных алгоритмов.

\item \bonus{+5 для пар, +2 для троек, обязательное для четвёрок%, если они к~этому моменту ещё не распались естественным путём
}
Доработайте универсальные кодер и~декодер так, что к~одному файлу было возможно применить последовательно:
\begin{enumerate}[label=\arabic*)]
\item вначале сжатие с~учётом контекста;
\item затем сжатие без учёта контекста.
\end{enumerate}
Баллы не начисляются, если кодер/декодер сводятся к~последовательному запуску двух программ, то есть если на первом проходе формируется заголовок формата~\ref{lab_task_intro_format}, и~второй проход рассматривает этот заголовок как часть исходного текста.

Конкретные алгоритмы выбираются при запуске: сжатие с~контекстом из реализованных в~данной л/р, без контекста "--- из реализованных в~предыдущей л/р.

% \item \bonus{+12 баллов}
% \label{lab_task_rle_stat}
% Постройте модель


% \item \bonus{+6 баллов}
% \label{lab_task_markov1_stat}
% % В~
% 
% Разработайте программу, которая по заданному файлу $Q$ рассчитывает:
% \begin{itemize}
% \item длину $n$ файла~$Q$ в~символах первичного алфавита $A_1$;
% % \item $\nu_i$ "--- общее количество вхождений каждого из символов $a_i \in A_1$ в~$Q$;
% \item $\nu_{ij}$ "--- количество вхождений подстрок $a_j a_i$;
% \item $\nu_{*j}$ "--- общее количество вхождений любых двухсимвольных подстрок, начинающихся с~$a_j$ (для всех символов, кроме последнего символа файла, $\nu_{*j} = \nu_j$);
% \end{itemize}
% и~оценивает, считая файл $Q$ порождённым источником Маркова первого порядка:
% \begin{itemize}
% \item безусловную вероятность $p(a_i)$ каждого из символов $a_i \in A_1$;
% \item условную вероятность $p(a_i|a_j)$ каждой пары символов $a_i, a_j \in A_1$;
% \item оценивает суммарное количество информации $I(Q)$ в~файле~$Q$ в~битах и~байтах;
% \end{itemize}
% символом кодирования, как всегда, является \emph{байт} (с~учётом использования архитектуры x86 "--- октет), первичным алфавитом $A_1$ "--- множество возможных значений байта ($0 \ldots 255$).
% 
% Полученные величины необходимо вывести на экран или сохранить в~виде отчёта.
% 
% 
% Таблицу $T_\nu$ частот $\nu_{ij}/\nu_{*j}$, описывающую источник-модель, сохраните в~файл и~оцените:
% \begin{itemize}
% \item размер $|T_\nu|$ в~байтах;
% \item количество информации в~ней "--- оценка $I_{\text{Хф}} (T_\nu)$ по модели без памяти (\ref{lab_task_letters_stat});
% \end{itemize}
% полученные величины необходимо вывести на экран или сохранить в~виде отчёта.
% 
% 
% Проверьте разработанную программу на файлах различного формата (не только простом тексте; в~том числе и~на бинарных).
% %
% Сопоставьте результат с~\ref{lab_task_letters_stat}.



% \item  \bonus{+6 баллов}
% \label{lab_task_markovN_stat}
% Разработайте программу, аналогичную \ref{lab_task_markov1_stat}, но считающую $Q$ порождённым источником Маркова порядка $N$ и, соответственно, рассматривающую $(N+1)$-символьные подстроки и~условные вероятности $p(a_i|a_{j_1}a_{j_2}\ldots a_{j_N})$.
% 
% Для упрощения расчёта полагайте $n \gg N$, то есть вероятности первых $N$ символов файла рассчитывайте без учёта контекста.
% 
% 
% Проверьте разработанную программу на файлах различного формата и~при различных $N \in [1, 4]$.
% Сопоставьте результат при $N=1$ с~\ref{lab_task_markov1_stat}.
% 
% \descrcomment{если реализован общий случай, но нет отдельной программы для $N=1$ "--- задание \ref{lab_task_markov1_stat} не считается пропущенным, общий бонус $+12$.
% }


% \item \bonus{+4 балла}
% Рассмотрите несколько файлов 
% Для каждого файла $Q$:
% \begin{itemize}
% \item рассчитайте оценку количества информации $I(Q)$ в~
% \end{itemize}
% Сопоставьте длину сжатых данных с~оценками количества информации в~исходном файле по марковским моделям порядка от 1 до 4 (\ref{lab_task_markov1_stat}, \ref{lab_task_markovN_stat}).
% 
% 
% Сохраните в~файл таблицу частот (размера $265\times256$ для первого порядка и~$265^{N+1}$ для $N$-го) и~оцените количество информации в~ней по модели без памяти (программой~\ref{lab_task_letters_stat})




\end{tasks}

\FloatBarrier
\endgroup

% \subsection{Дополнительные бонусные и~штрафные баллы}
% 
% 
% % \item 
% % \label{lab_task_codec_lz_univ_update}
% 
% $+3$ для пар, обязательно для троек
% Доработайте универсальный декодер из задания~\ref{lab_task_decoder_univ} и~кодер из задания~\ref{lab_task_coder_min}
% с~учётом всех реализованных алгоритмов.
% 
% $+8$ баллов, если реализованные программы позволяют применить к~файлу последовательно любой алгоритм сжатия с~учётом контекста, а~затем сжатие без учёта контекста.
% % (аналогично \ref{lab_markov}).
% 
% 
