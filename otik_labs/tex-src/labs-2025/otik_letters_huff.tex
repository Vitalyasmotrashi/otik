% \labwork{Частотность. Алгоритмы сжатия данных без учёта контекста (энтропийного сжатия), формирующие разделимые коды}
% \labwork{Источник без памяти. Алгоритмы сжатия данных без учёта контекста (энтропийного сжатия), формирующие разделимые коды}
% \labwork{Источник без памяти. %Кодирование Хаффмана
% Алфавитное префиксное кодирование
% }
\labwork{Сжатие данных без учёта контекста \mbox{(энтропийное сжатие)}}
\label{lab_otik_letters_huff}

% Максимальная оценка ПИН обязательной части "--- $\bdouble$ баллов. Максимум графы $\bdouble+\bdouble$ включает %бонусное задание 
% \ref{lab_task_ac}.
% Для НБ "--- бонус $+16$ полная, $+8$ упрощённая.
\doubleLab{}

\taskabsencepenalty{3}


\utask{$\BU{}$}

Используйте демонстрационные программы любой свободной библиотеки для сжатия методом Хаффмана, Шеннона"--~Фано, Шеннона либо целочисленным арифметическим (интервальным) методом.
Узнайте из документации, какой метод используется и~что является символом кодирования.

Продемонстрируйте работу кодера и~декодера.
Сопоставьте длину сжатых данных с~оценкой количества информации в~исходном файле (\ref{lab_task_letters_stat}).

\medskip

Отличие упрощённого задания от полного, реализованного с~помощью библиотеки со свободной лицензией "--- в~управлении заголовком.

В упрощённом задании студент использует демонстрационную программу «как есть»; полное может быть засчитано только в~том случае, если запись/чтение заголовка реализованы студентом и~могут быть изменены.

\medskip

Засчитывается только в~том случае, если студент может доказать, используя документацию библиотеки,
что используется именно заявленный студентом метод сжатия без учёта контекста и~только он (а~не, например, связка LZW+Хаффман).


\medskip


\begin{tasks}

\item 
\label{lab_task_codec_huff}
Разработайте программу-кодек (аналогично \ref{lab_task_intro_codec_echo}), 
реализующую сжатие/разжатие файла методом Хаффмана.


Сигнатура формата должна совпадать с~выбранной в~\ref{lab_task_intro_signature}.
Если в~формат необходимо внести какие-либо изменения по сравнению с~\ref{lab_task_intro_format} "--- они должны быть описаны в~отчёте, а~номер версии "--- изменён.
% Декодер должен корректно обрабатывать файл, сжат

Также в~отчёте обязательно должны быть описаны:
\begin{itemize}
\item код алгоритма, не равный 0 (если выполняются бонусные задания ниже "--- разным алгоритмам должны соответствовать разные коды);
\item состав информации для декодирования и~формат её хранения в~файле; 
\item принятые при построении дерева уточнения (порядок сортировки при совпадении частот
% , для Шеннона"--~Фано ниже "--- стратегия разбиения при невозможном равенстве веса частей 
и~т.\,п.).
\end{itemize}

% \item 
Сопоставьте длину сжатых данных с~оценкой количества информации в~исходном файле по стационарной модели без памяти (\ref{lab_task_letters_stat}),
а~длину архива "--- с~её оценкой снизу (\ref{lab_task_letters_stat}).

\bottompagebreak


\item 
% \bonus{+3 балла для пар, обязательное для троек} 
\label{lab_task_size_with_frec}

% \makeatletter
% \def\csizefrec#1{\expandafter\@csizefrec\csname c@#1\endcsname}
% \def\@csizefrec#1{\ifcase#1\or 32\or 8\or 4\or
% Fourth\or Fifth\or Sixth\fi}
% \makeatother
% \AddEnumerateCounter{\csizefrec}{\@csizefrec}{Second}
% 
% Разработайте программу, рассчитывающую для файла длиной до $2^{32}-1$ байт коды Хаффмана в~трёх случаях:
% \begin{enumerate}[label=\csizefrec*)]
% \item по ненормализованным частотам байтов в~диапазоне $0...2^{32}-1$ (для хранения одного значения необходимо $|\nu_{32}| = 4$ байта);
% \item по частотам, приведённым к~диапазону $0...255$ ($|\nu_{8}| = 1$ байт);
% \item по частотам, приведённым к~диапазону $0...15$ ($|\nu_4| = \frac{1}{2}$ байта).
% \end{enumerate}
% Частоты нормализовывать таким образом, чтобы ноль переходил в~$0$, единица в~$1$ (то есть чтобы ненулевые частоты не превращались в нулевые).
% 
% Для каждого $|\nu_{i}|$ программа должна рассчитывать:
% \begin{itemize}
% \item длину $E_i$ сжатых данных файла в~байтах;
% \item общую длину $G_i = E_i + 256\cdot|\nu_i|$ данных, необходимых для распаковки (сжатых данных $E_i$ и~массива частот) в~байтах.
% \end{itemize}
% Собственно архивы со сжатыми данными можно не создавать.
% 
% Для файла программа должна рассчитывать $\displaystyle
% i^*: ~  G_{i^*} = \min_{i}(G_i)
% $.
% 
% Для каждого из нескольких различных файлов сравните $E_{32}$, $E_{8}$ и~$E_4$, а~также $G_{32}$, $G_{8}$ и~$G_4$; запишите в~отчёт.
% % Какой из перечисленных диапазонов выгоднее использовать (и, соответственно, какую разрядность использовать для частот)?
% 
% \medskip
% 
% Дополнительно {+1 балл,} если программа перебирает для файла все возможные разрядности $i$ от 3 до 32 бит;
% для каждой разрядности:
% \begin{itemize}
% \item приводит частоты к~диапазону $0...(2^i - 1)$;
% \item по приведённым частотам рассчитывает $E_i$ и~$G_i = E_i + 256\cdot\frac{i}{8} = E_i + 32\cdot i$ в~байтах.
% \end{itemize}
% Какая разрядность $i$, по вашему мнению, лучше подходит для использования (удобнее в~чтении/записи и~при этом даёт достаточно малое $G_i$)?
% Предложите способ сохранения массива из 256 $i$-битных частот в~$32\cdot i$ байтов.
% 
% \medskip
% 
% Дополнительно {+2 балла} за графическое изображение зависимостей $\frac{E_i}{E_{32}}$ и~$\frac{G_i}{G_{32}}$ от $i$ для набора из 10 или более файлов разного типа.
% В~итоге должно получиться одно изображение для $E$ (либо со множеством графиков на нём, либо с~«ящиками с~усами») и~одно для $G$, независимо от количества файлов "--- если на каждый файл будет свой график, баллы не начисляются.


\makeatletter
\def\csizefrec#1{\expandafter\@csizefrec\csname c@#1\endcsname}
\def\@csizefrec#1{\ifcase#1\or 64\or 32\or 8\or 4\or
Fourth\or Fifth\or Sixth\fi}
\makeatother
\AddEnumerateCounter{\csizefrec}{\@csizefrec}{Second}

Разработайте программу, рассчитывающую для файла коды Хаффмана (собственно архивы со сжатыми данными можно не создавать):
\begin{enumerate}[label=\csizefrec*)]
\item по ненормализованным частотам байтов $\nu_{64}(j) = count(j)$ в~диапазоне $0 \ldots 2^{64}-1$ (для хранения одного значения необходимо $|\nu_{64}| = 8$ байт);
\item по усечённым (для файла длиной до $2^{32}-1$) или нормализованным к~диапазону $0 \ldots 2^{32}-1$ для больших файлов частотам ($|\nu_{32}| = 4$ байта);
\item по частотам, приведённым к~диапазону $0 \ldots 255$ ($|\nu_{8}| = 1$ байт);
\item по частотам, приведённым к~диапазону $0 \ldots 15$ ($|\nu_4| = \frac{1}{2}$ байта).
\end{enumerate}
Частоты нормализовывать таким образом, чтобы ноль переходил в~$0$, единица в~$1$ (то есть чтобы ненулевые частоты не превращались в нулевые).

\medskip

\warningframebox{
В~отличие от \ref{lab_task_letters_stat}, где рассчитывается оценка снизу длины сжатого текста и~длины архива
"--- здесь рассчитывается точное значение.
}

% \medskip

% Для файла длиной до $2^{32}-1$ можно $\nu_{32}\equiv \nu_{64}$.

Для каждого $|\nu_{B}|$ программа должна рассчитывать:
\begin{itemize}
\item длину $E_B$ сжатых данных файла в~байтах;
\item общую длину 
% $G_B = E_B + 256\cdot|\nu_B|$ 
$G_B$
данных, необходимых для распаковки (сжатых данных $E_B$ и~массива частот) в~байтах:
$G_B = E_B + 256\cdot\frac{B}{8} = E_B + 32\cdot B$.
\end{itemize}
% Собственно архивы со сжатыми данными можно не создавать.
% 
Для файла программа должна рассчитывать наиболее выгодную разрядность 
% $\displaystyle
% B^*: ~  G_{B^*} = \min_{B}(G_B)
% $
% частот.
$B^*$ частот $\displaystyle \Big(G_{B^*} = \min_{B}(G_B)\Big)$ для сжатия методом Хаффмана.


\medskip

Для каждого из нескольких различных файлов сравните $E_{64}$,  $E_{32}$, $E_{8}$ и~$E_4$, а~также $G_{64}$, $G_{32}$, $G_{8}$ и~$G_4$; сравните $B^*$; запишите в~отчёт.
% Какой из перечисленных диапазонов выгоднее использовать (и, соответственно, какую разрядность использовать для частот)?

Насколько выводы \ref{lab_task_size_with_frec}, учитывающие огрубление частот при приведении к~заданному диапазону,
отличаются от предварительных выводов \ref{lab_task_letters_stat}?

\medskip

Выгодно ли встраивать в~реализацию алгоритма подбор  $B^*$ для конкретного файла? Учитывайте время и~необходимость сохранения такого  $B^*$ в~заголовке.

Какая фиксированная для алгоритма разрядность $B^{**}$ лучше подходит для использования (удобнее в~чтении/записи и~при этом даёт достаточно малое $G_B$)?
Предложите способ представления 256 $B^{**}$-битных частот в~виде $32\cdot B^{**}$ байтов.

\medskip

{$+2$ балла,} если программа перебирает для файла все возможные разрядности $B$ от 1 до 64 бит
% ;
% для каждой разрядности:
% \begin{itemize}
% \item приводит частоты к~диапазону $0 \ldots (2^B - 1)$;
% \item по приведённым частотам рассчитывает длину $E_B$ сжатых данных и~общую длину $G_B = E_B + 256\cdot\frac{B}{8} = E_B + 32\cdot B$ архива в~байтах;
% \end{itemize}
и~рассчитывает $B^*$ среди всех, а~не только 64/32/8/4.

\medskip

{$+2$ балла} за графическое изображение зависимостей $\frac{E_B}{E_{64}}$ и~$\frac{G_B}{G_{64}}$ от $B$ для набора из 10 или более файлов разного типа.
В~итоге должно получиться одно изображение для $E$ (либо со множеством графиков на нём, либо с~«ящиками с~усами») и~одно для $G$, независимо от количества файлов "--- если на каждый файл будет свой график, баллы не начисляются.

Графики и~сделанные из них выводы "--- продублировать лектору, для истории.

\bottompagebreak





\item 
\label{lab_task_decoder_univ}

Разработайте универсальный декодер разработанного формата, который:
\begin{itemize}
\item проверяет сигнатуру на соответствие выбранной в~\ref{lab_task_intro_signature}, при некорректной сигнатуре прекращает работу;
\item при корректной сигнатуре  "--- проверяет номер версии формата: для предыдущих версий формата вызывает свою старую версию, при ещё неизвестном номере версии прекращает работу;
\item при корректных сигнатуре и~версии "--- коды алгоритмов, после чего вызывает соответствующий им декодер из заданий \ref{lab_task_intro_codec_echo} или \ref{lab_task_codec_huff}.
\end{itemize}
В~дальнейшем необходимо будет дополнять анализ при добавлении нового алгоритма (при этом любая модификация "--- например, реализация метода Хаффмана с~другим порядком сортировки при совпадении частот "--- должна оформляться именно как новый алгоритм с~новым кодом).




\item \bonus{+3 балла} 
\label{lab_task_coder_min}

Разработайте «интеллектуальный» кодер, который анализирует суммарный объём $n_{compr}$ сжатых данных и~информации для декодирования \ref{lab_task_codec_huff} 
и,~если $n_{compr} \geqslant n$, записывает в~полученный архив несжатый текст исходного файла (то есть использует вместо кодера \ref{lab_task_codec_huff} кодер \ref{lab_task_intro_codec_echo}; код алгоритма при этом также должен быть 0).




Сразу предусмотрите флаг для отключения анализа и~принудительного использования заданного алгоритма.




\item \lbonus[{} "--- арифметический/интервальный кодек]{$+\bdouble$}
\label{lab_task_ac}

Разработайте программу-кодек (аналогично \ref{lab_task_codec_huff}--\ref{lab_task_coder_min}), 
реализующую сжатие/разжатие файла целочисленным арифметическим (интервальным) методом.



\item 
% \bonus{+3 балла}
\bonus{+3 балла для пар, обязательное для троек} 
\label{tab_labs_nohuff_old}

Разработайте программу-кодек (аналогично \ref{lab_task_codec_huff}--\ref{lab_task_coder_min}), 
реализующую сжатие/разжатие файла методом, соответствующим варианту (таблица~\ref{tab_labs_nohuff_variants}).
\begin{table}[!ht]
\caption{Варианты \ref{tab_labs_nohuff_old}
% методов сжатия файла без учёта контекста (модель без памяти)
}
\label{tab_labs_nohuff_variants}
\begin{variants}{test_tab_labs_nohuff_variants}
метод Шеннона
\next
метод Шеннона"--~Фано
\end{variants}

\end{table}%




\bottompagebreak



















\medskip

% \makeatletter
% \def\csizefrec#1{\expandafter\@csizefrec\csname c@#1\endcsname}
% \def\@csizefrec#1{\ifcase#1\or $4$\or $1$\or $\frac{1}{2}$\or
% Fourth\or Fifth\or Sixth\fi}
% \makeatother
% \AddEnumerateCounter{\csizefrec}{\@csizefrec}{Second}
% 
% \item \bonus{+2 балла}
% \label{lab_task_size_with_frec}
% 
% Разработайте программу, рассчитывающую для файла длиной до $2^{32}-1$ байт коды Хаффмана в~трёх случаях:
% \begin{enumerate}[label=\csizefrec*)]
% \item по ненормализованным частотам байтов в~диапазоне $0...2^{32}-1$ (для хранения одного значения необходимо $|\nu_{4}| = 4$ байта);
% \item по частотам, приведённым к~диапазону $0...255$ ($|\nu_{1}| = 1$ байт);
% \item по частотам, приведённым к~диапазону $0...15$ ($|\nu_{\frac{1}{2}}| = \frac{1}{2}$ байта).
% \end{enumerate}
% Частоты нормализовывать таким образом, чтобы ноль переходил в~$0$, единица в~$1$ (то есть чтобы ненулевые частоты не превращались в нулевые).
% 
% Для каждого $|\nu_{i}|$ программа должна рассчитывать:
% \begin{itemize}
% \item длину $E_i$ сжатых данных файла в~байтах;
% \item общую длину $G_i = E_i + 256\cdot|\nu_i|$ данных, необходимых для распаковки (сжатых данных $E_i$ и~массива частот) в~байтах.
% \end{itemize}
% Собственно архивы со сжатыми данными можно не создавать.
% 
% Для каждого из нескольких различных файлов сравните $E_{4}$, $E_{1}$ и~$E_{\frac{1}{2}}$, а~также $G_{4}$, $G_{1}$ и~$G_{\frac{1}{2}}$; запишите в~отчёт.
% Какой из перечисленных диапазонов выгоднее использовать (и, соответственно, какую разрядность $|\nu|$ использовать для частот)?





\end{tasks}


\subsection{Дополнительные бонусные и~штрафные баллы}

$-4$ балла за текстовое представление архива или если кодер обрабатывает только файлы в~текстовом представлении "--- см.~раздел~\ref{codes_termin_text}.

$-2$ балла, если массив частот может для какого-то одного файла иметь длину более 256 байтов.

$-2$ балла, если формат архива не соответствует \ref{lab_task_intro_format} (штраф не начисляется, если в~отчёте описана новая версия формата, которая логичнее исходной).

$-4$ балла, если даже сигнатура не совпадает с~\ref{lab_task_intro_signature}.

$-2$ балла, если ранее разработанный декодер \ref{lab_task_intro_codec_echo} пытается декодировать архив \ref{lab_task_codec_huff}, а~не выдаёт сообщение о~несоответствии алгоритма.


$+1$ балл, если при работе с~несколькими файлами/папками каждый из файлов имеет собственный код алгоритма и~информацию для декодирования (а~в~\ref{lab_task_coder_min} "--- анализируется отдельно).

$+4$ балла, если архив позволяет как включить для каждого файла собственный код алгоритма и~информацию для декодирования, так и~рассмотреть совокупность файлов как единый исходный текст (но при декодировании восстановить исходную структуру файлов).
