    
\tikzmath{
    int \i, \iprev;
    coordinate \origincoord;    
    int \dyInMm;
    \dyInMm=22;
    int \yspaceInMm;
    \yspaceInMm = 12;
}

\tikzset{x=\linewidth, y=\dyInMm mm, trim left}


\tikzstyle{viewarealinestyle}=[line width=1ex, blue!30]
\tikzstyle{ticklinestyle}=[]
\tikzstyle{labelbelowstyle}=[]
\tikzstyle{labelabovestyle}=[]
\tikzstyle{pilabelstyle}=[sloped, above]

\tikzstyle{symlinestyle}=[red]
\def\ticksymbolcontrol{0.3}



\newcommand{\outbits}[1]{\textcolor{blue}{#1}}
\newcommand{\finalval}[1]{\ensuremath{\fbox{#1}}}



\newcommand{\ticklineonly}[2][lastcoord]
{
    \coordinate  (#1) at #2;
    \draw[ticklinestyle] ($(0,0.1)+(#1)$) -- ($(0,-0.1)+(#1)$);
}

\newcommand{\tickbelow}[3][lastcoord]
{
    \ticklineonly[#1]{#2}
    \node[below=1ex of #1, labelbelowstyle, ] (#1label) {#3};
    
}
% 
% \newcommand{\textbelow}[3][lastcoord]{
%     %\node[labelbelowstyle, below=1ex of #1] {#3};    
%     \node[below=1ex of #1, labelbelowstyle, ] {#3};
% }

\newcommand{\holineStart}
{    
    \tikzmath{
        \origincoord = (0,0);
        real \y;
        \y=\origincoordy;
    }    
    \coordinate  (zero) at (0,\y);
}

\newcommand{\hlineRealStart}
{    
    \tikzmath{
        % неточные значения! только для отрисовки
        real \reall, \realt, \reald, \reallprev, \realtprev, \realdprev; 
        \reall = 0;
        \realt = 1;
        \reald = \realt - \reall;
    }    
    \draw (0,\y) -- (1,\y);
    \tickbelow{(0,\y)}{$0=l_0$}
    \tickbelow{(1,\y)}{$1=t_0$}
    
    \tikzmath{
        \i=0;
    }
}

\newcommand{\drawRealMainLine}
{
    \coordinate[below=\yspaceInMm mm of zero|-current bounding box.south]  (newzero);
    \tikzmath{
        \origincoord = (newzero);
        real \y;
        %\y=\origincoordy/62.3622; % \origincoordy в пунктах, а не в единицах! 22мм?62.3622pt
        \y=\origincoordy/\dyInMm/2.8346456692913; % \origincoordy в пунктах, а не в единицах!
    } 
    \draw (0,\y) -- (1,\y);
}


% \def\myfrac #1/#2
% {
% \frac{#1}{#2}
% }
% \hlineLazyIC{1/2,5/6,1/1}{А,Н,С}{0/1,1/2}{}
%\hlineLazyIC[]{АНАНА,АНАНН,АНАНС}{\realFreq}{7/24,11/36}{0/1/$0$, 1/1/$1$}
% неточные значения! только для отрисовки
\newcommand{\hlineRealStep}[5][]
{
%     \coordinate[below=\yspaceInMm mm of zero|-current bounding box.south]  (newzero);
%     \tikzmath{
%         \origincoord = (newzero);
%         real \y;
%         %\y=\origincoordy/62.3622; % \origincoordy в пунктах, а не в единицах! 22мм?62.3622pt
%         \y=\origincoordy/\dyInMm/2.8346456692913; % \origincoordy в пунктах, а не в единицах!
%     } 
%     \draw (0,\y) -- (1,\y);
    \drawRealMainLine
    
    \tikzmath{
        \iprev=\i;
        \i=\i+1;
        \reallprev = \reall;
        \realtprev = \realt;
        \realdprev = \reald;        
        real \x, \w;        
    }    
    

    \ticklineonly[pistart]{(\reallprev,\y)}
    
    \foreach \pilabel/\numerator/\denominator in {#2} 
    {
        \tikzmath{
            \w = \numerator/\denominator;
            \x=\reallprev+\realdprev*\w;
        }    
        \ticklineonly[piend]{(\x,\y)}
        
        \draw[symlinestyle] (pistart)     .. controls ($0.5*(pistart) + 0.5*(piend) + (0,\ticksymbolcontrol)$)  
        .. node [symlinestyle, pilabelstyle] {\pilabel} 
        (piend);
        
        
        \coordinate (pistart) at (piend);
    }    
    
    
    \tikzmath{ 
        \reall = #3; 
        \realt = #4;
        \reald = \realt-\reall;
    }    
    %\tickbelow[l\i]{(\reall,\y)}{$l_\i$}    
    %\tickbelow[t\i]{(\realt,\y)}{$t_\i$}        
    
    \foreach \numerator/\denominator in {#3} 
    {
        %\tickbelow[l\i]{(\reall,\y)}{$l_\i = \frac{\numerator}{\denominator}$}    
        \ifthenelse{\equal{\numerator}{0}}{
            \tickbelow[l\i]{(\reall,\y)}{$l_\i = 0$}    
            }{
            \tickbelow[l\i]{(\reall,\y)}{$l_\i = \frac{\numerator}{\denominator}$}    
            }
    }
    \foreach \numerator/\denominator in {#4} 
    {
        %\tickbelow[t\i]{(\realt,\y)}{$t_\i = \frac{\numerator}{\denominator}$}    
        \ifthenelse{\equal{\numerator}{\denominator}}{
            \tickbelow[t\i]{(\realt,\y)}{$t_\i = 1$}    
            }{
            \tickbelow[t\i]{(\realt,\y)}{$t_\i = \frac{\numerator}{\denominator}$}    
            }
    }    
    
    
    \foreach \numerator/\denominator/\pointlabel in {#5} 
    {
        \tikzmath{
            \x=\numerator/\denominator;
        }    
        \tickbelow{(\x,\y)}{\pointlabel}    
    }
    
    
}


\newcommand{\hlineRealFinal}[3][]
{
    \drawRealMainLine
    
    \tikzmath{
        \iprev=\i;
        \i=\i+1;
        \reallprev = \reall;
        \realtprev = \realt;
        \realdprev = \reald;        
        real \x, \w;        
    }    
    

    \coordinate  (pistart) at (\reallprev,\y);
    \draw[symlinestyle] (pistart) -- (l\iprev label);
    
    \foreach \pilabel/\numerator/\denominator in {#2} 
    {
        \tikzmath{
            \w = \numerator/\denominator;
            \x=\reallprev+\realdprev*\w;
        }    
        \coordinate  (piend) at (\x,\y);
        
        \draw[symlinestyle] (pistart)     .. controls ($0.5*(pistart) + 0.5*(piend) + (0,\ticksymbolcontrol)$)  
        .. %node [symlinestyle, pilabelstyle] {\pilabel} 
        (piend);
        
        
        \coordinate (pistart) at (piend);
        
        \draw[symlinestyle] (piend) -- (t\iprev label);
    }    


    \foreach \numerator/\denominator/\pointlabel in {#3} 
    {
        \tikzmath{
            \x=\numerator/\denominator;
        }    
        \tickbelow{(\x,\y)}{\pointlabel}    
    }
    
    
}






\newcommand{\insertcommentbox}[2][]
{
    \node[below=\yspaceInMm mm of zero|-current bounding box.south, anchor=north west,   ] (abox) {#2};
}














\def\oldbits{}
\newcommand{\printbits}[1][]{%
  \oldbits%
    \ifthenelse{\equal{\bitscount}{0}}{}{%
      \foreach \k in {1,...,\bitscount}{\bits{\k}}
    }%
    \ifthenelse{\equal{\betabits}{0}}{}{%
      \foreach \k in {1,...,\betabits}{?}    
    }%
}



\newcommand{\drawIntMainLine}
{
    \coordinate[below=\yspaceInMm mm of zero|-current bounding box.south]  (newzero);
    \tikzmath{
        \origincoord = (newzero);
        %\y=\origincoordy/\dyInMm/2.8346456692913; % \origincoordy в пунктах, а не в единицах!
        \y=\origincoordy/\dyInMm/2.8346456692913; % \origincoordy в пунктах, а не в единицах!
    } 
%     %\draw[ultra thick, blue!30] (\realLview,\y) -- (\realLview+\realDview,\y);
%     \tikzmath{
%         real \realTview;
%         \realTview = \realLview + \realDview;
%     }
%     
%     \draw[viewarealinestyle] (\realLview,\y) -- (\realTview,\y);
    \draw[viewarealinestyle] (\realLview,\y) -- (\realLview+\realDview,\y);
%     
%     %\draw[viewarealinestyle, red] (0,\y) -- (0.5,\y);
   
    \draw (0,\y) -- (1,\y);
}

\newcommand{\tickabovebelow}[4][lastcoord]
{
    \coordinate  (#1) at #2;
    \draw[ticklinestyle] ($(0,0.1)+(#1)$) -- ($(0,-0.1)+(#1)$);
    \node[above=1ex of #1, labelabovestyle] (#1labelabove) {#3};
    \node[below=1ex of #1, labelbelowstyle] (#1labelbelow) {#4};
}
\newcommand{\nolineIntInit}
{    
    \tikzmath{
        int \i, \iprev;
        % убираем отсюда локальные переменные
        int \N, \intl, \intt, %\intd, 
        %\intlprev, \inttprev, %\intdprev, 
        \NQ, \NH, \NTQ, \bitscount, 
        \betabits; % команда \beta определяет, собственно, греческую букву, и tikz на неё ругается
        \N = 1024;
        \NH = \N/2;
        \NQ = \N/4;
        \NTQ = 3*\N/4;
        \intl = 0;
        \intt = \N;
        %\intd = \intt - \intl; 
        \bitscount = 0;
        \betabits = 0;
        %
        % далее переменные для отрисовки соответствия целочисленного [0, N) частям вещественного [0, 1)
        % для собственно кодирования не нужны
        real \realLview, %\realTview, — \realTview = \realLview + \realDview; в расчётах не участвует
        \realDview; % границы видимой области и её длина (длина \realDview всегда круглая: 1/(2^n))
        \realLview = 0;
        %\realTview = 1;        
        %\realDview = \realTview - \realLview;
        \realDview = 1;
    } 
   
}
\newcommand{\hlineIntStart}
{    
    \node[white] at (0, 0) {}; % невидимый узел — но без него всё сплющивается
    
    %\draw (0,\y) -- (1,\y); y не меняется
    \drawIntMainLine % а это и смена \y, и линия
    
    \tickabovebelow{(0,\y)}{\hex{\ell = 0}}{$0,0$}
    \tickabovebelow{(1,\y)}{\hex{t = \N}}{$1,0$}
    
    \tikzmath{
        \i=0;
    }
    
    \tikzmath{
        \yspaceInMm = 15;
    }   
}


%\hlineIntStepChar
%2 {А/1/2,Н/5/6,С/1/1} для отрисовки
%3, 4 {0/1}{1/2} доли для расчёта новых l, t
%(-)5, 6 {0/1}{1/1} вещественные границы видимого 0, N — а может, рассчитывать?
% 5: точки для прорисовки: верхняя_надпись/числитель/знаменатель/нижняя_надпись

\newcommand{\hlineIntStepChar}[5][]
{    
    \tikzmath
    {
        \iprev=\i;
        \i=\i+1;
        %
        % локальные переменные
        int \intlprev, \intdprev, \intd;        
        \intlprev = \intl;
        %\inttprev = \intt;
        \intdprev = \intt - \intl;
        %
        %real \endscaleleft, \endscalecurrent; % омега[j-1]/D и омега[j]/D соответственно
        %\endscaleleft = #3; 
        %\endscalecurrent = #4;
        %\intl = \intlprev + \intdprev*\endscaleleft; 
        %\intt = \intlprev + \intdprev*\endscalecurrent;       
        \intl = \intlprev + \intdprev*#3; 
        \intt = \intlprev + \intdprev*#4;       
    } 
    
    \drawIntMainLine
    
    % делим *предыдущий* ПИ на части соответственно #2 и рисуем дуги с подстроками на каждой части
    
    \tikzmath
    {
        % вещественные числа, которые соответствуют целочисленному изображению l (но не точнному вещественнному l_{i-1}) и длине *предыдущего* ПИ 
        real \reallprev;        
        \reallprev = \realLview + \intlprev*\realDview/\N;
    }     
    
    \ticklineonly[pistart]{(\reallprev,\y)} 
    
    \foreach \pilabel/\numerator/\denominator in {#2} 
    {
        \tikzmath
        {
            int \intx;        
            \intx = \intlprev + \intdprev*\numerator/\denominator; 
            real \x; 
            \x = \realLview + \intx*\realDview/\N;
        }    
        \ticklineonly[piend]{(\x,\y)}
        
        \draw[symlinestyle] (pistart)     .. controls ($0.5*(pistart) + 0.5*(piend) + (0,\ticksymbolcontrol)$)  
        .. node [symlinestyle, pilabelstyle] {\pilabel} 
        (piend);        
        
        \coordinate (pistart) at (piend);
    }     
    
    % подписываем границы *текущего* ПИ
    \tikzmath
    {
        % вещественные числа, которые соответствуют целочисленным изображениям l и t (но не точные вещественные l_i и t_i)
        real \reall, \reald;        
        \reall = \realLview + \intl*\realDview/\N;
        \realt = \realLview + \intt*\realDview/\N;
    }     
% \tikzstyle{ticklinestyle}=[blue]
    \tickabovebelow{(\reall,\y)}{\hex{\ell = \intl}}{}
    \tickabovebelow{(\realt,\y)}{\hex{t = \intt}}{}
% \tikzstyle{ticklinestyle}=[]
     
%     % подписываем границы области видимости
%     \tickabovebelow{(\realLview,\y)}{\hex{0}}{}
%     \tickabovebelow{(\realLview+\realDview,\y)}{\hex{\N}}{}
%     ^^^ работает, но некрасиво: не отображаются красивые двоичные вещественные значения
 
    \foreach \abovelabel/\numerator/\denominator/\belowlabel in {#5} 
    {
        \tikzmath{
            \x=\numerator/\denominator;
        }    
        \tickabovebelow{(\x,\y)}{\hex{\abovelabel}}{\belowlabel}
    } 
}

%\hlineIntStepScale
%2  {0} бит для расчёта новых изображений l, t: 0, 1, *
%(-)3, 4 {0/1}{1/2} доли для отрисовки l, t
%(-)5, 6 {0/1}{1/1} новые вещественные границы видимого 0, N для отрисовки
%(-)5 {0/1} новая вещественная нижняя граница видимого 0, N для отрисовки
%(-)6 {1/1} новая вещественная длина видимого 0, N для отрисовки (она уменьшается вдвое, а с верхней границей сложно)
% 3: точки для прорисовки: верхняя_надпись/числитель/знаменатель/нижняя_надпись

\newcommand{\hlineIntStepScale}[3][]
{ 
    % собственно запись бита и масштабирование
    \tikzmath
    {
        % локальные переменные
        int \intlprev, \inttprev, \intd, \bit;
        %
        \intlprev = \intl;
        \inttprev = \intt;
        %\intdprev = \intd; 
        %
        \realDview = \realDview/2; % масштаб в любом случае увеличивается вдвое; а длина видимой области вдвое уменьшается
        %
        \bit = #2;
        %
%         \ifthenelse{\equal{#2}{0}}
        if 0 == \bit then 
        {
            % [0, N/2) в [0, N)
            % запись 0 (или 0111...111)
            \bitscount = \bitscount + 1;
            \bits{\bitscount} = 0;
            if \betabits>0 then 
            {
                for \k in {1,...,\betabits}{ % <== очень важно, чтобы { была сразу после }, без пробела!!! 
                    \bitscount = \bitscount + 1;
                    \bits{\bitscount} = 1;
                };
                \betabits = 0;
            };        
            % масштабирование l и t
            \intl = \intlprev*2;
            \intt = \inttprev*2;
            % начало изображения на вещественной прямой не трогаем            
        }
        else
        {
            if 1 == \bit then 
%             \ifthenelse{\equal{#2}{}}
            {
                % [N/2, N) в [0, N)
                % запись 1 (или 1000...000)
                \bitscount = \bitscount + 1;
                \bits{\bitscount} = 1;
                if \betabits>0 then 
                {
                    for \k in {1,...,\betabits}{
                        \bitscount = \bitscount + 1;
                        \bits{\bitscount} = 1;
                    };
                    \betabits = 0;
                }; 
                % масштабирование l и t (\NH = N/2)
                \intl = (\intlprev - \NH)*2;
                \intt = (\inttprev - \NH)*2;
                % начало изображения на вещественной прямой                           
                \realLview = \realLview + \realDview; % \realDview — уже новое, которое половина старого
            }
            else
            {
                % [N/4, 3N/4) в [0, N)
                % увеличение количества отложенных битов
                \betabits = \betabits + 1;
                % масштабирование l и t (\NQ = N/4)
                \intl = (\intlprev - \NQ)*2;
                \intt = (\inttprev - \NQ)*2;                
                % начало изображения на вещественной прямой                           
                \realLview = \realLview + \realDview/2; % \realDview — новое, которое половина старого; но смещаемся мы на четверть
            };
        }; % 0 != \bit
        %        
        %\intd = \intt-\intl;
        %
        % вещественные числа, которые соответствуют целочисленным изображениям l и t (но не точные вещественные l_i и t_i)
        real \reall, \realt;
        \reall = \realLview + \intl*\realDview/\N;
        \realt = \realLview + \intt*\realDview/\N;
    } 
    
    \drawIntMainLine
    
     % рисуем, но не подписываем границы текущего ПИ
    \tikzmath
    {
        % вещественные числа, которые соответствуют целочисленным изображениям l и t (но не точные вещественные l_i и t_i)
        % используются потом в метках-подписях!
        real \reall, \realt;        
        \reall = \realLview + \intl*\realDview/\N;
        \realt = \realLview + \intt*\realDview/\N;
    } 
    \coordinate (pistart) at (\reall,\y);    
    \coordinate (piend) at (\realt,\y);  
        
    \draw[symlinestyle] (pistart) .. controls ($0.5*(pistart) + 0.5*(piend) + (0,\ticksymbolcontrol)$) .. (piend);        
       
     
%     % подписываем границы области видимости
%     \tickabovebelow{(\realLview,\y)}{\hex{0}}{}
%     \tickabovebelow{(\realLview+\realDview,\y)}{\hex{\N}}{}
%     ^^^ работает, но некрасиво: надо ещё и красивые вещественные значения там прописывать

    \foreach \abovelabel/\numerator/\denominator/\belowlabel in {#3} 
    {
        \tikzmath{
            \x=\numerator/\denominator;
        }    
        \tickabovebelow{(\x,\y)}{\hex{\abovelabel}}{\belowlabel}
    }
}
