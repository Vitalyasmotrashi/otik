В~данном пособии рассматриваются методы сжатия и~способы их реализации для современных ЭВМ общего назначения, таких как x86/amd64 или ARM.
% % байт занимает $k=8$ бит (октет).

Все они двоичны "--- элементарной единицей объёма является \emph{бит.}

Для современных архитектур общего назначения %, таких как x86/amd64 или ARM,
минимальная адресуемая единица памяти "--- \emph{байт} "--- 
содержит восемь бит (%байт x86/amd64 и ARM 
является \emph{октетом).}


% \section{Про символ кодирования и~символ печатный}
\section{Символ кодирования $=$ байт $\neq$ символ печатный}

% % При описании кодов
% В~кодировании (то есть сжатии, защите от помех или шифровании)
% широко используются термины:
% \begin{itemize}%[wide]
% % \item {символ кодирования} $a  \in A$, часто называемый просто символом "--- элемент качественной информации;% $a \in A$;
% \item \emph{символ} "--- элемент (квант) качественной информации $a \in A$;
% \item \emph{алфавит} "--- множество $A$ всех возможных символов;
% % % \item \emph{текст, строка, слово} "---  последовательность $C \in A^+$ символов алфавита 
% % % % ($C \in A^+$ "--- то есть $C = c_1 c_2 \ldots c_n$, и~каждый $c_i \in A$);
% % % ($A^+$ "--- множество всех конечных непустых последовательностей элементов $A$);
% % \item \emph{первичный алфавит} $A_1$ "--- алфавит до кодирования;
% % \item  \emph{вторичный алфавит} $A_2$ "--- после (может отличаться от $A_1$);
% \item \emph{текст, строка, слово} "---  последовательность символов алфавита; 
% в~частности, \emph{исходный текст} "--- текст до кодирования.
% % \item \emph{исходный текст} "--- текст до кодирования,  \emph{кодированный текст} "--- после; \\
% % % \item 
% % в~частности, \emph{несжатый текст} "--- текст до сжатия, \emph{сжатый текст} "--- после.
% \end{itemize}
% % Из-за схожести названий с~обозна
% % Для некоторых кодов первичный алфавит "--- это биты.
% % Для некоторых кодов первичный алфавит произволен, вторичный "--- биты
% % Для
% % программной реализации кода
% % первичный алфавит
% % 
% % \textbf{Символ кодирования} в~ТИ есть элемент (квант) качественной информации. 
% % Для некоторых кодов символом первичного алфавита является бит (код Хэмминга для защиты от помех),
% % для некоторых "--- символом вторичного алфавита является бит 
При программной реализации любых методов
кодирования  (то есть сжатия, защиты от помех или шифрования)
для современных ЭВМ общего назначения
\textbf{символ "--- это байт,} то есть произвольный октет; алфавит $A = \{\hex{00, 01, \ldots FF}\}$; изредка символом является отдельный бит (вторичный алфавит Хаффмана или первичный алфавит Хэмминга) или битовый блок 
% отличной от байта длины.
размером в~целое число  байтов.
Соответственно:
\begin{itemize}%[wide]
\item \textbf{{исходный текст}} "--- произвольный \textbf{бинарный файл;}
\item \textbf{{строка, слово}} "---  произвольный \textbf{фрагмент бинарного файла;}
\item {{кодированный текст, сжатый текст} "--- также бинарный файл.}
\end{itemize}
% Использование байта или кратного байту блока  в~качестве символа удобно 
% 
Ни одна общепринятая реализация не считает символом кодирования печатный символ  ASCII, KOI-8, Unicode и~т.\,д.,
хотя технически это можно реализовать.

Соответственно, %в~данном пособии считается, что 
в~общем случае не существует «такого символа, который не~может встретиться в~файле».
Исходный текст (бинарный файл) априори может содержать любые комбинации любых символов (байтов).

% Для ил


% ; и~никогда "--- печатный символ  ASCII, KOI-8, Unicode и~т.\,д.
% % (технически реализовать можно, как показывают задания~\ref{lab_task_letters_stat_utf8}/\ref{lab_task_markov1_stat_utf8}, но смысла в~этом нет).





% \pagebreak
% \section{Про различие реальности и~обучающих примеров}
\section{Элемент количественной информации "--- тоже байт}

 
% В~типовых реализациях сжатия для них:
% \begin{anumerate}[wide]
% \item символ кодирования, как сказано выше "--- один байт; %(не печатный символ);
% \item п
Под количественные величины ($L$~для RLE, $L$~и~$S$ для LZ77)
также 
отводится около одного 
байта (приблизительно $k$ бит):
% \end{anumerate}
% \begin{itemize}
% \item либо $Q$ занимает целиком один байт, $k=8$ бит;
% \item либо байт занимает пара $Q$+флаг-бит, на $Q$ отводится $k-1 = 7$ бит;
% \item либо пара величин $\rleLC{Q_1}{Q_2}$ занимает два целых байта, а~каждая из $Q_1$ и~$Q_2$ "---  от~$k-2=6$ бит до $k+2=10$ бит.
% \end{itemize}
% \begin{itemize}
% \item величина занимает целиком один байт, $k=8$ бит;
% \item пара величина+флаг-бит "--- байт, на величину отводится $k-1 = 7$ бит;
% \item пара величин "--- два байта, на~каждую из величин "---  от~6 до 10 бит.
% \end{itemize}
% \begin{itemize}
% \item один байт "--- величина размером $k=8$ бит;
% \item один байт "--- величина + флаг-бит, на величину отводится $k-1 = 7$ бит;
% \item два байта "--- пара величин, на~каждую "--- от~$k-2=6$ бит до $k+2=10$ бит.
% \end{itemize}
\begin{itemize}
\item один байт "--- число размером $k=8$ бит;
\item один байт "--- число + флаг-бит, на число отводится $k-1 = 7$ бит;
\item два байта "--- пара чисел, каждое "--- от~$k-2=6$ бит до $k+2=10$ бит.
\end{itemize}
% Файлы, для которых имеет смысл отдавать для одной величины два байта и~более, встречаются редко (раздел~\ref{sec_rle_n_model} и~т.\,п.).
% % Сжатие 16-битных символов не имеет смысла.
Настолько избыточные файлы, что при их сжатии имело бы смысл отводить для одной величины два октета и~более, встречаются слишком редко 
(раздел~\ref{sec_rle_n_model}% и~т.\,п.
).%
% и~не учитываются на практике.
\medskip

\warningframebox{%Формулы записываются для $k$-битного байта и~случая символ=байт.
% Формулы в~настоящем пособии записываются для $k$-битного байта, предполагая:
Формулы в~настоящем пособии "--- для $k$-битного байта в~предположении, что:
\begin{anumerate}[wide]
\item символ кодирования занимает ровно $k$ бит (символ=байт);
\item количественные величины %$L$ и~$S$ 
"--- приблизительно $k$ бит (число$\approx$байт).
\end{anumerate}

% =кол.\,величина.
} % warningframebox

\section{Различие реальности и~обучающих примеров}

К~сожалению, файл из 8-битных байтов,
иллюстрирующий, в~частности, переполнение 
% хотя бы 6"=битного $L$ 
8-битного $L$ 
при обработке, 
слишком объёмен для того, чтобы 
% компактно разместить его в~тексте пособия и~чтобы при ручном исследовании переполнение было очевидным.
быть наглядным.
Соответственно, для иллюстрации работы алгоритмов сжатия в~настоящем пособии используется меньшая разрядность количественных величин
и~соответствующая ей меньшая разрядность байта (символа кодирования).

\subsection{Разрядность байтов, символов и~количественных~величин}

Для ЦСП или других архитектур специального назначения байт иногда занимает $4$, $12$ или $16$ бит,
% На $4$-
% (при реализации )
причём случай $k>8$ бит в~байте 
% предусмотрен
описан стандартом C++.
% Для $k=4$ возможны языки, подобные C/C++, 
% % но они не вполне соответствуют стандарту.
% но не вполне соответствующие стандарту.
% Для $k=4$ возможно подобие C/C++, 
% % но они не вполне соответствуют стандарту.
% не вполне соответствующие стандарту.
Не стандартизированные языки, подобные C/C++, реализуются и~для $k=4$.

% ^^^ https://www.rsdn.org/forum/cpp/5973101.hot
% 

Размер байта $k$, некратный четырём битам, в~настоящее время встречается ещё реже.
Тем не менее, исторически %первый байт занимал $k=6$ бит, 
% были распространены байты из $k=6$ бит 
% % (наследие шестибитного байта "--- base64) 
% % https://vk.com/wall774177099_33?ysclid=m2rgv5idfe773469659
% % 
% и~встречались "--- из $k=9$ бит.
использовались байты из $k \in [6, 9]$ бит;
% распространёнными из 
весьма распространены были байты из $k=6$ бит, вмещающие латинский алфавит и~цифры (иногда наследием шестибитных программ называют кодировку base64).
% % https://vk.com/wall774177099_33?ysclid=m2rgv5idfe773469659

\medskip

\warningframebox{При необходимости проиллюстрировать работу алгоритмов сжатия на компактных примерах в~настоящем пособии: 

\medskip

\begin{anumerate}[wide]
\item используется символ из $k=3$ бит $\big($алфавит $A = \{0, 1, 2, 3,  4, 5, 6, 7\}\big)$;
\item \textbf{байт} для ручного расчёта считается также \textbf{трёхбитным} (триадой); % (символ=байт);
% \item количественные величины $L$ и~$S$ также трёхбитны (число=байт).
% \item  величины  $L$ или $L$ и~$S$ либо обе по три битa, либо два и~четыре (число$\approx$байт).
\item количественные величины занимают около трёх бит (от двух до четырёх бит). % (число$\approx$байт).
\end{anumerate}

\medskip

Это позволяет продемонстрировать переполнение байта и~другие особые случаи на сообщениях, умещающихся в~одну-две строки пособия.
} % warningframebox

% На практике алфавит из восьми символов неудобен

% На практике т
Трёхбитные количественные величины   $L$ или $L$ и~$S$ не позволяют реализовать эффективное сжатие, что видно в~том числе 
% и~по~приведённым 
и~по~приводимым
примерам.
% 
% При необходимости на~практике реализовать один из методов сжатия для архитектуры
% % с~$4$-битным байтом 
% с~$4$- %, $12$- 
% или $16$-битным байтом "---
% обычно используется $8$-битный символ (составленный из двух $4$-битных байтов или полученный битовыми операциями).
% % :
% % % Это даёт не только совместимость с~архивами, созданными для x86/amd64,
% % % но и~
% % не только из-за совместимости с~x86/amd64, но~и~потому, что $256$-символьный алфавит удобнее $16$- или $65536$-символьного.
% % Это даёт, в~частности, совместимость с~архивами, созданными для x86/amd64.
% Это, в~частности, облегчает обмен данными с~x86/amd64.
При необходимости на~практике реализовать один из методов сжатия для архитектуры
% с~$4$-битным байтом 
с~$4$-битным байтом "---
следует оценить характеристики сжимаемых файлов
и, возможно, использовать $8$-битные количественные величины, а~иногда и
$8$-битный символ кодирования (составленный из двух $4$-битных байтов).
% Это, в~частности, может облегчить обмен данными с~x86/amd64.
Это, в~частности, облегчит обмен данными с~x86/amd64.


% Тем не менее, так как данное пособие предназначено для подготовки к~написанию программ для ЭВМ общего назначения, счи


% На практике при реализации тех же методов кодирования на ЦСП или других архитектурах специального назначения с~$4$-битным или $16$-битным байтом

% При $k=8$ это соответствует программам для x86/amd64 или ARM, а~также  большинства ЭВМ общего назначения.

 \section{Максимальный размер файла}
