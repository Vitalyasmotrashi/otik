
% \newcommand{\upair}[2]{\ensuremath{%
% \left\{\begin{array}{@{}c@{}}
% {#1}\\ {#2}
% \end{array}\right\}
% }}
















Схемы данных кодирования и~декодирования методом LZ77 представлены на рис.~\ref{ris_data_lz77_decode} и~\ref{ris_data_lz77_decode} соответственно.

\begin{figure}[!ht]
\includegraphics[width=\linewidth]{\IMGPATH/data_lz77}

\caption{Схема данных кодирования методом LZ77 \mbox{(любой код семейства LZ77)}}
\label{ris_data_lz77_encode}
\end{figure}


\begin{figure}[!ht]
\includegraphics[width=\linewidth]{\IMGPATH/data_lz77_decode}

\caption{Схема данных декодирования методом LZ77 (декодирование символа $c$ и~ссылки 
% $\upair{L}{S}$ 
$\{L, S\}$
должно строго соответствовать их кодированию)}
\label{ris_data_lz77_decode}
\end{figure}

Ключевой и~самый времязатратный этап любого \textbf{алгоритма} кодирования семейства LZ77 "--- поиск в~окне вхождений слова-эталона $E_L = c_i \ldots c_{i+L-1}$ длины $L$ (блоки процесса «Инициализация $\{L, S\}$» и~«Поиск лучшего $S$»).

Отметим два момента, которые могут быть неочевидны.
Во-первых, слова «вхождение $E_L$ в~окне» не подразумевают, что $E_L$ лежит в~окне \emph{целиком.}
Для LZ77 достаточно, чтобы в~окне находилась \emph{начальная позиция $j$} такая, что $c_j\ldots c_{j+L-1}$ составляют  $E_L$.

% \begin{enumerate}
% \item\label{item_lz77_Smin_is_1} «Вхо» 
% 
% \end{enumerate}


Во-вторых, кодирование методом LZ77 принципиально неоднозначно: в~окне может быть несколько 
% вхождений эталонного слова $E$, 
% подходящих смещений $S$, 
% каждому из которых соответствует своя длина $L$;
% какое из них будет выбрано "--- определяется реализацией поиска.
% В~частности
подходящих позиций $j$, то есть несколько подходящих смещений $S = i-j$, 
% каждой из которых соответствует своя длина $L$;
% какая из них будет выбрано "--- определяется реализацией поиска.
каждому из которых соответствует своя длина $L$;
какое из них будет выбрано "--- определяется реализацией поиска.
Поиск может отличаться направлением исследования окна "--- по возрастанию позиции (от $i-w$ к~$i-1$), по~убыванию %позиции 
(от $i-1$ к~$i-w$), 
с~использованием вспомогательных структур данных (первое найденное вхождение может быть не первым и~не последним в~окне).

При однотипной реализации поиска "--- 
\textbf{чем быстрее поиск, тем} хуже его результат \textbf{(меньше степень сжатия} одного и~того же файла).
% 
В~частности, для ускорения может быть реализован поиск первого подходящего вхождения, а~не~наилучшего совпадения "--- тогда блока «Поиск лучшего $S$» нет, 
смещение $S$  не меняется от~инициализации до~записи  $\{L, S\}$.
% 
% Блок «Уточнение $L$ для~текущего $S$» необходим, иначе даже в~наилучшем случае сжатие не будет .

Размер окна $w$ для максимального сжатия должен достигать $S_{\max}$ (все допустимые кодовые комбинации $\widetilde{S}$ должны быть использованы),
при этом:
\begin{anumerate}
\item
первый символ "---  $c_1$ "--- всегда записывается как несжатый символ (окна нет);

\item
для $i \geqslant S_{\max}+1$ доступно %полноразмерное 
окно $W = [i-S_{\max}, i-1]$ размера $w=S_{\max}$;
\item
для $2 \leqslant i \leqslant S_{\max}$ возможны два варианта:
\begin{itemize}
\item поиск в~уменьшенном окне $W = [1, i-1]$ % "--- лучше сжатие начала файла; не всегда
"--- лучше сжимает некоторые файлы, где в~начале много повторений;
\item запись 
% $c_i$ всегда как несжатого символа
всех $c_i$ из $2 \leqslant i \leqslant S_{\max}$ %как несжатых
«как есть», без служебных структур "--- всегда проще; лучше сжимает те файлы, где повторений в~начале мало. %, а~служебные структуры ).
%  "--- проще реализация. % для длинных файлов влияние начала на степень сжатия относительно мало.
\end{itemize}
% Для различных файлов 
% Первый способ лучше сжимает некоторые файлы (если в~начале файла много повторений);
% второй "--- всегда проще и~лучше сжимает некоторые другие файлы (где в~начале повторений мало, и~служебные структуры
% для других файлов 
% (в~начале файла нет служебн)
\end{anumerate}
В~некоторых реализациях размер окна может быть дополнительно ограничен сверху для ускорения поиска (что ещё сильнее уменьшает степень сжатия).

Ключевая характеристика любого \textbf{кода} семейства LZ77 "--- 
способы записи ссылок $\{L, S\}$ и~несжатых символов $c_i$.
Так как любой код ссылки $\{L, S\}$ теоретически может встретиться в~исходном тексте $C = c_1 \ldots c_n$,
% ни в~одной реализации 
% несжатые символы 
% $c_i$
% не могут быть записаны 
нельзя записывать $c_i$
«как есть» "--- необходимо отделять код $\{L, S\}$ от %сочетаний кодов %несжатых 
кодов сочетаний
$c_i$.

Из разных способов записи ссылок $\{L, S\}$ и~несжатых символов $c_i$ следуют разные %границы 
$L_{\min}$, $L_{\max}$, $S_{\max}$.
% Нижняя граница смещения 
При этом
$S_{\min} = 1$ для любой реализации: технически дополнительно ограничить $S$ снизу  возможно, но бессмысленно.
% (уменьшает степень сжатия и~не ускоряет поиск).

Сочетание \textbf{различных кодов семейства LZ77 с~различными алгоритмами} %LZ77} %
поиска 
порождает %огромное
неисчислимое
количество реализаций идеи LZ77.
Такое разнообразие в~сочетании с~эффективностью сжатия приводит к~тому, что %большинство таких реализаций известно
многие из этих реализаций известны не как LZ77, а~под собственными именами (LZSS от Сторера и~Сжимански, LZJB от  Джефа Бонвика %для  ZFS 
и~др.).

Декодирование любого %кода 
LZ77 однозначно; скорость декодирования "--- высокая.

% Использование метода LZ77 ог
% Основной недостаток метода LZ77 "--- низкая скорость кодирования (для каждой позиции $i$ необходим поиск в~большом окне).
% Скорость декодирования LZ77 высока

Скорость кодирования LZ77 "--- низкая (для каждой позиции $i$ необходим поиск в~большом окне), что является основным недостатком этого метода
и~ограничивает его применение.
% в~сжатых файловых системах и.
% там, где требуется быстрое перекодирование.
Многие современные реализации LZ77 сжимают \emph{хуже,} чем описанные ранее "--- зато делают это быстрее.

% Для различных алгоритмов, реализующих метод  LZ77, различаются алгоритмы поиска (блоки «Инициализация $\{L, S\}$» и~«Поиск лучшего $S$»)



%     Если реализован поиск первого подходящего, а~не~наилучшего совпадения "--- блока «Поиск лучшего $S$» нет, 
% 
%     $S$  не меняется от~инициализации до~записи  $\{L, S\}$.
%     \medskip

%     После изменения $i$ (записи как  $\{L, S\}$, так~и~$c_i$)
%     следует попытка новой инициализации.
%     % (новый эталон $E_{\min}$, новое окно).
%     \medskip


\subsection{Алгоритм А1 семейства LZ77, подсемейство «с~односимвольным префиксом»}

\setcounter{mpimgPageCounter}{0}
\setcounter{mpimgLetterCounter}{0}
\newcommand\includeNextPage{\stepcounter{mpimgPageCounter}\includegraphics[width=\linewidth]{\mpImgName}}
\newcommand\inclLetterNextPage{\stepcounter{mpimgLetterCounter}\stepcounter{mpimgPageCounter}%
    \asbuk{mpimgLetterCounter})~\includegraphics[width=0.97\linewidth,valign=c]{\mpImgName}}

Рассмотрим один алгоритм из огромного семейства LZ77. Так как он хронологически первый из обозреваемых в~настоящем пособии, обозначим его А1.

Как всегда, \textbf{символ=байт.}
Перечислим опции алгоритма и~кода А1.
\begin{enumerate}


\item\label{item_a1_prefix} 
Для отделения ссылок $\{L, S\}$ от несжатого текста используется односимвольный префикс (см.~раздел \ref{section_lz77_codes_prefix}).


\item\label{item_a1_byte_byte} 
Как $L$, так и~$S$ занимают по одному байту, $k$ бит (напомним, что в~этой главе $k=4$ "--- но принципиальных отличий реализации от $k=8$ нет).


\item\label{item_a1_order_L_S} 
Вначале записывается байт $L$, затем байт $S$.



\item\label{item_a1_delta0} 
Для значений $L$ и~$S$ используется код без смещения ($\Delta_L = \Delta_S = 0$).
Это \textbf{проигрышный выбор для любого кода} с~точки зрения объёма и~не увеличивает скорость.
% но такой код выглядит нагляднее.
Для иллюстрации метода LZ77 он выбран только из-за наглядности полученного кода для человека.

\item\label{item_a1_prefix_sel} 
Если есть несколько байтов, в~равной степени подходящих на роль префикса "--- из них выбирается наименьший по значению.

\item\label{item_a1_first_w} 
Начинаем поиск совпадений с~позиции $i=w+1$, где доступно полноразмерное окно "--- первые $w$ символов записываем «как есть».

\item\label{item_a1_last_e_prefix} 
Если 
% среди 
% % трёх последних (в~общем случае $L_{\min}-1$) 
% $L_{\max}-1$ последних 
после окончания поиска совпадений среди последних
символов встречается префикс, он экранируется.

\item\label{item_a1_search_max_to_1} 
Поиск в~окне 
% производится последовательно в~направлении от $w$ к~$1$.
"--- последовательный
по возрастанию позиции (от $i-w$ к~$i-1$).

\item\label{item_a1_search_best} 
Ищем наилучшее вхождение.
Это {выигрышный выбор с~точки зрения объёма, но крайне проигрышный по скорости.}

\item\label{item_a1_last_e} 
Заканчиваем поиск совпадений на~позиции $i=n-L_{\max}+1$, где ещё доступен полноразмерный эталон.
% "--- если последние $L_{\max}$ символов не были ранее записаны как часть ссылки,
% остаток записываем тоже «как есть».
% Заканчиваем кодирование так поздно, как только возможно,
% 
% на~позиции $i=n-L_{\min}+1$, где ещё доступен минимально возможный эталон "--- если последние $L_{\min}-1$ символов не были ранее записаны как часть ссылки,
% остаток записываем тоже «как есть».

\item\label{item_a1_w_Smax} 
Не ограничиваем размер окна: $w = S_{\max}$. 
По сравнению с~$w < S_{\max}$ "--- выигрыш по объёму, проигрыш по скорости.




\end{enumerate}
Опции \ref{item_a1_prefix}--\ref{item_a1_w_Smax}  определяют алгоритм кодирования и~сам код.
Из них:
\begin{itemize}
\item опции \ref{item_a1_prefix}--\ref{item_a1_last_e_prefix} влияют также и~на алгоритм декодирования;
\item если изменить опции \ref{item_a1_search_max_to_1}--\ref{item_a1_w_Smax} "--- алгоритм кодирования и~код изменятся, но всё ещё будет применим декодер A1.
\end{itemize}
Все опции, кроме \ref{item_a1_prefix_sel}, имеют смысл для любого способа отделения ссылок $\{L, S\}$ от несжатого текста;
способ выбора префикса \ref{item_a1_prefix_sel}, очевидно, актуален только в~том случае, если для отделения используется односимвольный префикс.

Следствия из выбранных опций:
\begin{enumerate}

\item 
Из \ref{item_a1_prefix} (ссылка с~учётом префикса записывается \emph{тремя} байтами) следует \mbox{$L_{\min} = 4$.}

\item 
% С учётом предыдущего пункта из этого следует $L_{\max} = S_{\max} = 2^k$
Из \ref{item_a1_delta0} и~\ref{item_a1_byte_byte} (оба $L$ и~$S$ записываются без смещения $k$ битами) %получаем 
\mbox{$L_{\max} = S_{\max} = 2^k-1.$}
С учётом $k=4$ в~этой главе $L_{\max} = S_{\max} = 2^4-1 = 15_{10} = \hex{F}$.

\item 
Из \ref{item_a1_w_Smax} и~$S_{\max} = 15_{10}$ размер окна также $w = S_{\max}  = 15_{10} = \hex{F}$ позиций.

\item 
Из \ref{item_a1_first_w} 
% (кодирование начинается с~позиции $i=w+1=S_{\max}+1$)
(первые $w$ символов записываем «как есть»)
следует, что и~префикс среди первых $w = 15_{10} = \hex{F}$ символов экранировать не нужно.

\end{enumerate}

% % Теоретически, конечно, можно, но э
% Экранирование префикса в~начале файла, где ещё не может быть ссылок, не~только бесполезно, но и~во всех отношениях вредно: а)~увеличивает объём; 
% % б)~уменьшает скорость кодирования; в)~уменьшает скорость декодирования.
% % б)~уменьшает скорость как кодирования, так и~декодирования.
% б)~усложняет кодер; в)~усложняет декодер.
% Это связано с~тем, что начало файла и~в~кодере, и~в~декодере обрабатывается отдельно \emph{всегда,} и~копировать «как есть» быстрее, чем анализировать на префикс.
% 
% При этом экранирование префикса \emph{в~конце} файла, где \emph{уже} не может быть ссылок (опция~\ref{item_a1_last_e_prefix}), хотя тоже а)~увеличивает объём 
% % и~б)~уменьшает скорость кодирования,
% % но скорость декодирования "--- увеличивает и~упрощает декодер.
% и~б)~усложняет кодер; но в)~декодер "--- упрощает, %опция~\ref{item_a1_last_e_prefix} 
% позволяя обрабатывать конец файла по общему правилу.
% % Это связано с~тем, что начало файла в~декодере обрабатывается отдельно всегда, а~конец  "--- %только если там не экранируется префикс.
% % нет. 
% % 
% Именно поэтому обработка префикса в~конце файла "--- опция (есть несколько вариантов выбора, каждый из которых имеет свои достоинства и~недостатки), а~в~начале "--- нет (есть однозначно лучший вариант).
% 
% % Это связано с~тем, что начало файла в~декодере всегда обрабатывается отдельно (и~копировать «как есть» быстрее, чем анализировать на префикс), а~для того, чтобы  обработать позицию «за пятнадцать символов до конца» иначе, чем «за шестнадцать символов до конца» "--- необходимо усложнять декодер сверх необходимого.













\providecommand\mpImgName{\IMGPATH/c3_a1_lz77p_page\arabic{mpimgPageCounter}}
\setcounter{mpimgPageCounter}{0}

\subsubsection{Кодирование А1}
Рассмотрим сообщение 
% $$C = \hex{012340123456789012345678901234540123ABCDEFFFFFFF0123EFCD456789AB}$$
$C$ вида 
% $$\hex{012340123456789012345678901234540123ABCDEFFFFFFF0123EFCD456789AB}$$
% $$\hex{012340123456789012345678901234540123ABCDEFFFFFFF123ABCDE45678999}$$
$$\hex{012340123456789012345678901234540123ABCDEFFFFFFF0123EFCD456789AB}$$
из $n = 64_{10} = 80_8$ байтов.
Его код А1 имеет вид 
% $$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 6FA 5 4 647 ABCDEF 661 0 1 2 3 E F C D 4 5607 8 9 A B}$$ и~состоит из $49_{10} = 61_8$
$$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 6FA 5 4 647 A B C D E F 661 68F 4 5 60 7 8 9 A B}$$ и~состоит из $44_{10} = 54_8$ 
байтов (рис.~\ref{ris_c2_a1_lz77p_start_end}).

\begin{figure}[!ht]
\includeNextPage
\caption{Сообщение $C$ и~его код А1}
\label{ris_c2_a1_lz77p_start_end}
\end{figure}%

Рассмотрим процесс его построения подробно.
% 
Так как, согласно опции~\ref{item_a1_prefix}, ссылка в~коде А1 отделяется от несжатого текста префиксом, для сообщения $C$ в~первую очередь необходимо выбрать байт $p$, который будет префиксом.
Для этого необходимо выполнить предварительный проход по файлу (соответственно, код A1 не может быть поточным кодом) и~найти самый редкий символ кодируемой части файла.

Так как, согласно опции~\ref{item_a1_first_w}, первые $15_{10} = \hex{F}$ символов записываются «как есть», 
% экранировать префикс там нет смысла. П
префикс экранируется только начиная с~позиции $16_{10}$. Необходимо учитывать статистику только этой части (рис.~\ref{ris_c2_a1_lz77p_prefix_sel}).

\begin{figure}[!ht]
\includeNextPage
\caption{Выбор префикса для сообщения $C$ (алгоритм А1)}
\label{ris_c2_a1_lz77p_prefix_sel}
\end{figure}%

Префиксом для сообщения $C$ может быть любой из одинаково редких байтов 
% \hex{6, 7, 8, 9, A, B, C, D, E}. 
% \hex{6, 7, 8, A, B, C, D, E}. 
\hex{6, 7, 8, 9, C, D, E}. 
Согласно опции~\ref{item_a1_prefix_sel}, выбираем из них байт \hex{6}:
\begin{equation}
p = \hex{6}.
\end{equation}
Значение \hex{6} записывается в~соответствующее поле заголовка.

Начало кода $A1(C)$ "--- первые $15_{10} = \hex{F}$ символов сообщения $C$ «как есть»:
$$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9...},$$
далее, начиная с~позиции $i=16$, может быть записана либо ссылка 
% \mbox{$\{L \geqslant 4, S \geqslant 1\}$,} предварённая префиксом $p=\hex{6}$, 
в~виде тройки байтов 
% \mbox{$(\hex{6}, L \neq 0, S \neq 0)$,} 
\mbox{$(\hex{6}, L \geqslant 4, S \geqslant 1)$,} 
% \mbox{$\Big(\hex{6}, (L \geqslant 4) \neq 0, S \geqslant 1\Big)$,} 
либо байт несжатого текста (\hex{6} экранируется).
% Если очередной байт несжатого текста равен \hex{6}, он экранируется "--- записывается как $(\hex{6}, \hex{0})$.
% , в~то время как первый байт ссылки $L$ не может быть нулевым.
Для того, чтобы определить, 
% ссылка или символ будет в~позиции $i=16$, 
что именно "--- необходимо рассмотреть окно (рис.~\ref{ris_c2_a1_lz77p_16_window})
\begin{figure}[!ht]
\includeNextPage
\caption{Окно и~эталон для позиции $i=16$}
\label{ris_c2_a1_lz77p_16_window}
\end{figure}%
и~для каждой его позиции сравнить строку на этой позиции с~эталоном $E_{\min}$.
% $j$ сравнить строку, начинающуюся с~$j$, и~эталон $E_{\min}$.

 
Для каждой позиции окна внизу рис.~\ref{ris_c2_a1_lz77p_16_window} показано соответствующее смещение $S$ относительно текущей позиции кодирования $i$.
На этом и~последующих рисунках показана только часть позиций сообщения~$C$, чтобы изображение не было слишком мелким.

Согласно опции~\ref{item_a1_search_max_to_1}, окно просматривается по возрастанию позиции, то есть слева направо "--- от 
% $S = 15_{10} = \hex{F}$ 
$S = S_{\max}$ 
до $S = 1$.
На рис.~\ref{ris_c2_a1_lz77p_i_16_1}, а--в) показан анализ первой позиции окна: $S = S_{\max} = 15_{10}$.
\begin{figure}[!ht]
\setcounter{mpimgLetterCounter}{0}\foreach \i in {1,...,3}{\inclLetterNextPage\par}
% \caption{Кодирование $C$, шаг $i=16$ (показаны позиции с~$1$ по $40$)}
\caption{Кодирование $C$, $i=16$, смещение $S=15_{10}$}
\label{ris_c2_a1_lz77p_i_16_1}
\end{figure}%
Из рис.~\ref{ris_c2_a1_lz77p_i_16_1}, а) видно, что четырёхбайтовое слово по смещению $S = 15_{10}$ совпадает с~четырёхбайтовым эталоном $E_{\min} = \hex{0123}$ на позиции $i$.
Следовательно, в~коде далее будет ссылка на слово длины $L\geqslant4$.

Рис.~\ref{ris_c2_a1_lz77p_i_16_1}, б)--в) показывают \emph{уточнение $L$ для текущего $S$:} видно, что не только четырёх-, но и~пятибайтовые слова по смещению $S = 15_{10}$ и~на позиции $i$ совпадают, а~вот шестибайтовые уже различаются.
Таким образом, ссылку можно сохранить на слово длины $L\geqslant5$, и~одна подходящая ссылка уже найдена: это $\{L=5, S=15_{10}\}$.
Если бы опция \ref{item_a1_search_best} предписывала поиск не \emph{наилучшего,} а~\emph{первого подходящего} вхождения, то $\{L=5, S=15_{10}\}$ и~была бы записана в~файл.

Но опция \ref{item_a1_search_best} требует искать наилучшее, поэтому продолжаем просматривать остаток окна (от смещения $S=14_{10}$ до $S = 1$) и~ищем лучшее, чем пять байтов, совпадение, для чего сравниваем уже шестибайтовые слова с~шестибайтовым эталоном $E_{6} = \hex{012345}$ (рис.~\ref{ris_c2_a1_lz77p_i_16_2}, а--е)

\begin{figure}[!ht]
\setcounter{mpimgLetterCounter}{0}\foreach \i in {14,...,10, 10}{\inclLetterNextPage\par}
\caption{Кодирование $C$, $i=16$, \mbox{смещения от $S=14_{10}$ до $S = 10_{10}$}}
\label{ris_c2_a1_lz77p_i_16_2}
\end{figure}%

Рис.~\ref{ris_c2_a1_lz77p_i_16_2}, а--д) показывают \emph{поиск лучшего $S$:} по смещениям от  $S=14_{10}$ до $S = 11_{10}$ (а--г) нет искомого $E_{6} = \hex{012345}$,
а~по смещению $S = 10_{10}$ (д) есть.

\newcommand{\pLS}[3][6]{\textcolor{green}{\hex{#1}}\textcolor{red}{\hex{#2}}\textcolor{blue}{\hex{#3}}}
\newcommand{\pfx}[1][6]{\textcolor{green}{\hex{#1 0}}}


После обнаружения лучшего $S$ для него снова \emph{уточняется $L$} (рис~\ref{ris_c2_a1_lz77p_i_16_2}, е).
Для $S = 10_{10}$ совпадают уже 
% $L=15_{10}$ байтов (на самом деле даже шестнадцать, но $16_{10}$ нельзя закодировать по~опциям \ref{item_a1_delta0} и~\ref{item_a1_byte_byte}).
% Так как $L_{\max} = 15_{10}$, лучшего совпадения уже не найти "--- просмотр окна останавливается, ссылка $\{\mbox{$L=15_{10}=\hex{F}$}, S=10_{10}=\hex{A}\}$ записывается тройкой байтов \mbox{$(\hex{6}, \hex{F}, \hex{A})$.} 
$L=15_{10} = L_{\max}$ байтов.
Так как достигнуто значение $L_{\max}$, лучшего совпадения уже не найти "--- просмотр окна останавливается, ссылка $\{\mbox{$L=15_{10}=\hex{F}$}, S=10_{10}=\hex{A}\}$ записывается тройкой байтов \mbox{$(\hex{6}, \hex{F}, \hex{A})$:} 
$$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 \pLS{F}{A} ...}$$

% На рис.~\ref{ris_c2_a1_lz77p_i_16_2}, е) видно, что при том, что начало слова лежит в~

Этой ссылкой были записаны пятнадцать байтов сообщения $C$. Таким образом, следующая позиция кодирования "--- $i=16+15=31$ (рис.~\ref{ris_c2_a1_lz77p_i_31}, а--б).
\begin{figure}[!ht]
% \setcounter{mpimgLetterCounter}{0}\foreach \i in {1, ..., 4}{\inclLetterNextPage\par}
\setcounter{mpimgLetterCounter}{0}\foreach \i in {1, 2}{\inclLetterNextPage\par}
\caption{Кодирование $C$, $i=31$}
\label{ris_c2_a1_lz77p_i_31}
\end{figure}%
Как всегда при переходе к~новой $i$, производится поиск минимально допустимого четырёхбайтового эталона $E_{\min} = \hex{5 4 0 1}$.
Последовательное сравнение со всеми смещениями в~окне 
% (между а--б и~в--г на рис.~\ref{ris_c2_a1_lz77p_i_31} пропущено ещё одиннадцать шагов) 
(между а и~б на рис.~\ref{ris_c2_a1_lz77p_i_31} пропущено ещё тринадцать шагов) 
показывает, что ни по одному смещению нет совпадения с~$E_{\min}$.
% $S = 15_{10}$ (рис.~\ref{ris_c2_a1_lz77p_i_31}, а),
% $S = 14_{10}$ (рис.~\ref{ris_c2_a1_lz77p_i_31}, б),
Следовательно, следующей записью будет не ссылка, а~один несжатый байт \hex{5}:
$$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 \pLS{F}{A} 5 ...}$$

Следующая позиция кодирования "--- $i=32$ (рис.~\ref{ris_c2_a1_lz77p_i_32}).
\begin{figure}[!ht]
\includeNextPage\caption{Кодирование $C$, $i=31$}
\label{ris_c2_a1_lz77p_i_32}
\end{figure}%
Аналогично, пятнадцать сравнений (на рис.~\ref{ris_c2_a1_lz77p_i_32} изображено только первое, с~$S = 15_{10}$) показывают, 
что в~окне нет ни одного совпадения даже с~$E_{\min} = \hex{4 0 1 2}$, так что следующей записью будет один байт \hex{4}:
$$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 \pLS{F}{A} 5 4 ...}$$

Следующая позиция кодирования "--- $i=33$ (рис.~\ref{ris_c2_a1_lz77p_i_33}, а--д).
\begin{figure}[!ht]
\setcounter{mpimgLetterCounter}{0}\foreach \i in {1, ..., 5}{\inclLetterNextPage\par}
\caption{Кодирование $C$, $i=33$}
\label{ris_c2_a1_lz77p_i_33}
\end{figure}%
По первому смещению 
$S = 15_{10}$ (рис.~\ref{ris_c2_a1_lz77p_i_33}, а)
совпадения с~$E_{\min} = \hex{0 1 2 3}$ нет, но через семь шагов на $S = 7$ (рис.~\ref{ris_c2_a1_lz77p_i_33}, б) совпадение находится.
Попытка уточнения $L$ (рис.~\ref{ris_c2_a1_lz77p_i_33}, в) показала, что пятибайтовые слова уже не совпадают: найдено $\{L=\hex{4}, S=\hex{7}\}$.

Так как опция \ref{item_a1_search_best} требует искать наилучшее совпадение, ссылка $\{\mbox{$L=\hex{4}$}, S=\hex{7}\}$ не может быть записана до тех пор, пока остаток окна не просмотрен до конца и~не доказано, что нет совпадения с~$E_{5} = \hex{0 1 2 3 A}$ (рис.~\ref{ris_c2_a1_lz77p_i_33}, г--д).

После окончания просмотра окна %записывается лучшая из ранее найденных ссылка:
ссылка записывается:
$$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 \pLS{F}{A} 5 4 \pLS{4}{7}  ...}$$

\warningframebox{%
Таким образом, в~общем случае необходимо на \emph{каждую} позицию $i$ исходного сообщения (чтобы в~итоге записать в~выходной поток один символ или ссылку)
проанализировать \emph{все} $w = S_{\max}$ позиций окна, 
причём для каждой позиции сравнить как минимум четыре символа. 
Поэтому все те варианты LZ77, где выполняется поиск \emph{наилучшего совпадения} "--- исключительно медленны.%
}

Следующая позиция кодирования "--- $i=37$ (рис.~\ref{ris_c2_a1_lz77p_i_37}).
% (на рис.~\ref{ris_c2_a1_lz77p_i_37} показан первый шаг).
\begin{figure}[!ht]
\includeNextPage\caption{Кодирование $C$, $i=37$}
\label{ris_c2_a1_lz77p_i_37}
\end{figure}%
В~окне нет ни одного совпадения с~эталоном \hex{ABCD}, следующей записью будет один байт \hex{A}:
$$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 \pLS{F}{A} 5 4 \pLS{4}{7} A  ...}$$
Аналогично следующие пять записей также будут байтами:
$$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 \pLS{F}{A} 5 4 \pLS{4}{7} A  B C D E F ...}$$


На позиции $i=43$ (рис.~\ref{ris_c2_a1_lz77p_i_43}, а--в)
\begin{figure}[!ht]
\setcounter{mpimgLetterCounter}{0}\foreach \i in {1, ..., 3}{\inclLetterNextPage\par}
\caption{Кодирование $C$, $i=43$}
\label{ris_c2_a1_lz77p_i_43}
\end{figure}%
совпадение найдено только на последнем шаге $S = 1$ (рис.~\ref{ris_c2_a1_lz77p_i_43}, в), после уточнения $L$ получим $\{L=\hex{6}, S=\hex{1}\}$:
$$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 \pLS{F}{A} 5 4 \pLS{4}{7} A  B C D E F\pLS{6}{1} ...}$$

% В~дальнейшем совпадений нет (рис.~\ref{ris_c2_a1_lz77p_i_49})
% \begin{figure}[!ht]
% \includeNextPage\caption{Кодирование $C$, $i=49$}
% \label{ris_c2_a1_lz77p_i_49}
% \end{figure}%
% и~до конца сообщения записываться будут несжатые байты. Среди них \hex{6}, требующий экранирования:
% $$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 \pLS{F}{A} 5 4 \pLS{4}{7} A  B C D E F\pLS{6}{1} 0 1 2 3 E F C D 4 5 \pfx 7 8 9 A B}$$
% Отметим, что в~кодируемой части $C$ символ \hex{6} встречается \emph{два} раза, а~экранировать его пришлось только \emph{один} раз
% "--- первое вхождение стало частью ссылки.
% Такое совпадение удачно сократило объём кода, но предсказать его заранее по частотам символов было невозможно.

% В~дальнейшем до окончания кодирования в~позиции $i=n-L_{\max}+1=64-15+1=50$ совпадений нет (рис.~\ref{ris_c2_a1_lz77p_i_49_50}, а--б)
На следующей позиции $i=43$ (рис.~\ref{ris_c2_a1_lz77p_i_49}, а--б)
\begin{figure}[!ht]
\setcounter{mpimgLetterCounter}{0}\foreach \i in {1, 2}{\inclLetterNextPage\par}
% \caption{Кодирование $C$: а) $i=49$; б) $i=50$}
% \label{ris_c2_a1_lz77p_i_49_50}
\caption{Кодирование $C$, $i=49$}
\label{ris_c2_a1_lz77p_i_49}
\end{figure}%
% и~до останова после $i=50$ записываться будут несжатые байты:
% $$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 \pLS{F}{A} 5 4 \pLS{4}{7} A  B C D E F\pLS{6}{1} 0 1}$$
также находим совпадение $\{L=\hex{8}, S=\hex{F}\}$ и~после того, как убедимся, что далее в~окне нет ещё лучшего совпадения, записываем ссылку:
$$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 \pLS{F}{A} 5 4 \pLS{4}{7} A  B C D E F\pLS{6}{1}\pLS{8}{F}...}$$

Следующая позиция кодирования $i=57$ (рис.~\ref{ris_c2_a1_lz77p_i_57})
\begin{figure}[!ht]
\includeNextPage\caption{Останов поиска совпадений $C$, $i=57$}
\label{ris_c2_a1_lz77p_i_57}
\end{figure}%
превышает заданную в~опции \ref{item_a1_last_e} границу $i_{\max}=n-L_{\max}+1=64-15+1=50$ "--- останов поиска совпадений.

% Отметим, что в~позиции кодирования $i=50$ (рис.~\ref{ris_c2_a1_lz77p_i_49_50}, б),
% полноразмерный (длины $L_{\max}=15$) эталон ещё доступен, но уже «упирается» в~конец файла.
% Если бы опция \ref{item_a1_last_e} предписывала продолжать кодирование дальше "--- пришлось бы уменьшать максимально возможное $L$ на каждом шаге.

Отметим, что если бы поиск совпадений продолжался "--- его алгоритм бы отличался от описанного ранее, так как
в~позиции кодирования $i=57$ (рис.~\ref{ris_c2_a1_lz77p_i_57})
недоступен эталон максимальной длины $L_{\max}=15$, а только до конца файла (восемь символов).

% полноразмерный (длины $L_{\max}=15$) эталон уже недоступен.
% Если бы опция \ref{item_a1_last_e} предписывала продолжать кодирование дальше "--- пришлось бы уменьшать максимально возможное $L$ на каждом шаге.

% После останова кодирования (после $i=50$) 
После останова поиска совпадений и~до конца файла
записываться будут несжатые байты, но префикс \hex{6} по опции \ref{item_a1_last_e_prefix} экранируется:
$$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 \pLS{F}{A} 5 4 \pLS{4}{7} A  B C D E F\pLS{6}{1} \pLS{8}{F} 4 5 \pfx 7 8 9 AB}$$
Отметим, что в~кодируемой части $C$ символ \hex{6} встречается \emph{два} раза, а~экранировать его пришлось только \emph{один} раз
"--- первое вхождение стало частью ссылки.
Такое совпадение удачно сократило объём кода, но предсказать его заранее по частотам символов было невозможно.

% Отметим также, что
% для %$C$ 
% сообщения
% длины $n=64$ в~позиции кодирования $i=50$ (рис.~\ref{ris_c2_a1_lz77p_i_50}),
% \begin{figure}[!ht]
% \includeNextPage\caption{Кодирование $C$, $i=n-L_{\max}+1=64-15+1=50$}
% \label{ris_c2_a1_lz77p_i_50}
% \end{figure}%
% где по опции \ref{item_a1_last_e} заканчивается кодирование,
% % на~позиции $i=n-L_{\max}+1$, где ещё доступен полноразмерный эталон.
% полноразмерный (длины $L_{\max}=15$) эталон ещё доступен, но уже «упирается» в~конец файла.
% Если бы опция \ref{item_a1_last_e} предписывала продолжать кодирование дальше "--- пришлось бы уменьшать максимально возможное $L$ на каждом шаге.



% % % Тем не менее, рассмотрим, как строился бы код вблизи конца файла, если бы совпадения там были.
% % 
% % При $i \geqslant n-L_{\max}$, где $n$ "--- длина сообщения, возникают дополнительные ограничения.
% Отметим также, что
% для %$C$ 
% сообщения
% длины $n=64$ в~позиции кодирования $i=51$ (рис.~\ref{ris_c2_a1_lz77p_i_51})
% \begin{figure}[!ht]
% \includeNextPage\caption{Кодирование $C$, $i=n-L_{\max}+2=64-15+2=51$}
% \label{ris_c2_a1_lz77p_i_51}
% \end{figure}%
% возможная длина эталона ограничена сверху не только $L_{\max} = 15$ (максимально возможно кодируемой длиной),
% но и~концом файла,
% так что фактическая максимально возможная длина совпадения здесь $L_{\max}^i = 14$, а~для последующих позиций будет уменьшаться дальше.
% % В~сообщении $C$ в~окне нет совпадения даже минимально воз
% В общем случае это ограничение возникает при $i\geqslant n-L_{\max}+2$.
% 
% % Отметим также, что
% Для $C$ длины $n=64$ в~позиции кодирования $i=61$ 
% % (рис.~\ref{ris_c2_a1_lz77p_i_61}, а)
% (рис.~\ref{ris_c2_a1_lz77p_i_61})
% \begin{figure}[!ht]
% \includeNextPage\caption{Кодирование $C$, $i=61$}
% % \setcounter{mpimgLetterCounter}{0}\foreach \i in {1, 2}{\inclLetterNextPage\par}\caption{Кодирование $C$, $i=61$ и~$i=62$}
% \label{ris_c2_a1_lz77p_i_61}
% \end{figure}%
% существуют как минимально возможный эталон $E_{\min} = \hex{8 9 A B}$, так и~окно для его поиска,
% так что в~ином сообщении той же длины на этой позиции могла бы быть ссылка.
% 
% В~позиции $i=62$ 
% % (рис.~\ref{ris_c2_a1_lz77p_i_61}, б) 
% (рис.~\ref{ris_c2_a1_lz77p_i_62})
% \begin{figure}[!ht]
% \includeNextPage\caption{Кодирование $C$, $i=62$}
% % \setcounter{mpimgLetterCounter}{0}\foreach \i in {1, 2}{\inclLetterNextPage\par}\caption{Кодирование $C$, $i=61$ и~$i=62$}
% \label{ris_c2_a1_lz77p_i_62}
% \end{figure}%
% окно есть, а~эталона даже минимально возможной длины \emph{не существует,}
% поэтому 
% % если кодирование дошло до этой позиции, то есть последние три символа не были ранее записаны как часть ссылки 
% % "--- эти три символа записываются как несжатые символы.
% % Согласно опции \ref{item_a1_last_e_prefix}, если среди этих трёх символов встретится префикс, он экранируется: теоретически, как и~в~начале файла, этого можно не делать
% % символ на позиции $i=62$ (в~общем случае при $i=n-L_{\min}+1$) началом ссылки быть не может и~записывается как несжатый \hex{9}.
% с~позиции $i=62$ (в~общем случае при $i=n-L_{\min}+1$) не может начаться ссылка; записывается несжатый символ \hex{9}.
% Две следующие (предпоследняя и~последняя) позиции "--- также символы \hex{A} и~\hex{B}.
% 
% % на~позиции $i=n-L_{\min}+1$, где ещё доступен минимально возможный эталон "--- если последние $L_{\min}-1$ символов не были ранее записаны как часть ссылки,
% % остаток записываем тоже «как есть».

Таким образом, у кодера А1 есть три интервала с~разными режимами работы:
\begin{anumerate}
\item $1 \leqslant i \leqslant S_{\max}$ "--- символы переписываются «как есть»: без ссылок, префикс не~экранируется;
\item $S_{\max}+1 \leqslant i \leqslant n-L_{\max}+1$ "--- «нормальное» кодирование: 
\begin{itemize}
\item окно длины $w=S_{\max}$;
\item эталон длины  от $L_{\min}$ (в~начале поиска) до $L_{\max}$;
\item префикс экранируется;
\end{itemize}
\item $i \geqslant n-L_{\max}+2$ "--- каждый очередной символ записывается как несжатый, префикс %по опции \ref{item_a1_last_e_prefix} 
экранируется.
\end{anumerate}
У~декодера А1 будет только два интервала с~разными режимами работы:
\begin{anumerate}
\item $1 \leqslant i \leqslant S_{\max}$ "--- символы переписываются «как есть»: ссылок быть не может, префикс не анализируется;
\item $S_{\max}+1 \leqslant i \leqslant n$ "--- «нормальное» декодирование: анализируется префикс.
\end{anumerate}
Именно ради упрощения декодирования (чтобы «хвост» кода анализировался по общему правилу) в~А1 была включена опция \ref{item_a1_last_e_prefix}.
Если при кодировании в~интервале (в) не экранировать префикс (это будет уже не алгоритм А1, так как  опция \ref{item_a1_last_e_prefix} отличается) "--- код будет немного короче,
но декодирование "--- сложнее.


% В~дальнейшем совпадений нет (рис.~\ref{ris_c2_a1_lz77p_i_49})
% \begin{figure}[!ht]
% \includeNextPage\caption{Кодирование $C$, $i=49$}
% \label{ris_c2_a1_lz77p_i_49}
% \end{figure}%
% и~до конца сообщения записываться будут несжатые байты. Среди них \hex{6}, требующий экранирования:
% $$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 \pLS{F}{A} 5 4 \pLS{4}{7} A  B C D E F\pLS{6}{1} 0 1 2 3 E F C D 4 5 \pfx 7 8 9 A B}$$
% Отметим, что в~кодируемой части $C$ символ \hex{6} встречается \emph{два} раза, а~экранировать его пришлось только \emph{один} раз
% "--- первое вхождение стало частью ссылки.
% Такое совпадение удачно сократило объём кода, но предсказать его заранее по частотам символов было невозможно.
% 
% Отметим также, что
% для %$C$ 
% сообщения
% длины $n=64$ в~позиции кодирования $i=50$ (рис.~\ref{ris_c2_a1_lz77p_i_50}),
% \begin{figure}[!ht]
% \includeNextPage\caption{Кодирование $C$, $i=n-L_{\max}+1=64-15+1=50$}
% \label{ris_c2_a1_lz77p_i_50}
% \end{figure}%
% где по опции \ref{item_a1_last_e} заканчивается кодирование,
% % на~позиции $i=n-L_{\max}+1$, где ещё доступен полноразмерный эталон.
% полноразмерный (длины $L_{\max}=15$) эталон ещё доступен, но уже «упирается» в~конец файла.
% Если бы опция \ref{item_a1_last_e} предписывала продолжать кодирование дальше "--- пришлось бы уменьшать максимально возможное $L$ на каждом шаге.

\FloatBarrier

\subsubsection{Декодирование А1}

При декодировании из заголовка файла прочитаны номер алгоритма (А1) и~значение префикса ($p=\hex{6}$); 
% и~доступен код:
кроме того, в~архиве записан код:
% $$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 6FA ...}$$
% $$A1(C) = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 6{F}{A} 5 4 6{4}{7} A  B C D E F 6{6}{1} 0 1 2 3 E F C D 4 5 60 7 8 9 A B}.$$
$$A1(C) = \hex{ 0123401234567896FA54647ABCDEF66168F4560789AB}.$$
Известно, что первые $15_{10}$ байтов А1 записывал «как есть», так что при декодировании они копируются без дополнительного анализа:
$$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9  ...}$$
Счётчик позиции $i$ для декодера увеличивается при каждой записи символа в~выходной (уже декодированный) поток, то есть здесь $i = 15_{10}$.


Начиная с~позиции $i = 16_{10}$, требуется проверять каждый прочитанный байт на равенство префиксу \hex{6}.
Так, байт на позиции $16_{10}$ равен \hex{6} "--- читаем следующий и~сравниваем его с~нулём.
Следующий $\hex{F} \neq 0$ "--- значит, это начало ссылки: $L = \hex{F}=15_{10}$, а~далее записано $S = \hex{A}=10_{10}$.

Таким образом, необходимо взять файл с~\textbf{уже декодированным} текстом $C$, прочитать десятый с~конца символ и~вставить его в~конец файла:
% Необходимо \hex{F} раз скопировать \hex{A}-й с~конца символ в~конец файла:
$$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 0 ...},$$
затем ещё раз прочитать десятый с~конца символ (конец файла сместился, так что это будет уже другой символ "--- следующий за прочитанным ранее) и~вставить вновь прочитанный символ в~конец:
$$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 0 1 ...},$$
и повторить это в~общей сложности пятнадцать раз:
$$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 ...}$$
Каждый раз символ для копирования существует. 
% Даже когда копирование выполняется функцией $memcpy()$ или подобной ей "--- 
% % оно всё равно выполняется побайтово
% конец файла всегда успевает отодвинуться 
% Счётчик $i$ для декодера увеличивается при каждой записи символа в~выходной поток, то есть после декодирования ссылки

При каждой записи увеличивается $i$, в~итоге получим $i = i+L= 15+15 = 30$.

После окончания разбора ссылки \hex{6FA} ($i = 30$) читаем следующий байт входного потока "--- это \hex{5}. 
Он не равен префиксу $p=\hex{6}$, поэтому его необходимо переписать в~выходной поток «как есть»:
$$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 ...}$$
Далее действуем аналогично: символ $\hex{4} \neq p$ переписываем «как есть»: 
$$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 4 ...}$$
символ $\hex{6}=p$ %обрабатываем как 
"--- префикс: после него ненулевой байт \hex{4},
так что это начало ссылки \hex{647} "--- четыре раза читаем седьмой с~конца символ, после каждого раза записываем прочитанное в~конец и~только после записи можем читать снова: 
$$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 4 0 1 2 3 ...},$$
далее
символы \hex{ABCDEF}:
$$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 4 0 1 2 3 A B C D E F ...}$$
и~ссылка \hex{661} "--- шесть раз читаем последний символ файла, после каждого раза записываем прочитанное в~конец:
$$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 4 0 1 2 3 A B C D E F F F F F F F ...};$$
хотя символы получаются одинаковыми, но источник для копирования каждый раз новый.
Случай $S=1$ не является особым и обрабатывается по общему правилу.
% Далее "--- символы \hex{0123EFCD45}:
% $$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 4 0 1 2 3 A B C D E F F F F F F F 0 1 2 3 E F C D 4 5  ...}$$
% Следующий символ \hex{6} обрабатываем как префикс: читаем следующий "--- это нулевой байт, значит, это не начало ссылки, а~экранированный символ \hex{6}:
% $$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 4 0 1 2 3 A B C D E F F F F F F F 0 1 2 3 E F C D 4 5 6 ...},$$
% далее "--- символы \hex{7 8 9 A B}.
Далее "--- %символ \hex{6} "--- префикс, начинает ссылку 
ссылка \hex{68F}:
$$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 4 0 1 2 3 A B C D E F F F F F F F 1 2 3 A B C D E  ...}$$
и~символы \hex{4 5}:
$$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 4 0 1 2 3 A B C D E F F F F F F F 1 2 3 A B C D E 4 5  ...}$$
Далее символ \hex{6} "---  
% префикс: читаем следующий "--- это нулевой байт, значит, это не начало ссылки, а~экранированный символ \hex{6}:
префикс: после него \hex{0} "--- не начало ссылки, а~собственно \hex{6}:
$$C = \hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 4 0 1 2 3 A B C D E F F F F F F F 0 1 2 3 E F C D 4 5 6 ...},$$
далее "--- символы \hex{7 8 9 A B}.
Полученное сообщение
$$\hex{0 1 2 3 4 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 4 0 1 2 3 A B C D E F F F F F F F 1 2 3 A B C D E 4 5 6 7 8 9 A B}$$
совпадает с~исходным по содержанию и~длине. 

\warningframebox{%
Декодирование любого варианта LZ77 выполняется намного быстрее кодирования: не нужен трудоёмкий поиск, отсчитываем заданное в~архиве смещение.
}

\subsubsection{А1 и~исходная длина файла $n$}

Рассмотреннaя здесь реализация А1 метода LZ77 "--- один из немногих алгоритмов сжатия, которые никогда не дописывают незначащие символы в~конце, и, соответственно, при декодировании не требуют исходной длины $n$.
Тем не менее, для дополнительного контроля целостности $n$ лучше сохранить в~архиве,
а~если A1 применяется совместно с~каким-либо кодом сжатия без контекста, защиты от помех или шифрования "--- $n$ необходима для корректного декодирования.

\FloatBarrier

\subsection{Алгоритм А2 семейства LZ77, подсемейство «с~односимвольным префиксом»}
% \subsubsection{Некоторые другие алгоритмы семейства LZ77, сходные с~А1}
% \subsubsubsection{А2}

Рассмотрим алгоритм \textbf{А2} семейства LZ77, который отличается от А1 только опцией~\ref{item_a1_first_w}: \textbf{поиск совпадений начинается так рано, как это возможно.}
При этом один первый символ всё равно записываются «как есть», так как перед ним нет ни одной позиции. Таким образом, ссылка на предыдущее вхождение невозможна, а~значит "--- 
% и~префикс экранировать нет смысла.
если даже первый символ сообщения совпадает с~выбранным префиксом, экранировать его нет смысла.

\setcounter{mpimgPageCounter}{0}
\renewcommand\mpImgName{\IMGPATH/c3_a2_lz77p_page\arabic{mpimgPageCounter}}

Кодирование начинается только с~позиции $i=2$. Необходимо учитывать статистику от $i=2$ до конца $i=n$.
По этим частотам (рис.~\ref{ris_c2_a2_lz77p_prefix_sel}) 
\begin{figure}[!ht]
\includeNextPage
\caption{Выбор префикса для сообщения $C$ (алгоритм А2)}
\label{ris_c2_a2_lz77p_prefix_sel}
\end{figure}%
префиксом, согласно опции~\ref{item_a1_prefix_sel}, выбирается уже байт \hex{C}.

Для позиции $i=2$ (рис.~\ref{ris_c2_a2_lz77p_i_1})
\begin{figure}[!ht]
\includeNextPage
\caption{Кодирование $C$, $i=2$}
\label{ris_c2_a2_lz77p_i_1}
\end{figure}%
окно состоит из единственного возможного смещения $S=1$ (позиция $i=1$). 
Здесь четырёхбайтовое слово \hex{0123} по смещению $S=1$ не совпадает с~минимально возможным четырёхбайтовым эталоном $E_{\min} = \hex{1234}$, поэтому 
второй байт \hex{1} записывается как несжатый символ.

Отметим, что для иного сообщения, в~частности, для $C = \hex{00000...}$, слово по смещению $S=1$ могло бы совпасть с~эталоном и~для $i=2$ могла быть записана ссылка с~$S=1$ и~некоторым $4 \leqslant L\leqslant L_{\max}$. 
Так, для $C_{\text{л}16} = \hex{0000 0000 0000 0000}$ из шестнадцати нулевых байтов код $A2(C_{\text{л}16}) = 0\pLS[1]{F}{1}$ (префиксом согласно опции~\ref{item_a1_prefix_sel} выбран байт \hex{1}).

Соответственно, если второй, третий и~т.\,д. символы сообщения совпадают с~выбранным префиксом "--- их в~А2 необходимо экранировать. 


Для позиции $i=3$ (рис.~\ref{ris_c2_a2_lz77p_i_2}, а--б)
\begin{figure}[!ht]
\setcounter{mpimgLetterCounter}{0}\foreach \i in {1, ..., 2}{\inclLetterNextPage\par}
\caption{Кодирование $C$, $i=3$}
\label{ris_c2_a2_lz77p_i_2}
\end{figure}%
окно состоит из двух возможных смещений $S=2$ и~$S=1$ (позиции $i=1$ и~$i=2$), и~далее аналогично.


Таким образом, для каждой позиции $2 \leqslant i \leqslant S_{\max}+1$ окно состоит из $i-1$ возможных смещений (ограничением является начало файла): 
\begin{itemize}
\item смещение $S=i-1$ соответствует позиции $1$ сообщения (первой);
\item смещение $S=1$ соответствует позиции $i-1$ сообщения (непосредственно предшествующей кодируемому слову/символу);
\end{itemize}
при $i=S_{\max}+1$ (для А2 при $i=16$) размер $i-1$ этого окна 
% совпадает с~максимально возможным размером окна $S_{\max}$.
достигает $S_{\max}$.
% 
% % Смещения б\'{о}льшие, чем $S_{\max}$, невозможно записать (по определению $S_{\max}$), поэтому д
% Далее, при $i \geqslant S_{\max}+1$, окно состоит из $S_{\max}$ возможных смещений, как и~в~А1 (ограничением является то, что по определению величины $S_{\max}$ невозможно записать смещения б\'{о}льшие, чем $S_{\max}$): 
% \begin{itemize}
% \item смещение $S=S_{\max}$ соответствует позиции $i-S_{\max}$ сообщения;
% \item смещение $S=1$ соответствует позиции $i-1$.
% \end{itemize}
% 
% 
% % Таким образом, в~коде А2 (рис.~\ref{ris_c2_a2_lz77p_final}) 
% Таким образом, получаем рис.~\ref{ris_c2_a2_lz77p_final}.
Далее кодирование А2 аналогично А1 (рис.~\ref{ris_c2_a2_lz77p_final}).
\begin{figure}[!ht]
\includeNextPage
\caption{Сообщение $C$ и~его код А2}
\label{ris_c2_a2_lz77p_final}
\end{figure}%
% первый символ всегда записывается «как есть»,
% % при $2 \leqslant i \leqslant 15$ используется укороченное окно,
% % при $i\geqslant 16$ код A2 строится так же, как и~А1. 
% при $2 \leqslant i \leqslant S_{\max}$ используется укороченное окно,
% при $i\geqslant S_{\max}+1$ код A2 строится так же, как и~А1. 
% 
% % , с~поправкой на $p = \hex{A}$.

% Для рассматриваемого сообщения $C$ код А2 (48 байтов) получился на один байт короче, чем А1 (49 байтов).
Для рассматриваемого сообщения $C$ код А2 (42 байта) получился на два байта короче, чем А1 (44 байта).
% Для других сообщений длины кодов А1 и~А2 могут совпадать; также А2 может оказаться длиннее А1 "---
% 
Для другого сообщения код А2 может, наоборот, оказаться длиннее А1: 
если в~позициях $2 \leqslant i \leqslant S_{\max}$
% % (которые А2 кодирует, а~А1 переписывает «как есть»),
% "--- которые А1 переписывает «как есть», а~А2 кодирует, вставляя ссылки и~экранируя 
% % символы, равные выбранному префиксу
% символ"~префикс
% "--- 
нет или мало совпадений, зато часто встречается 
% символ, равный выбранному префиксу.
символ"~префикс.
% 
% Для некоторых сообщений длины А2 и~А1 могут совпадать.

Различие длин кодов А1 и~А2 всегда относительно невелико: результат их работы отличается только в~первых $S_{\max}$ позициях файла, а~любой алгоритм сжатия имеет смысл применять только к~достаточно длинным файлам, то есть $n \gg S_{\max}$.

Реализация А2 сложнее А1. У~кодера А2 есть \textbf{четыре} интервала с~разными режимами работы (у~кодера А1 "--- три):
\begin{anumerate}
\item $i = 1$ "--- первый символ переписывается «как есть»: префикс не~экранируется;
\item $2 \leqslant i \leqslant S_{\max}$ "--- кодирование начала файла (используется укороченное окно):
\begin{itemize}
\item окно длины $i$;
\item эталон длины от $L_{\min}$ (в~начале поиска) до $L_{\max}$;
\item префикс экранируется;
\end{itemize}
\item $S_{\max}+1 \leqslant i \leqslant n-L_{\max}+1$ "--- «нормальное» кодирование: 
\begin{itemize}
\item окно длины $w=S_{\max}$;
\item эталон длины $L_{\min}$ (в~начале поиска) до $L_{\max}$;
\item префикс экранируется;
\end{itemize}
\item $i \geqslant n-L_{\max}+2$ "--- каждый очередной символ записывается как несжатый, префикс %по опции \ref{item_a1_last_e_prefix} 
экранируется.
\end{anumerate}
У~декодера А2, как и~у А1 "--- два интервала с~разными режимами работы: % (интервалы отличаются от А1):
\begin{anumerate}
\item $i = 1$ "--- первый символ переписывается «как есть»: ссылки быть не может, префикс не~анализируется;
\item $2 \leqslant i \leqslant n$ "--- «нормальное» декодирование: анализируется префикс.
\end{anumerate}
Режимы аналогичны декодеру А1, а~интервалы разные: для А2 нужен отдельный не только кодер, но и~декодер.

\subsection{Алгоритм А3 семейства LZ77, подсемейство «с~односимвольным префиксом»}

Рассмотрим также алгоритм \textbf{А3} семейства LZ77, который отличается от А1 только опцией~\ref{item_a1_last_e}: \textbf{поиск совпадений заканчивается так поздно, как это возможно.}




% % % Тем не менее, рассмотрим, как строился бы код вблизи конца файла, если бы совпадения там были.
% % 
% % При $i \geqslant n-L_{\max}$, где $n$ "--- длина сообщения, возникают дополнительные ограничения.
% Отметим также, что
% для %$C$ 
% сообщения
% длины $n=64$ в~позиции кодирования $i=51$ (рис.~\ref{ris_c2_a1_lz77p_i_51})
% \begin{figure}[!ht]
% \includeNextPage\caption{Кодирование $C$, $i=n-L_{\max}+2=64-15+2=51$}
% \label{ris_c2_a1_lz77p_i_51}
% \end{figure}%
% возможная длина эталона ограничена сверху не только $L_{\max} = 15$ (максимально возможно кодируемой длиной),
% но и~концом файла,
% так что фактическая максимально возможная длина совпадения здесь $L_{\max}^i = 14$, а~для последующих позиций будет уменьшаться дальше.
% % В~сообщении $C$ в~окне нет совпадения даже минимально воз
% В общем случае это ограничение возникает при $i\geqslant n-L_{\max}+2$.
% 
% % Отметим также, что
% Для $C$ длины $n=64$ в~позиции кодирования $i=61$ 
% % (рис.~\ref{ris_c2_a1_lz77p_i_61}, а)
% (рис.~\ref{ris_c2_a1_lz77p_i_61})
% \begin{figure}[!ht]
% \includeNextPage\caption{Кодирование $C$, $i=61$}
% % \setcounter{mpimgLetterCounter}{0}\foreach \i in {1, 2}{\inclLetterNextPage\par}\caption{Кодирование $C$, $i=61$ и~$i=62$}
% \label{ris_c2_a1_lz77p_i_61}
% \end{figure}%
% существуют как минимально возможный эталон $E_{\min} = \hex{8 9 A B}$, так и~окно для его поиска,
% так что в~ином сообщении той же длины на этой позиции могла бы быть ссылка.
% 
% В~позиции $i=62$ 
% % (рис.~\ref{ris_c2_a1_lz77p_i_61}, б) 
% (рис.~\ref{ris_c2_a1_lz77p_i_62})
% \begin{figure}[!ht]
% \includeNextPage\caption{Кодирование $C$, $i=62$}
% % \setcounter{mpimgLetterCounter}{0}\foreach \i in {1, 2}{\inclLetterNextPage\par}\caption{Кодирование $C$, $i=61$ и~$i=62$}
% \label{ris_c2_a1_lz77p_i_62}
% \end{figure}%
% окно есть, а~эталона даже минимально возможной длины \emph{не существует,}
% поэтому 
% % если кодирование дошло до этой позиции, то есть последние три символа не были ранее записаны как часть ссылки 
% % "--- эти три символа записываются как несжатые символы.
% % Согласно опции \ref{item_a1_last_e_prefix}, если среди этих трёх символов встретится префикс, он экранируется: теоретически, как и~в~начале файла, этого можно не делать
% % символ на позиции $i=62$ (в~общем случае при $i=n-L_{\min}+1$) началом ссылки быть не может и~записывается как несжатый \hex{9}.
% с~позиции $i=62$ (в~общем случае при $i=n-L_{\min}+1$) не может начаться ссылка; записывается несжатый символ \hex{9}.
% Две следующие (предпоследняя и~последняя) позиции "--- также символы \hex{A} и~\hex{B}.
% 
% % на~позиции $i=n-L_{\min}+1$, где ещё доступен минимально возможный эталон "--- если последние $L_{\min}-1$ символов не были ранее записаны как часть ссылки,
% % остаток записываем тоже «как есть».


\section{Коды семейства LZ77 с~префиксом}
\label{section_lz77_codes_prefix}
