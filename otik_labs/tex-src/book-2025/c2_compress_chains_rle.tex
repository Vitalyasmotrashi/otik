
% \newcommand{\upair}[2]{\ensuremath{%
% \left\{\begin{array}{@{}c@{}}
% {#1}\\ {#2}
% \end{array}\right\}
% }}

     
\newcommand{\LM}{\ensuremath{%
L_{\min}^{\text{сж}}
}}
    
\newcommand{\Lcmin}{\ensuremath{%
% L^c_{\min}
L_{\min}
}}
    
\newcommand{\Lcmax}{\ensuremath{%
% L^c_{\max}
L_{\max}
}}

% \newcommand{\uset}[1]{\ensuremath{%
% \left\{\begin{array}{@{}c@{}}
% #1
% \end{array}\right\}
% }}

% \newcommand{\rleLC}[2]{\ensuremath{%
% % \left\{\begin{array}{@{}c@{}}
% % {#1}\\ {#2}
% % \end{array}\right\}
% \{#1, #2\}
% }}

Повторение символа $c$ подряд $L$ раз "--- цепочку длины $L_{\min} \leqslant L \leqslant L_{\max}$ 
"--- будем записывать как пару $\rleLC{L}{c}$ "--- сжатую цепочку:
\begin{itemize}
\item повторение одного символа $c$ более чем $L_{\max}$ раз подряд "--- делится на несколько цепочек длины $L \leqslant L_{\max}$;
\item последовательность символов, где ни один не повторяется  $L_{\min}$ раз подряд "--- рассматривается как несжатый текст и~кодируется отдельно.
\end{itemize}
% Если $c$ и~$L$ одного размера "--- это имеет смысл (приводит к~сжатию цепочки) только при $L_{\min} > 2$ ($L_{\min}\geqslant 3$).
%  RLE "--- не код, а~\termin{семейство кодов,} основанных на одном принципе сжатия и~похожих моделях источника.
% 
% 
Схемы данных кодирования и~декодирования 
методом RLE представлены на рис.~\ref{ris_data_rle_n_encode}--\ref{ris_data_rle_p_decode} соответственно.

\subsubsection{Разделение сжатых цепочек RLE и~несжатого текста}

Исходный текст $C = c_1 \ldots c_n$ в~общем случае "--- произвольная последовательность байтов.
Соответственно,
% любое значение $L$, а~также любой код любой управляющей конструкции теоретически может встретиться в~$C$
любой код пары $\rleLC{L}{c}$  теоретически может встретиться в~$C$,
следовательно, 
% несжатый текст не может записываться «как есть» "--- 
необходимо отделять код $\rleLC{L}{c}$ от кода несжатого текста.
Основных способа три:
\begin{anumerate}
\item\label{item_rle_n} несжатого текста нет ($L_{\min} = 1$) "--- 
% «наивная» реализация метода RLE;
следуя  Мику ван Гельдерену, назовём такую реализацию наивной;
% Mick van Gelderen 
% https://github.com/mickvangelderen/rle-rust?ysclid=m2qi8tyhjy963428244

\item\label{item_rle_flagbit}
несжатый текст разбивается на фрагменты длины 
% $L_{\min}^{\text{несж}} \leqslant L \leqslant L_{\max}^{\text{несж}}$:
$1 \leqslant L \leqslant L_{\max}^{\text{несж}}$:
% "---
% реализация метода RLE с~флаг-битом сжатая/несжатая цепочка: 
\begin{itemize}
\item каждый фрагмент несжатого текста предваряется длиной (наподобие строки в~стиле Pascal) и~маркером несжатого текста;
\item каждая сжатая цепочка предваряется маркером сжатого текста;
% \item маркер сжатого/несжатого текста (два состояния) "--- один бит (флаг-бит);
% % \item 
% флаг-бит $\theta$ и~код длины  $\widetilde{L}$ помещаются в~один байт;
% % 
% % % из $k$-битного байта на $L$ остаётся $(k-1)$ бит;
% % ($\widetilde{L}$ занимает  $(k-1)$ бит);
\end{itemize}
% граничные значения $L$ для сжатой цепочки будем для определённости обозначать $\LM, L_{\max}^{\text{сж}}$;
маркер сжатого/несжатого текста (два состояния) "--- один бит \textbf{(флаг-бит),}
флаг-бит $\theta$ и~код длины  $\widetilde{L}$ помещаются в~один байт;

\item\label{item_rle_p} 
% Реализация метода RLE с~односимвольным префиксом.
из алфавита выбирается один символ $a = p$ и~назначается специальным символом (односимвольным \textbf{префиксом):}
\begin{itemize}
\item код каждой сжатой цепочки $\rleLC{L}{c}$ предваряется префиксом $p$ (цепочка записывается тремя байтами $p\, b_{1} \, b_{2}$);
\item каждый символ $c_i\neq p$ несжатого текста записывается «как есть» (одним байтом $c_i$);
\item символ $c_i= p$ несжатого текста записывается таким кодом из нескольких байтов, который начинается с~$p$ и~не совпадает с~началом  никакого кода $\rleLC{L}{c}$
"---
иначе говоря, символ $p$ в~несжатом тексте \emph{экранируется.}
\end{itemize}
% обычно символ $c_i= p$ несжатого текста записывается как $(p, 0)$, а~от кода $p~ b_{1} \, b_{2}$ цепочки $\rleLC{L}{c}$ требуется $b_{1}\neq 0$.

\end{anumerate}
В рамках данного пособия коды, использующие эти способы, будут обозначаться соответственно как
RLE-н (наивная реализация), 
RLE-$\theta$ (реализация с~флаг-битом сжатая/несжатая цепочка)
и~RLE-$p$  (с~односимвольным префиксом).




\section{Наивная реализация метода RLE (RLE-н)}

Любое количество повторений, включая однократное, рассматривается как сжатая цепочка ($L_{\min} = 1$, рис~\ref{ris_data_rle_n_encode}--\ref{ris_data_rle_n_decode}).

\begin{figure}[!ht]
\includegraphics[width=\linewidth]{\IMGPATH/data_rle_n}
\caption{Схема данных кодирования «наивной» реализацией метода RLE}
\label{ris_data_rle_n_encode}
\end{figure}

\begin{figure}[!ht]
\includegraphics[width=\linewidth]{\IMGPATH/data_rle_n_decode}
\caption{Схема данных декодирования «наивной» реализации метода RLE}
\label{ris_data_rle_n_decode}
\end{figure}

Как видно из рис.~\ref{ris_data_rle_n_encode}, позиция $i$ начала текущей цепочки ни на что не влияет 
% ни в~«наивной» реализации метода RLE, ни в~рассмотренных позднее.
в~«наивной» реализации метода RLE, в~рассмотренных далее реализациях RLE "--- также.
% В~простейшей реализации п
Переменной $i$ может вообще не существовать "--- достаточно 
двух переменных для $c_i$ и~$c_{i+L}$.
% одной переменной  для первого символа в~цепочке (на рис.~\ref{ris_data_rle_n_encode} это два разных блока: $c_i$ и~$c$) и~одной переменной для следующего прочитанного из $C$ символа ($c_{i+L}$).
При чтении $c_{i+L}$ из $C$ не анализируются $i$ и~$L$ "--- это просто следующий непрочитанный символ.
% Соответственно, н
На рис.~\ref{ris_data_rle_flagbit_encode}--
% и~рис.~
\ref{ris_data_rle_p_encode} блок $i$ не показан.


Для кодирования всех файлов 
% используется одна и~та~же пара глобальных констант 
используются одни и~те~же глобальные константы
$L_{\min} = 1$ и~$L_{\max}$
% , где $L_{\max}$ 
"---
определяется исходя из $L_{\min}$ и~формата записи $L$.

\subsection{Код со смещением для $L$}

Так как несжатого текста в~RLE"~н не существует,
код сжатой цепочки  $\rleLC{L}{c}$ максимально компактен и~состоит только из кода символа $c$ (символа $c$, записанного байтом «как есть») и~кода $L$ (обозначаемого $\widetilde{L}$). 
Их порядок ($\widetilde{L}c$ или  $c\widetilde{L}$) для RLE"~н безразличен, так что есть как минимум два варианта «наивной» реализации; 
далее рассмотрим вариант $\widetilde{L}c$.

Рассматриваем случай, когда код  $L$ (обозначим этот код $\widetilde{L}$) занимает один байт, как и~$c$. % или менее байта.
Случай, когда $\widetilde{L}$ занимает два и~более байта, описан в~разделе~\ref{sec_rle_n_model}.

Для $k$-битного байта $\widetilde{L}$ доступно $2^k$ кодовых комбинаций и~соответствующий диапазон значений: 
$$0 \leqslant \widetilde{L} \leqslant 2^k-1.$$ 

\subsubsection{Запись $L$ без смещения}

Простейший способ записи  $L$ "--- это запись байтом «как есть» ($\widetilde{L}=L$).
% , то есть 
% % $$
% % \text{
% файл \hex{1111~2223~3333~2} записывается как \hex{41~32~53~12}.
% % }
% % $$
% 
В~этом случае
из $2^k$ кодовых комбинаций используется
% но используется из них 
только $2^k-1$:
$$\left\{\begin{array}{@{\,}l@{}}0 \leqslant {L} \leqslant 2^k-1\\L \geqslant L_{\min} = 1\end{array}\right.
\implies
1 \leqslant {L} \leqslant 2^k-1.$$ 

Соответственно, для такого формата записи $L_{\max} = 2^k-1$.

% Для восьмибитного байта x86/amd64 %($k=8$) 
% $L_{\max} = 2^8-1=255$.

% Обозначим такой код RLE"~н"~0 (без смещения, то есть со смещением 0).

% Код RLE"~н, где $L$ записывается без смещения% (назовём его RLE"~н"~0: с~нулевым смещением)
% , более нагляден и~часто рассматривается в~иллюстративных целях.
% % Тем не менее, неиспользуемая кодовая комбинация ухудшает степень сжатия по сравнению с~аналог
% При этом его степень сжатия всегда не лучше и~иногда хуже, чем у~аналогичного RLE"~н, использующего все кодовые комбинации $\widetilde{L}$.

\subsubsection{Запись $L$ со смещением}

% Задействовать неиспользуемую ранее кодовую комбинацию $\widetilde{L}=0$ 
Разработаем такой код, чтобы минимальная возможная кодовая комбинация $\widetilde{L}=0$ соответствовала минимальному допустимому значению $L=L_{\min} = 1$:
будем записывать байт $\widetilde{L}
% =L-L_{\min}
=L-1$ (код со смещением $1$).
% , то есть тот же
% % Тогда 
% файл \hex{1111~2223~3333~2} записывается как \hex{31~22~43~02}.
Соответственно, при декодировании, прочитав $\widetilde{L}$, восстановим $L = \widetilde{L}+1$.

Тогда используются все кодовые комбинации:
$$\left\{\begin{array}{@{\,}l@{}}0 \leqslant {L-1} \leqslant 2^k-1\\L \geqslant L_{\min} = 1\end{array}\right.
\implies
1 \leqslant {L} \leqslant 2^k,$$ 
и~$L_{\max} = 2^k$.

Обозначим такой код RLE"~н"~1 (наивная реализация RLE со смещением 1), а~код, где $L$ записывается без смещения "--- RLE"~н"~0 (со смещением 0).

\subsubsection{Сравнение RLE"~н"~1 и~RLE"~н"~0}

% % Для трёхбитного байта %($k=3$) 
% % $L_{\max} = 2^3-1=7$, так что файл 
% % % % $A = \hex{0000~2222~2222~3345}$ будет записан как \hex{4072~1223~1415}.
% % $A = \hex{2222~2222}$ будет записан как две цепочки (четыре байта) \hex{7212}.
% % % "--- слишком длинная цепочка из восьми символов разбита на две допустимой длины.
% % % $$
% % % \text{файл $A = \hex{2222~2222}$ будет записан как \hex{7212}}
% % % $$
% 
% 
% Для трёхбитного байта $L_{\max}^\text{RLE"~н"~1} = 2^3=8$, и~файл $A = \hex{2222~2222}$ будет записан как 
% % \hex{3072~1304~05}.
% одна цепочка (два байта) \hex{72}.


% Рассмотрим трёхбитный байт ($k=3$) и~файл $A = \hex{2222~2222}$.
% 
% $L_{\max}^\text{RLE"~н"~0} = 2^3-1=7$, то есть $A$ будет разбит на две цепочки из 7 и 1 символов и~записан как \hex{7212}.
% 
% $L_{\max}^\text{RLE"~н"~1} = 2^3=8$, и~файл $A = \hex{2222~2222}$ будет записан как одна цепочка (два байта) \hex{72}.

Для трёхбитного байта %($k=3$) $L_{\max}^\text{RLE"~н"~0} = 2^3-1=7$ и~$L_{\max}^\text{RLE"~н"~1} = 2^3=8$.
$L_{\max}^\text{RLE"~н"~1} = 2^3=8$ против $L_{\max}^\text{RLE"~н"~0} = 2^3-1=7$.
Сравнение кодов RLE"~н"~0 и~RLE"~н"~1 в~этом случае показано в~таблице~\ref{tab_rle_n0_vs_n1}.
% Рассмотрим файл $A = \hex{2222~2222}$ из восьми одинаковых символов:
% % RLE"~н"~0 


\begin{table}[!ht]
\caption{Сравнение RLE"~н"~0 и~RLE"~н"~1 для трёхбитного байта %(для $k=3$)
}
% \renewcommand{\tabularxcolumn}[1]{m{#1}}	% для копирования
\setlength{\tabcolsep}{5pt}

\label{tab_rle_n0_vs_n1}
\begin{tabularx}{\linewidth}{|@{}>{\centering\arraybackslash}m{2em}@{}|l|L|L|}
\hline
% Исходный файл & код RLE"~н"~0, $L_{\max}^\text{RLE"~н"~0} = 2^3-1=7$ & код RLE"~н"~1, $L_{\max}^\text{RLE"~н"~1} = 2^3=8$ \\\hline
№ п/п & Исходный файл & RLE"~н"~0 \hfill $\big(L_{\max}^\text{RLE"~н"~0} = 7\big)$  & RLE"~н"~1 \hfill $\big(L_{\max}^\text{RLE"~н"~1} = 8\big)$\\\hline
% \hex{1111222333332} & \hex{1111 222 33333 2 = 41~32~53~12} & \hex{31~22~43~02} \\\hline
1&\hex{1111~2223~3333~2} & \hex{41~32~53~12} & \hex{31~22~43~02} \\\hline
2&\hex{1} & \hex{11} & \hex{01} \\\hline
3&\hex{1111~111} & \hex{71} & \hex{61} \\\hline
4&\hex{1111~1111} & \hex{71~11} & \hex{71} \\\hline
5&\hex{1111~1111~1} & \hex{71~21} & \hex{71~01} \\\hline
6&\hex{1111~1111~1111~1111} & \hex{71~71~21} & \hex{71~71} \\\hline
7&\hex{1111~1111~2222~2222} & \hex{71~11~72~12} & \hex{71~72} \\\hline
\end{tabularx}
\end{table}%


% $\text{RLE-н-0}(A) = \hex{7212}$, $\text{RLE-н}(A) = 72$.


Независимо от размера байта $k$:
\begin{itemize}[wide]
\item код RLE"~н"~0 более нагляден, поэтому часто рассматривается в~иллюстративных целях;
\item у~кода RLE"~н"~1 выше степень сжатия:
сжатый RLE"~н"~1 файл всегда не~длиннее и~иногда короче (в~особом случае может быть вдвое короче), чем тот же файл, сжатый RLE"~н"~0;

\item
при этом скорость кодирования/декодирования RLE"~н"~1 и~RLE"~н"~0 одинакова, так как 
временные затраты на сложение/вычитание чисел пренебрежимо малы по сравнению  с~ветвлениями  и~особенно с~чтением/записью в~файл.

\end{itemize}

%  При этом 
% , аналогичном строкам 4 и~7 таблицы~\ref{tab_rle_n0_vs_n1},

Для восьмибитного байта %x86/amd64 
% Для $k=8$ (байта) %x86/amd64 
$L_{\max}^\text{RLE"~н"~1} = 2^8=256$, \mbox{$L_{\max}^\text{RLE"~н"~0} = 2^8-1=255$.}
% так что относительный выигрыш меньше, 
% так что с

Случай, аналогичный строке 7 таблицы~\ref{tab_rle_n0_vs_n1} (код RLE"~н"~1 вдвое короче RLE"~н"~0) достигается и~здесь "--- 
в~частности, если 
% файл состоит из серий по 256
в~файле идёт подряд 256 байтов \hex{01}, затем  подряд 256 байтов \hex{02} и~т.\,д.

Вообще, если для RLE-кодов A и~B $L_{\max}^A < L_{\max}^B$


% Код RLE"~н"~0, где $L$ записывается без смещения% (назовём его RLE"~н"~0: с~нулевым смещением)
% , более нагляден и~часто рассматривается в~иллюстративных целях.
% % % Тем не менее, неиспользуемая кодовая комбинация ухудшает степень сжатия по сравнению с~аналог
% % При этом его степень сжатия всегда не лучше и~иногда хуже, чем у~аналогичного RLE"~н"~1, использующего все кодовые комбинации $\widetilde{L}$.
% 
% У~кода RLE"~н"~1 выше степень сжатия.
% Сжатый RLE"~н"~1 файл всегда не длиннее и~иногда короче (в~особом случае, аналогичном строкам 4 и~7 таблицы~\ref{tab_rle_n0_vs_n1}, может быть даже вдвое короче), чем тот же файл, сжатый RLE"~н"~0.
% 
% При этом скорость кодирования/декодирования RLE"~н"~1 и~RLE"~н"~0 одинакова, так как 
% % при той же скорости кодирования/декодирования:
% % временем сложения/вычитания чисел можно пренебречь по сравнению с~условиями и~особенно с~чтением/записью в~файл.
% временные затраты на сложение/вычитание чисел пренебрежимо малы по сравнению  с~ветвлениями  и~особенно с~чтением/записью в~файл.


% % \subsubsection{Длина кода в~наилучшем случае}
% % 
% % Наилучший случай длины $n$ для любой реализации RLE "--- это файл из $n$ одинаковых символов:
% % $$
% % C_\text{л} = \hex{0000\ldots0000}
% % $$
% % Длина кода RLE-н такого файла (считаем $n\to \infty$,% или $n$ кратно $L_{\max}$
% % то есть пренебрегаем тем, что последняя цепочка, возможно, короче  $L_{\max}$):
% % $$
% % \big|\text{RLE-н}(C_\text{л})\big| = 2\cdot \dfrac{n}{L_{\max}}
% % $$
% % Для восьмибитного байта x86/amd64 и~кода $L$ без смещения 
% % % $L_{\max} = 2^8-1=255$, для смещения 1 "--- $L_{\max} = 2^8=256$.
% % % Для восьмибитного байта x86/amd64 и~кода RLE"~н"~0 
% % $$L_{\max}^\text{RLE"~н"~0} = 2^8-1=255,$$ для смещения 1:$$L_{\max}^\text{RLE"~н"~1} = 2^8=256.$$
% % Таким образом, код RLE"~н"~1 короче на
% % $$
% % \big|\text{RLE-н-0}(C_\text{л})\big|-\big|\text{RLE-н-1}(C_\text{л})\big|
% % = 2\cdot \dfrac{n}{L_{\max}^\text{RLE"~н"~0}} - 2\cdot \dfrac{n}{L_{\max}^\text{RLE"~н"~1}}
% % % = 2\cdot n \left( \dfrac{1}{L_{\max}^\text{RLE"~н"~0}} - \dfrac{1}{L_{\max}^\text{RLE"~н"~1}}\right)
% % = 2\cdot n \left( \dfrac{1}{255} - \dfrac{1}{256}\right)
% % $$

\subsection{Обработка конца файла}

При кодировании конец файла %«наивной» реализацией метода RLE
при попытке чтения $c_{i+L}$ обрабатывается как $c_{i+L}\neq c$.
% Если при этом существует переменная $i$ для проверки $$

\section{Реализация метода RLE с~флаг-битом сжатая/несжатая цепочка (RLE-$\theta$)}

\begin{figure}[!ht]
\includegraphics[width=\linewidth]{\IMGPATH/data_rle_flagbit}
\caption{Схема данных кодирования реализацией метода RLE с~флаг-битом сжатая/несжатая цепочка}
\label{ris_data_rle_flagbit_encode}
\end{figure}

\begin{figure}[!ht]
\includegraphics[width=\linewidth]{\IMGPATH/data_rle_flagbit_decode}
\caption{Схема данных декодирования реализации метода RLE с~флаг-битом сжатая/несжатая цепочка}
\label{ris_data_rle_flagbit_decode}
\end{figure}



Для кодирования всех файлов используется один и~тот же набор из~четырёх глобальных констант $\LM, L_{\max}^{\text{сж}}, L_{\min}^{\text{несж}} = 1, L_{\max}^{\text{несж}}$:
\begin{anumerate}
\item $\LM \in \{2, 3\}$ "--- выбирается на этапе реализации кодека;
\item $L_{\max}^{\text{сж}}$ определяется исходя из $\LM$ и~формата записи $L$ для сжатой цепочки;
\item $L_{\min}^{\text{несж}}=1$ всегда;
\item $L_{\max}^{\text{несж}}$ определяется исходя из формата записи $L$ для несжатой цепочки.
\end{anumerate}

% При выборе $\LM = 1$ получаем вариант «наивного» RLE, причём хуже описанного выше "--- разрядность  бит, отведённый  с~неиспользуемым битом $\theta$;
% Так как несжатый текст в~принципе существует "--- $\LM \geqslant 2$ ($\LM = 1$ получаем отсутствие  «наивного» RLE)

Если $\LM = 1$ "--- несжатый текст в~принципе отсутствует (вариант наивного RLE), так что RLE-$\theta$ имеет смысл рассматривать при $\LM \geqslant 2$.
Обычно выбирается $\LM \in \{2, 3\}$, лучшего из них  не существует:
так, для файла, содержащего последовательность вида \hex{1221} выгоднее $\LM  = 3$, а~для $\hex{1122}$ "--- $\LM  = 2$.

% Оптимального $\LM$ не существует: так, для файла, содержащего четыре байта \hex{1221} выгоднее $\LM  = 3$, а~для $\hex{1122}$ "--- $\LM  = 2$.
% % % теоретически возможно два кодека (с~разными кодами алгоритмов) 
% % при $\LM \geqslant 4$ длина кода всегда больше, чем для $\LM \in \{2, 3\}$. — Lmax!!!

Конец файла при попытке чтения  окончания $E$ (то есть если в~конце кодирования получится $E$ короче $L_{\min}$ символов) обрабатывается как ситуация
«не все символы $E$ одинаковы»; аналогично для $G$.

\section{Реализация метода RLE с~односимвольным префиксом}


\begin{figure}[!ht]
\includegraphics[width=\linewidth]{\IMGPATH/data_rle_p}

\caption{Схема данных кодирования реализацией метода RLE с~односимвольным префиксом}
\label{ris_data_rle_p_encode}
\end{figure}

\begin{figure}[!ht]
\includegraphics[width=\linewidth]{\IMGPATH/data_rle_p_decode}
\caption{Схема данных декодирования реализации метода RLE с~односимвольным префиксом}
\label{ris_data_rle_p_decode}
\end{figure}

Для кодирования всех файлов используется один и~тот же набор из~четырёх глобальных констант 
$L^{c\neq p}_{\min} = 4, L^{c\neq p}_{\max}, L^{p}_{\min}, L^{p}_{\max}$:
\begin{anumerate}
\item $L^{c\neq p}_{\min} = 4$;
\item $L^{c\neq p}_{\max}$ определяется исходя из $L^{c\neq p}_{\min}$ и~формата записи $L$;


\item $L^{p}_{\min}\in \left[1, L^{c\neq p}_{\min}\right]$ "--- выбирается на этапе реализации кодека;
\item $L^{p}_{\max}$ определяется исходя из $L^{p}_{\min}$ и~формата записи $L$.
\end{anumerate}
Оптимального $L^{p}_{\min}$ не существует: 
для каждого $L^{p}_{\min}$ есть файл, который именно при таком $L^{p}_{\min}$ сжимается лучше всего.

Для каждого конкретного файла %перед кодированием RLE 
первым проходом по файлу рассчитываются частоты байтов и~выбирается префикс $p$
как самый редкий (в~идеале "--- отсутствующий в~файле) байт;
значение $p$ сохраняется в~заголовке архива.
Собственно кодирование RLE при заданном $p$ "--- второй проход.

\section{Модель источника для «наивного» RLE}\label{sec_rle_n_model}
