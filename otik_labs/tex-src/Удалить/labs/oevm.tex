\setcounter{section}{-1}%

\labworkC{Представление данных в~ЭВМ
(только для тех, кто не~изучал ОргЭВМ!)
}
{Представление  данных в~ЭВМ (для должников)}

\label{lab_oevm}


Студентам, сдавшим ОргЭВМ\,[и\,Асм], 
выполнять \ref{lab_oevm} не нужно; баллы за неё начисляться не будут.

% Не сдавшим ОргЭВМ\,[и\,Асм] (обучающимся по индивидуальному плану либо должникам)
% необходимо выполнить и~защитить  \ref{lab_oevm}.
% %
Должникам, выполнившим \ref{lab_oevm} в~срок, долг по ОргЭВМ\,[и\,Асм] закрывается автоматически (если у~преподавателя лабораторных работ нет доступа "--- сообщите лектору, что долг снят).

\medskip

Максимальная оценка "--- $\bsingle$ баллов; оценка выставляется в~графу «Бонус (прочее)», чтобы компенсировать отставание по {\alllabsotik}.

\taskabsencepenalty[балл]{-1}

\begin{tasks}



% \bottompagebreak
\newcounter{item_lab_types_reinterpret_counter}

\item 
\label{task_lab_func_print16}
\label{task_lab_types_reinterpret}
% \label{\csname task_lab__refsample_for_reglament:\thechapter\endcsname}
Изучите, как интерпретируется одна и~та же область памяти, если она рассматривается как знаковое или беззнаковое целое число, 
а~также "--- как одно и~то же число записывается в~различных системах счисления.

Для этого на языке C/C++ разработайте функцию $\mathrm{void}~ print16(\mathrm{void}~ *p)$, которая печатает для 16-битной области памяти по заданному адресу~$p$:
\begin{enumerate}[label=\asbuk*),ref=\asbuk*]
\item\label{item_lab_types_reinterpret_first}\label{item_lab_types_reinterpret_hex}
целочисленную беззнаковую интерпретацию 
в~шестнадцатеричном %(и~опционально двоичном) 
представлении; 

\item\label{item_lab_types_reinterpret_bin}
целочисленную беззнаковую интерпретацию в~двоичном представлении; 

\item\label{item_lab_types_reinterpret_unsigned_dec} целочисленную беззнаковую интерпретацию 
в~десятичном представлении; 

\item\label{item_lab_types_reinterpret_signed_hex} целочисленную знаковую интерпретацию  в~шестнадцатеричном %(и~опционально двоичном) 
представлении; 

\item\label{item_lab_types_reinterpret_signed_bin}
целочисленную знаковую интерпретацию в~двоичном представлении; 

\item\label{item_lab_types_reinterpret_signed_dec} целочисленную знаковую интерпретацию  в~десятичном представлении.   
\label{item_lab_types_reinterpret_int_last}

% \refstepcounter{enumi}\label{item_lab_types_reinterpret_float}
\setcounter{item_lab_types_reinterpret_counter}{\value{enumi}}
\end{enumerate}


\textbf{Штраф $\mathbf{-2}$ балла,} если количество выводимых цифр двоичного представления отлично от количества бит в~числе (16 для $print16()$) 
либо если количество выводимых цифр шестнадцатеричного представления отлично от количества тетрад в~числе ($\frac{16}{4}=4$ для $print16()$).

\textbf{Бонус $\mathbf{+1}$ балл,} если вывод $print16()$ занимает одну строку (так на экран поместится больше чисел).
\textbf{Бонус $\mathbf{+2}$ балла,} если при этом младшая цифра находится под младшей цифрой предыдущей строки (чего можно добиться заданием ширины поля вывода).


\descrcomment{%
для получения различных интерпретаций одного и~того же участка памяти 
в~C++ можно использовать объединения (\lstinline$union$) или преобразование \emph{указателя $p$ в~указатель на другой тип} оператором \lstinline$reinterpret_cast$ или приведением в~стиле C.
% 
Обратите внимание, что преобразование \emph{значения в~значение} оператором \lstinline!static_cast! или приведением в~стиле C не обеспечивает необходимого эффекта (хотя для целых типов  одного размера $signed \leftrightarrow unsigned$ преобразование значения в~значение чаще всего приводит к~тому же результату, что разыменованный преобразованный указатель%, но уже для плавающей запятой это не так
).

Имена беззнаковых целочисленных типов C++ содержат ключевое слово $unsigned$ (так, беззнаковый тип того же размера, что и~$short$, называется $unsigned~short$).
Имена знаковых целочисленных типов могут содержать ключевое слово $signed$ либо никакого (так, $signed~short$ и~$short$ "--- 
% абсолютные синонимы, даже при декорировании имён функций).
синонимы).

{
Соответственно, 
% если  16"~битный целый тип на используемой платформе "--- short
% представления 
целочисленную беззнаковую интерпретацию памяти по адресу~$p$ для
(\ref{item_lab_types_reinterpret_hex}) и~(\ref{item_lab_types_reinterpret_unsigned_dec})
можно получить, как \lstinline$*(reinterpret_cast<unsigned short *>(p))$,
знаковую для (\ref{item_lab_types_reinterpret_signed_hex}) и~(\ref{item_lab_types_reinterpret_signed_dec}) 
"--- как 
\lstinline$*(reinterpret_cast<short *>(p))$. % (см.~разделы~\ref{sec:cpp-types} и~\ref{sec:cpp-cast}).
\sloppy

}

Шестнадцатеричное и~десятичное представление %в~этом случае 
целых чисел
можно получить, используя различные форматы вывода функции $printf()$ библиотеки libc либо манипуляторы $hex$ и~$dec$ потокового вывода.

Шестнадцатеричный формат вывода для целочисленных переменных соответствует компактной записи двоичного кода, поэтому совпадает для беззнаковой и~знаковой интерпретаций (и~равен беззнаковой интерпретации в~шестнадцатеричной системе счисления).


На вывод чисел с~плавающей запятой манипуляторы $hex$, $oct$, $dec$ никакого влияния не оказывают.

Двоичное (битовое) представление чисел можно получить, используя шаблон
\lstinline$std::bitset<N>$,
где $N$ "--- количество бит в~представлении "--- необходимо задать вручную.
% (необходимо $N = 8 \cdot sizeof $)

}

Проверьте работу функции $print16()$ на %адресах 
16"~битных целочисленных переменных, принимающих следующие значения:
\begin{itemize}
\item минимальное целое 16"~битное значение без знака;
\item максимальное целое 16"~битное значение без знака;
\item минимальное целое 16"~битное значение со знаком;
\item максимальное целое 16"~битное значение со знаком;
\item значение $x$, соответствующее варианту (таблица~\ref{tab_lab_types_variants_xyz});
\item значение $y$, соответствующее варианту (таблица~\ref{tab_lab_types_variants_xyz});
\end{itemize}
(запишите каждое из значений в~16"~битную целочисленную переменную и~передайте её адрес функции). 


Убедитесь, что (\ref{item_lab_types_reinterpret_hex}) и~(\ref{item_lab_types_reinterpret_signed_hex}) "--- одно и~то же шестнадцатеричное представление;
аналогично,
(\ref{item_lab_types_reinterpret_bin}) и~(\ref{item_lab_types_reinterpret_signed_bin}) "--- одно и~то же двоичное представление.
Измените функцию $print16()$ так, чтобы убрать дублирование, и~в~дальнейшем пользуйтесь вариантом без дублей.

% Полученные результаты внесите в~отчёт в~таблицу, 
% каждая строка которой соответствует значению, столбец "--- представлениям  
% (\ref{item_lab_types_reinterpret_first}), (\ref{item_lab_types_reinterpret_bin}), (\ref{item_lab_types_reinterpret_unsigned_dec}), (\ref{item_lab_types_reinterpret_signed_dec}).




\begin{table}[!ht]
\caption{Варианты значений}
\label{tab_lab_types_variants_xyz}

\begin{variants}{lab_digits}
% $x = \hex{0xF1F2F3F4}$, $y = 4$, $z = -7$
% \next
% $x = \hex{0x8A8B8C8D}$, $y = 6$, $z = -3$
%
% 2023
% $x = \hex{0x99887766}$, $y = 5$, $z = -5$
% \next
% $x = \hex{0xAA11BB22}$, $y = 7$, $z = -7$
%
$x = 9$, $y = -9$, $z = \hex{0x88776155}$
\next
$x = 5$, $y = -5$, $z = \hex{0xFF007101}$
\end{variants}
\end{table}



\bottompagebreak
\item 
\label{task_lab_func_print32}
{
Разработайте на языке C/C++ функцию 
% $\mathrm{void}~ print32(\mathrm{void}~ *p)$, 
$print32()$
аналогичную $print16()$ для размера 32 (%
каждое из дублирующихся 
представлений 
"--- 
шестнадцатеричное (\ref{item_lab_types_reinterpret_hex}) и~(\ref{item_lab_types_reinterpret_signed_hex}),
двоичное (\ref{item_lab_types_reinterpret_bin}) и~(\ref{item_lab_types_reinterpret_signed_bin})
"---выводить один раз%
).

Кроме целочисленных интерпретаций, $print32()$ должна рассматривать
память по адресу $p$ как 32-битноe числo с~плавающей запятой («вещественноe») одинарной точности ($float$) и~печатать:
\sloppy

}
\begin{enumerate}[label=\asbuk*),ref=\asbuk*]
\setcounter{enumi}{\value{item_lab_types_reinterpret_counter}}

\item\label{item_lab_types_reinterpret_float_fix}
интерпретацию с~плавающей запятой в~представлении с~фиксированным количеством цифр после запятой; 

\item\label{item_lab_types_reinterpret_float_exp}\label{item_lab_types_reinterpret_total_last}%
интерпретацию с~плавающей запятой в~экспоненциальном представлении.
\end{enumerate}
%
\descrcomment{для вывода в~поток обратите внимание на манипулятор $setprecision()$ и~метод $setf()$.
}


% \begin{enumerate}[label=\asbuk*),ref=\asbuk*]
% \item\label{item_lab_types_reinterpret_float} 16"~битную с~плавающей запятой (одинарной точности) интерпретацию $*p$ в~десятичном представлении. 
% % \item\label{lab_item_lab_types_reinterpret_float_hex} 16"~битную с~плавающей запятой (одинарной точности) интерпретацию $*p$ в~шестнадцатеричном представлении.
% \label{item_lab_types_reinterpret_last}
% \end{enumerate}

% печатающие соответственно 16"~битные и~64"~битные целочисленные  представления (а)--(в),  используя преобразование в~знаковые и~беззнаковые типы соответствующего размера.

Проверьте работу $print32()$ на %адресах 
32"~битных целочисленных переменных, принимающих следующие значения:
\begin{itemize}
\item минимальное целое 32"~битное значение без знака;
\item максимальное целое 32"~битное значение без знака;
\item минимальное целое 32"~битное значение со знаком;
\item максимальное целое 32"~битное значение со знаком;
\item целочисленное значение $x$, соответствующее варианту (таблица~\ref{tab_lab_types_variants_xyz});
\item целочисленное значение $y$, соответствующее варианту (таблица~\ref{tab_lab_types_variants_xyz});
\item целочисленное значение $z$, соответствующее варианту (таблица~\ref{tab_lab_types_variants_xyz});
\end{itemize}
(аналогично $print16()$), а~также переменных  с~плавающей запятой ($float$):
\begin{itemize}
\item $float$-значение $x$, соответствующее варианту;
\item $float$-значение $y$, соответствующее варианту;
\item $float$-значение $z$, соответствующее варианту;
\end{itemize}
значения $x, y, z$ смотрите в~таблице~\ref{tab_lab_types_variants_xyz}.
% %
% Выпишите в~отчёт полученные результаты (дополните таблицу задания \ref{task_lab_types_reinterpret} 
% % столбцом \ref{item_lab_types_reinterpret_float}).
% столбцами (\ref{item_lab_types_reinterpret_float_fix}) и~(\ref{item_lab_types_reinterpret_float_exp}).

% Обратите внимание на отличие структуры целочисленного пре $float$-значений от целочисленных
Сравните структуру целой переменной и~$float$-переменной, имеющих равные значения (в~частности, $x$).
Сравните $float$-значения $x$ и~$y=-x$.

\item \bonus{+2 балла}%
\label{task_lab_func_print64}%
{%
Разработайте на языке C/C++ функцию $print64()$, аналогичную $print32()$ для размера 64 бита 
и, соответственно, числа с~плавающей запятой двойной точности, $double$. 
% Для $float/double$ н
\sloppy

}

Аналогично \ref{task_lab_func_print32}, проверьте $print64()$ на граничных целочисленных 64"~битных значениях, целочисленных значениях $x, y, z$ и~$double$-значениях  $x, y, z$.

\textbf{Штраф $\mathbf{-2}$ балла,} если для $print32()$  либо $print64()$
количество выводимых цифр двоичного представления отлично от количества бит в~числе
либо количество выводимых цифр шестнадцатеричного "--- от количества тетрад.

\textbf{Бонус $\mathbf{+1}$ балл,} если вывод $print32()$ (и~$print64()$, если она реализована) занимает одну строку.
\textbf{Бонус $\mathbf{+2}$ балла,} если при этом младшая цифра находится под младшей цифрой предыдущей строки.



\item 
\label{task_lab_fields}
Разработайте на языке C/C++ функцию, которая упаковывает два беззнаковых числа "--- $k$-битное $v$ и~$(m-k)$-битное $w$ "--- в~одно $m$-битное при помощи побитовых операций и~сдвигов.
Значения $v$ и~$w$ функция получает как параметры; $k$ смотрите в~таблице~\ref{task_lab_fields}.

Рассчитайте минимальные и~максимальные возможные значения  $v$ и~$w$.

\begin{table}[!ht]
\caption{Варианты значений}
\label{task_lab_fields}

\begin{variants}{task_lab_fields}
$k = 5$, $m=16$
\next
$k = 6$, $m=16$
\next
$k = 12$, $m=32$
\end{variants}
\end{table}


Разработайте на языке C/C++ функцию, которая извлекает $v$ и~$w$ из $m$-битного значения. Проверьте корректность её работы (все значения должны выводиться при помощи $print16()$ или $print32()$, в~зависимости от разрядности).






\end{tasks}
