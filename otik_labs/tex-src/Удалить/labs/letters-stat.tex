\labworkC{%Источник без памяти. 
Исследование статистических характеристик исходных текстов (как бинарных файлов, так и~файлов в~формате простого текста). Работа с кодовыми таблицами русского языка}
{Частотность. Кодировки русского языка}

Максимальная оценка обязательной части "--- $\bsingle$ баллов. Максимум графы $%\bdouble = 
\bsingle+\bsingle$ баллов включает бонусное задание \ref{lab_task_markov1_stat}.

\taskabsencepenalty{-3}


\label{lab_letters_stat}
\label{lab_freq}

% Обратите внимание, что это "--- \emph{единственная} лабораторная работа, где
% символ кодирования не обязательно является байтом, а~под исходным текстом не всегда понимается произвольный бинарный файл.
% 
% \medskip


\begin{tasks}


\item 
\label{lab_task_letters_stat}
% В~

Разработайте программу или используйте набор программ (в~частности, это может быть набор скриптов-однострочников, использующий стандартные утилиты GNU/Linux), который по заданному файлу $X$ рассчитывает:
\begin{itemize}
\item длину $n$ файла~$X$ в~символах первичного алфавита $A_1$;
% \item целочисленную частоту $\nu_i$ каждого из символов $a_i \in A_1$ алфавита (общее количество вхождений $a_i$ в~$X$);
\item $\nu_i$ "--- общее количество вхождений каждого из символов $a_i \in A_1$ в~$X$ (целочисленную частоту $a_i$);
\end{itemize}
и~оценивает, считая файл $X$ порождённым источником без памяти:
\begin{itemize}
\item вероятность $p_i$ каждого из символов $a_i \in A_1$;
\item количество информации $I(a_i)$ в~каждом символе $a_i \in A_1$;
\item суммарное количество информации $I(X)$ в~файле~$X$ (не среднее на символ, которое в~$n$ раз меньше, а~именно суммарное!) в~битах и~байтах;
\end{itemize}
символом кодирования, как всегда, является \emph{байт} (с~учётом использования архитектуры x86 это 8 бит, \emph{октет}), первичным алфавитом $A_1$ "--- множество возможных значений байта ($0 \ldots 255$).


Полученные величины необходимо вывести на экран или сохранить в~виде отчёта; 
причём таблица характеристик символов алфавита $a_i \in A_1$ должна выводиться дважды (либо в~программе необходимо предусмотреть пересортировку) "--- отсортированной по алфавиту (по значению $a_i$) и~отсортированной по убыванию частоты $\nu_i$.

Проверьте разработанную программу на файлах различного формата (не только простом тексте; в~том числе и~на бинарных).

\descrcomment{%
Для побайтового чтения используйте $fread()$ или её аналог в~используемом языке программирования.

Для проверки корректности используйте файлы с~заранее известным $I(X)$: для произвольных разных октетов $a$, $b$, $c$, $d$ и~модели без памяти верно
$I(ab) = 2$ бита, $I(abcd) = 4\cdot2 = 8$ бит (1 байт x86) и т.\,п.
}


\item \bonus{+3 балла для пар, обязательное для троек} 
\label{lab_task_letters_stat_utf8}

Разработайте программу, аналогичную \ref{lab_task_letters_stat}, но считающую символом кодирования \emph{печатный символ Unicode,} а~первичным алфавитом $A_1$ "--- множество символов Unicode (строчных букв, заглавных букв, цифр, различных пробельных символов, знаков препинания и~т.\,п) в~файле $X$.

\emph{
Обратите внимание, что это задание и~соответствующее \ref{lab_task_markov1_stat_utf8} "--- \emph{единственные} задания лабораторных работ, где
символ кодирования не обязательно является байтом, а~под исходным текстом не всегда понимается произвольный бинарный файл.
}

Рассчитайте две оценки количества информации в~длинном текстовом файле в~кодировке UTF-8 программами \ref{lab_task_letters_stat} и~\ref{lab_task_letters_stat_utf8}.
Сравните результаты.

\item 
\label{lab_task_letters_stat_ruenc}
{
Рассчитайте частоты появления октетов (\ref{lab_task_letters_stat}) в~файлах, являющихся простым текстом в~различных кодировках (см. «\LABFILETEXTSPATH»).
\sloppy
Определите 4 наиболее частых октета среди всех используемых и 4 наиболее частых октета, не являющихся кодами печатных символов ASCII. Обратите внимание на распределение октетов многобайтовых кодировок.

}


Рассчитайте частоты появления октетов в~файле, соответствующем варианту $N \Mod 9$ в~папке «\LABVARIANTSPATH/L\arabic{section}» (далее "--- файл $Z$). 

Определите, является ли $Z$  простым русскоязычным текстом в одной из стандартных кодировок (один из вариантов представляет собой нерусскоязычный текст); если да "--- определите кодировку.
%и декодируйте в UTF-8.


\item \lbonus[{} "--- источник с~памятью]{$+\bsingle$}
\label{lab_task_markov1_stat}

Разработайте программу, которая по заданному файлу $X$ рассчитывает:
\begin{itemize}
% \item длину $n$ файла~$X$ в~символах первичного алфавита $A_1$;
% % \item $\nu_i$ "--- общее количество вхождений каждого из символов $a_i \in A_1$ в~$X$;
\item $\nu_{ij}$ "--- количество вхождений подстрок $a_j a_i$;
\item $\nu_{*j}$ "--- общее количество вхождений любых двухсимвольных подстрок, начинающихся с~$a_j$ (для всех символов, кроме последнего символа файла, $\nu_{*j} = \nu_j$);
\end{itemize}
и~оценивает, считая файл $X$ порождённым источником Маркова первого порядка:
\begin{itemize}
\item безусловную вероятность $p(a_i)$ каждого из символов $a_i \in A_1$;
\item условную вероятность $p(a_i|a_j)$ каждой пары символов $a_i, a_j \in A_1$;
\item суммарное количество информации $I(X)$ в~файле~$X$ в~битах и~байтах;
\end{itemize}
% символом кодирования, как всегда, является \emph{байт} (с~учётом использования архитектуры x86 "--- октет), первичным алфавитом $A_1$ "--- множество возможных значений байта ($0 \ldots 255$).
% 
% Полученные величины необходимо вывести на экран или сохранить в~виде отчёта.
аналогично~\ref{lab_task_letters_stat}.


Проверьте разработанную программу на файлах различного формата (не только простом тексте; в~том числе и~на бинарных).
%
Сопоставьте результат с~\ref{lab_task_letters_stat}.

\item\bonus{+3 балла}
\label{lab_task_markov1_stat_utf8}
Разработайте программу, аналогичную \ref{lab_task_markov1_stat}, но считающую символом кодирования \emph{печатный символ Unicode,} аналогично \ref{lab_task_letters_stat_utf8}.

Проверьте разработанную программу,
сопоставьте результат с~\ref{lab_task_markov1_stat} и~\ref{lab_task_letters_stat_utf8}.


\end{tasks}

\subsection{О терминах}
\label{codes_termin_text_1}

\textbf{Символ кодирования} в~ТИ есть элемент (квант) качественной информации. В~кодировании (то есть сжатии, защите от помех или шифровании) символом является, как правило, \textbf{байт} (для x86 "--- октет); изредка "--- отдельный бит (символ вторичного алфавита Хаффмана или первичного алфавита Хэмминга) или битовый блок отличной от байта длины; и~никогда "--- печатный символ  ASCII, KOI-8, Unicode etc (технически реализовать можно, как показывают задания~\ref{lab_task_letters_stat_utf8}/\ref{lab_task_markov1_stat_utf8}, но смысла в~этом нет).

\textbf{Текст, строка}  "--- последовательность символов в~указанном выше смысле (в~общем случае бинарный файл и~его фрагменты).
\textbf{Алфавит}  "--- множество всех возможных символов в~указанном выше смысле.


Не обманывайтесь принятой в~кодировании терминологией! 

Кто обманется и~воспользуется функцией $fgetc()$ (или, тем более, $readLine()$, $split()$ и~т.\,п.) где-то, кроме~\ref{lab_task_letters_stat_utf8}/\ref{lab_task_markov1_stat_utf8} "--- минус 2 балла.
