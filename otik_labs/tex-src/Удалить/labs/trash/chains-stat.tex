\labwork{Источник Маркова. Исследование статистических характеристик исходных текстов (как бинарных файлов, так и~файлов в~формате простого текста). 
Простейшие алгоритмы сжатия данных с~учётом контекста}
\label{lab_markov}


\taskabsencepenalty{-2}

\begin{tasks}


\item 
\label{lab_task_markov1_stat}
% В~

Разработайте программу, которая по заданному файлу $X$ рассчитывает:
\begin{itemize}
\item длину $n$ файла~$X$ в~символах первичного алфавита $A_1$;
% \item $\nu_i$ "--- общее количество вхождений каждого из символов $a_i \in A_1$ в~$X$;
\item $\nu_{ij}$ "--- количество вхождений подстрок $a_j a_i$;
\item $\nu_{*j}$ "--- общее количество вхождений любых двухсимвольных подстрок, начинающихся с~$a_j$ (для всех символов, кроме последнего символа файла, $\nu_{*j} = \nu_j$);
\end{itemize}
и~оценивает, считая файл $X$ порождённым источником Маркова первого порядка:
\begin{itemize}
\item безусловную вероятность $p(a_i)$ каждого из символов $a_i \in A_1$;
\item условную вероятность $p(a_i|a_j)$ каждой пары символов $a_i, a_j \in A_1$;
\item оценивает суммарное количество информации $I(X)$ в~файле~$X$ в~битах и~байтах;
\end{itemize}
символом кодирования, как всегда, является \emph{байт} (с~учётом использования архитектуры x86 "--- октет), первичным алфавитом $A_1$ "--- множество возможных значений байта ($0 \ldots 255$).

Полученные величины необходимо вывести на экран или сохранить в~виде отчёта.

Проверьте разработанную программу на файлах различного формата (не только простом тексте; в~том числе и~на бинарных).
%
Сопоставьте результат с~\ref{lab_task_letters_stat}.


\item  \bonus{+2 балла}
\label{lab_task_markovN_stat}
Разработайте программу, аналогичную \ref{lab_task_markov1_stat}, но считающую $X$ порождённым источником Маркова порядка $N$ и, соответственно, рассматривающую $(N+1)$-символьные подстроки и~условные вероятности $p(a_i|a_{j_1}a_{j_2}\ldots a_{j_N})$.

Для упрощения расчёта полагайте $n \gg N$, то есть вероятности первых $N$ символов файла рассчитывайте без учёта контекста.


Проверьте разработанную программу на файлах различного формата и~при различных $N \in [1, 4]$.
Сопоставьте результат при $N=1$ с~\ref{lab_task_markov1_stat}.

\descrcomment{если реализован общий случай, но нет отдельной программы для $N=1$ "--- обязательное задание \ref{lab_task_markov1_stat} не считается пропущенным.
}

% \item 
% \label{lab_task_codec_rle_naive}
% Разработайте программу-кодек, реализующую сжатие/разжатие файла «наивным» алгоритмом RLE (даже однократно повторённый символ $c$ записывается парой $(L, c)$).
% 
% 
% \item 
% \label{lab_task_codec_rle_flagbit}
% Разработайте программу-кодек, реализующую сжатие/разжатие файла алгоритмом RLE с~флаг-битом (цепочки несжатых символов и~сжатые цепочки).
% 
% 
% \item 
% \label{lab_task_codec_rle_symprefix}
% Разработайте программу-кодек, реализующую сжатие/разжатие файла алгоритмом RLE с~односимвольным префиксом (сжатые цепочки отделяются от несжатого теста символом-префиксом).


\item 
\label{lab_task_codec_rle}
Разработайте программу-кодек, реализующую сжатие/разжатие файла алгоритмом RLE
согласно варианту (таблица~\ref{tab_labs_rle_variants}).
\begin{table}[!ht]
\caption{Варианты алгоритмов семейства RLE}
\label{tab_labs_rle_variants}
\begin{variants}
RLE с~флаг-битами (цепочки несжатых символов и~сжатые цепочки)
\next
RLE с~односимвольным префиксом (сжатые цепочки отделяются от несжатого теста символом-префиксом $p$).
Префикс $p$ выбирать для каждого исходного текста $X$ отдельно, исходя из частот символов в~$X$.
\end{variants}

\emph{Упрощённое задание, $-1$ балл (может быть выбрано студентом вместо любого варианта): «наивный» алгоритм RLE (даже однократно повторённый ($L=1$) символ $c$ записывается парой $(L, c)$).}

\end{table}%



Сопоставьте длину сжатых данных с~оценкой количества информации в~исходном файле по марковской модели первого порядка (\ref{lab_task_markov1_stat}).

\item 
\label{lab_task_codec_rle_univ_update}
Доработайте универсальный декодер из задания~\ref{lab_task_decoder_univ} и~кодер из задания~\ref{lab_task_coder_min}
с~учётом реализованных алгоритмов.


\end{tasks}


\subsection{Дополнительные бонусные и~штрафные баллы}

$+3$ балла, если реализованные программы позволяют применить к~файлу последовательно сжатие с~учётом контекста, а~затем сжатие без учёта контекста;
но при этом сжатию без учёта контекста не подвергается, например, добавленная на этапе сжатия с~контекстом сигнатура (то есть сжатие двумя алгоритмами не сводится к~двойному запуску кодера).


