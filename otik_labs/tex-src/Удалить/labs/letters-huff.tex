% \labwork{Частотность. Алгоритмы сжатия данных без учёта контекста (энтропийного сжатия), формирующие разделимые коды}
% \labwork{Источник без памяти. Алгоритмы сжатия данных без учёта контекста (энтропийного сжатия), формирующие разделимые коды}
% \labwork{Источник без памяти. %Кодирование Хаффмана
% Алфавитное префиксное кодирование
% }
\labwork{Сжатие данных без учёта контекста \mbox{(энтропийное сжатие)}}
\label{lab_huff}

Максимальная оценка обязательной части "--- $\bdouble$ баллов. Максимум графы $\bdouble+\bdouble$ включает бонусное задание \ref{lab_task_ac}.

\taskabsencepenalty{-3}


\utask{$\BU{}$}

Используйте демонстрационные программы любой свободной библиотеки для сжатия методом Хаффмана, Шеннона"--~Фано, Шеннона либо целочисленным арифметическим (интервальным) алгоритмом.
Узнайте из документации, какой метод используется и~что является символом кодирования.

Продемонстрируйте работу кодера и~декодера.
Сопоставьте длину сжатых данных с~оценкой количества информации в~исходном файле (\ref{lab_task_letters_stat}).

\descrcomment%
{%
отличие упрощённого задания от полного, реализованного с~помощью библиотеки со свободной лицензией "--- в~управлении заголовком.

В упрощённом задании студент использует демонстрационную программу «как есть»; полное может быть засчитано только в~том случае, если запись/чтение заголовка реализованы студентом и~могут быть изменены.
}


\begin{tasks}

\item 
\label{lab_task_codec_huff}
Разработайте программу-кодек (аналогично \ref{lab_task_intro_codec_echo}), 
реализующую сжатие/разжатие файла алгоритмом Хаффмана.


Сигнатура формата должна совпадать с~выбранной в~\ref{lab_task_intro_signature}.
Если в~формат необходимо внести какие-либо изменения по сравнению с~\ref{lab_task_intro_format} "--- они должны быть описаны в~отчёте, а~номер версии "--- изменён.
% Декодер должен корректно обрабатывать файл, сжат

Также в~отчёте обязательно должны быть описаны:
\begin{itemize}
\item код алгоритма, не равный 0 (если выполняются бонусные задания ниже "--- разным алгоритмам должны соответствовать разные коды);
\item состав информации для декодирования и~формат её хранения в~файле; 
\item принятые при построении дерева уточнения (порядок сортировки при совпадении частот
% , для Шеннона"--~Фано ниже "--- стратегия разбиения при невозможном равенстве веса частей 
и~т.\,п.).
\end{itemize}

% \item 
Сопоставьте длину сжатых данных с~оценкой количества информации в~исходном файле по стационарной модели без памяти (\ref{lab_task_letters_stat}).

\bottompagebreak

\item 
\label{lab_task_decoder_univ}

Разработайте универсальный декодер разработанного формата, который:
\begin{itemize}
\item проверяет сигнатуру на соответствие выбранной в~\ref{lab_task_intro_signature}, при некорректной сигнатуре прекращает работу;
\item при корректной сигнатуре  "--- проверяет номер версии формата: для предыдущих версий формата вызывает свою старую версию, при ещё неизвестном номере версии прекращает работу;
\item при корректных сигнатуре и~версии "--- коды алгоритмов, после чего вызывает соответствующий им декодер из заданий \ref{lab_task_intro_codec_echo} или \ref{lab_task_codec_huff}.
\end{itemize}
В~дальнейшем необходимо будет дополнять анализ при добавлении нового алгоритма (при этом любая модификация "--- например, Хаффман с~другим порядком сортировки при совпадении частот "--- должна оформляться именно как новый алгоритм с~новым кодом).




\item \bonus{+3 балла} 
\label{lab_task_coder_min}

Разработайте «интеллектуальный» кодер, который анализирует суммарный объём $n_{compr}$ сжатых данных и~информации для декодирования \ref{lab_task_codec_huff} 
и,~если $n_{compr} \geqslant n$, записывает в~полученный архив несжатый текст исходного файла (то есть использует вместо кодера \ref{lab_task_codec_huff} кодер \ref{lab_task_intro_codec_echo}; код алгоритма при этом также должен быть 0).



\descrcomment%
{%
сразу предусмотрите флаг для отключения анализа и~принудительного использования заданного алгоритма.
}



\item \lbonus[{} "--- арифметический/интервальный кодек]{$+\bdouble$}
\label{lab_task_ac}

Разработайте программу-кодек (аналогично \ref{lab_task_codec_huff}--\ref{lab_task_coder_min}), 
реализующую сжатие/разжатие файла целочисленным арифметическим (интервальным) алгоритмом.



\item \bonus{+3 балла}
\label{tab_labs_nohuff_old}

Разработайте программу-кодек (аналогично \ref{lab_task_codec_huff}--\ref{lab_task_coder_min}), 
реализующую сжатие/разжатие файла алгоритмом, соответствующим варианту (таблица~\ref{tab_labs_nohuff_variants}).
\begin{table}[!ht]
\caption{Варианты \ref{tab_labs_nohuff_old}
% алгоритмов сжатия файла без учёта контекста (модель без памяти)
}
\label{tab_labs_nohuff_variants}
\begin{variants}{test_tab_labs_nohuff_variants}
алгоритм Шеннона
\next
алгоритм Шеннона"--~Фано
\end{variants}

\end{table}%




\bottompagebreak

\makeatletter
\def\csizefrec#1{\expandafter\@csizefrec\csname c@#1\endcsname}
\def\@csizefrec#1{\ifcase#1\or 32\or 8\or 4\or
Fourth\or Fifth\or Sixth\fi}
\makeatother
\AddEnumerateCounter{\csizefrec}{\@csizefrec}{Second}

\item \bonus{+3 балла для пар, обязательное для троек} 
\label{lab_task_size_with_frec}

Разработайте программу, рассчитывающую для файла длиной до $2^{32}-1$ байт коды Хаффмана в~трёх случаях:
\begin{enumerate}[label=\csizefrec*)]
\item по ненормализованным частотам байтов в~диапазоне $0...2^{32}-1$ (для хранения одного значения необходимо $|\nu_{32}| = 4$ байта);
\item по частотам, приведённым к~диапазону $0...255$ ($|\nu_{8}| = 1$ байт);
\item по частотам, приведённым к~диапазону $0...15$ ($|\nu_4| = \frac{1}{2}$ байта).
\end{enumerate}
Частоты нормализовывать таким образом, чтобы ноль переходил в~$0$, единица в~$1$ (то есть чтобы ненулевые частоты не превращались в нулевые).

Для каждого $|\nu_{i}|$ программа должна рассчитывать:
\begin{itemize}
\item длину $C_i$ сжатых данных файла в~байтах;
\item общую длину $D_i = C_i + 256\cdot|\nu_i|$ данных, необходимых для распаковки (сжатых данных $C_i$ и~массива частот) в~байтах.
\end{itemize}
Собственно архивы со сжатыми данными можно не создавать.

Для файла программа должна рассчитывать $\displaystyle
i^*: ~  D_{i^*} = \min_{i}(D_i)
$.

Для каждого из нескольких различных файлов сравните $C_{32}$, $C_{8}$ и~$C_4$, а~также $D_{32}$, $D_{8}$ и~$D_4$; запишите в~отчёт.
% Какой из перечисленных диапазонов выгоднее использовать (и, соответственно, какую разрядность использовать для частот)?

\medskip

Дополнительно {+1 балл,} если программа перебирает для файла все возможные разрядности $i$ от 3 до 32 бит;
для каждой разрядности:
\begin{itemize}
\item приводит частоты к~диапазону $0...(2^i - 1)$;
\item по приведённым частотам рассчитывает $C_i$ и~$D_i = C_i + 256\cdot\frac{i}{8} = C_i + 32\cdot i$ в~байтах.
\end{itemize}
% Также для рассматриваемого файла программа должна найти значение разрядности $i^*$ с~наименьшей общей длиной 
% $\displaystyle D_{i^*} = \min_{i}(D_i)$.
% Для файла "--- ищет $\displaystyle
% i^*: ~  D_{i^*} = \min_{i}(D_i)
% $.
% % (оптимальную для файла разрядность частот).
% 
% Найдите $i^*$ для разных файлов, сравните и~запишите в~отчёт. 
%
% \medskip
% Постройте график зависимости $D_i$ от $i$ для файла

Какая разрядность $i$, по вашему мнению, лучше подходит для использования (удобнее в~чтении/записи и~при этом даёт достаточно малое $D_i$)?
Предложите способ сохранения массива из 256 $i$-битных частот в~$32\cdot i$ байтов.

\medskip

Дополнительно {+2 балла} за графическое изображение зависимостей $\frac{C_i}{C_{32}}$ и~$\frac{D_i}{D_{32}}$ от $i$ для набора из 10 или более файлов разного типа.
В~итоге должно получиться одно изображение для $C$ (либо со множеством графиков на нём, либо с~«ящиками с~усами») и~одно для $D$, независимо от количества файлов "--- если на каждый файл будет свой график, баллы не начисляются.


\medskip

% \makeatletter
% \def\csizefrec#1{\expandafter\@csizefrec\csname c@#1\endcsname}
% \def\@csizefrec#1{\ifcase#1\or $4$\or $1$\or $\frac{1}{2}$\or
% Fourth\or Fifth\or Sixth\fi}
% \makeatother
% \AddEnumerateCounter{\csizefrec}{\@csizefrec}{Second}
% 
% \item \bonus{+2 балла}
% \label{lab_task_size_with_frec}
% 
% Разработайте программу, рассчитывающую для файла длиной до $2^{32}-1$ байт коды Хаффмана в~трёх случаях:
% \begin{enumerate}[label=\csizefrec*)]
% \item по ненормализованным частотам байтов в~диапазоне $0...2^{32}-1$ (для хранения одного значения необходимо $|\nu_{4}| = 4$ байта);
% \item по частотам, приведённым к~диапазону $0...255$ ($|\nu_{1}| = 1$ байт);
% \item по частотам, приведённым к~диапазону $0...15$ ($|\nu_{\frac{1}{2}}| = \frac{1}{2}$ байта).
% \end{enumerate}
% Частоты нормализовывать таким образом, чтобы ноль переходил в~$0$, единица в~$1$ (то есть чтобы ненулевые частоты не превращались в нулевые).
% 
% Для каждого $|\nu_{i}|$ программа должна рассчитывать:
% \begin{itemize}
% \item длину $C_i$ сжатых данных файла в~байтах;
% \item общую длину $D_i = C_i + 256\cdot|\nu_i|$ данных, необходимых для распаковки (сжатых данных $C_i$ и~массива частот) в~байтах.
% \end{itemize}
% Собственно архивы со сжатыми данными можно не создавать.
% 
% Для каждого из нескольких различных файлов сравните $C_{4}$, $C_{1}$ и~$C_{\frac{1}{2}}$, а~также $D_{4}$, $D_{1}$ и~$D_{\frac{1}{2}}$; запишите в~отчёт.
% Какой из перечисленных диапазонов выгоднее использовать (и, соответственно, какую разрядность $|\nu|$ использовать для частот)?





\end{tasks}


\subsection{Дополнительные бонусные и~штрафные баллы}

$-4$ балла за текстовое представление архива или если кодер обрабатывает только файлы в~текстовом представлении "--- см.~раздел~\ref{codes_termin_text}.

$-2$ балла, если массив частот может для какого-то одного файла иметь длину более 256 байтов.

$-2$ балла, если формат архива не соответствует \ref{lab_task_intro_format} (штраф не начисляется, если в~отчёте описана новая версия формата, которая логичнее исходной).

$-4$ балла, если даже сигнатура не совпадает с~\ref{lab_task_intro_signature}.

$-2$ балла, если ранее разработанный декодер \ref{lab_task_intro_codec_echo} пытается декодировать архив \ref{lab_task_codec_huff}, а~не выдаёт сообщение о~несоответствии алгоритма.


$+1$ балл, если при работе с~несколькими файлами/папками каждый из файлов имеет собственный код алгоритма и~информацию для декодирования (а~в~\ref{lab_task_coder_min} "--- анализируется отдельно).

$+4$ балла, если архив позволяет как включить для каждого файла собственный код алгоритма и~информацию для декодирования, так и~рассмотреть совокупность файлов как единый исходный текст (но при декодировании восстановить исходную структуру файлов).
