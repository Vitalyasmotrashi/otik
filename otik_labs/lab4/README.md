# Лабораторная работа 4: Сжатие данных без учёта контекста (энтропийное сжатие)

## Описание реализованных заданий

### Л4.№1 — Кодек Хаффмана (n1.py)
**Реализация:** Метод Хаффмана с форматом архива из Л3.

**Формат архива:**
- Заголовок (16 байт):
  - 0-5: сигнатура `b"SOBSTV"` (6 байт)
  - 6-7: версия формата `uint16 = 0`
  - 8: код алгоритма `uint8 = 1` (Хаффман)
  - 9-15: исходная длина n (`uint64`, 7 байт)
- Таблица частот (256 байт): нормализованные частоты 0..255 (`uint8`)
- Сжатые данные (побитово упакованные коды Хаффмана)

**Принятые уточнения:**
- При построении дерева: сортировка по частоте, при равных частотах - листья раньше узлов, затем по символу
- Нормализация частот: ненулевые частоты не превращаются в нулевые (min = 1)
- Частоты хранятся как `uint8` (256 байт таблица)

**Использование:**
```bash
# Сжатие
python3 n1.py encode input.txt archive.otik

# Распаковка
python3 n1.py decode archive.otik output.txt
```

**Пример:**
```bash
python3 n1.py encode ../lab2/1.txt 1_huffman.otik
python3 n1.py decode 1_huffman.otik 1_restored.txt
diff ../lab2/1.txt 1_restored.txt
```

---

### Л4.№2 — Анализ разных разрядностей частот (n2.py)
**Реализация:** Программа рассчитывает коды Хаффмана для разных разрядностей частот и сравнивает эффективность.

**Поддерживаемые разрядности:**
- **64 бит**: ненормализованные частоты (таблица 2048 байт)
- **32 бит**: усечённые/нормализованные частоты (таблица 1024 байт)
- **8 бит**: нормализованные к 0..255 (таблица 256 байт)
- **4 бит**: нормализованные к 0..15 (таблица 128 байт)

**Рассчитываемые метрики:**
- **EB**: длина сжатых данных в байтах
- **GB**: общая длина архива (EB + размер таблицы частот)
- **B***: оптимальная разрядность (минимизирующая GB)
- **B****: рекомендуемая фиксированная разрядность = 8 бит

**Использование:**
```bash
# Анализ одного файла
python3 n2.py analyze file.txt

# Анализ с перебором всех разрядностей 1..64 (+2 балла)
python3 n2.py analyze file.txt --all-bits

# Сравнение нескольких файлов
python3 n2.py compare file1.txt file2.txt file3.txt
```

**Пример:**
```bash
python3 n2.py analyze ../lab2/1.txt
python3 n2.py compare ../lab2/*.txt
```

**Выводы:**
- Для малых файлов (< 1KB): оптимально B* = 4 бита (малая таблица)
- Для средних/больших файлов: оптимально B* = 8 бит (баланс размера таблицы и точности)
- Рекомендуемая фиксированная разрядность: **B** = 8 бит**
  - Удобна в чтении/записи (по 1 байту на частоту)
  - Компактная таблица (256 байт)
  - Близка к оптимуму для большинства файлов

---

### Л4.№3 — Универсальный декодер (n3.py)
**Реализация:** Проверяет сигнатуру, версию и код алгоритма, затем вызывает соответствующий декодер.

**Поддерживаемые алгоритмы:**
- **0**: без сжатия (формат из Л3.№1)
- **1**: Хаффман (Л4.№1)
- **2**: Шеннон-Фано (Л4.№6)

**Возможности:**
- Автоматическое определение формата по сигнатуре
- Поддержка старого формата (без поля алгоритма) и нового (с полем)
- Проверка версии и корректная обработка ошибок

**Использование:**
```bash
python3 n3.py decode archive.otik output.txt
```

**Пример:**
```bash
# Декодирование архива Хаффмана
python3 n3.py decode 1_huffman.otik output.txt

# Декодирование архива без сжатия
python3 n3.py decode ../lab3/r.otik output.txt

# Декодирование архива Шеннона-Фано
python3 n3.py decode 1_sf.otik output.txt
```

---

### Л4.№4 — Интеллектуальный кодер (n4.py) [+3 балла]
**Реализация:** Анализирует эффективность сжатия и автоматически выбирает алгоритм.

**Логика выбора:**
- Если `ncompr < n`: использует алгоритм 1 (Хаффман)
- Если `ncompr >= n`: использует алгоритм 0 (без сжатия)

**Дополнительные возможности:**
- Флаг `--force-algorithm=N` для принудительного выбора алгоритма
- Вывод статистики сжатия

**Использование:**
```bash
# Автоматический выбор алгоритма
python3 n4.py encode input.txt archive.otik

# Принудительное использование алгоритма
python3 n4.py encode input.txt archive.otik --force-algorithm=1

# Декодирование (автоматическое определение)
python3 n4.py decode archive.otik output.txt
```

**Пример:**
```bash
# Малый файл (без сжатия выгоднее)
python3 n4.py encode test.txt test_smart.otik

# Большой файл (Хаффман выгоднее)
python3 n4.py encode ../lab2/1.txt 1_smart.otik
```

---

### Л4.№6 — Кодек Шеннона-Фано (n6.py) [+3 балла]
**Реализация:** Метод Шеннона-Фано с тем же форматом, что и Хаффман.

**Формат архива:**
- Аналогичен формату Хаффмана, но `код алгоритма = 2`

**Алгоритм:**
- Сортировка символов по убыванию частот
- Рекурсивное деление на две части с примерно равными суммами частот
- Присвоение кодов: левая половина - 0, правая - 1

**Использование:**
```bash
# Сжатие
python3 n6.py encode input.txt archive.otik

# Распаковка
python3 n6.py decode archive.otik output.txt
```

**Пример:**
```bash
python3 n6.py encode ../lab2/1.txt 1_sf.otik
python3 n6.py decode 1_sf.otik 1_sf_restored.txt
diff ../lab2/1.txt 1_sf_restored.txt
```

---

## Сравнение с Л2.№1

### Теоретическая оценка (Л2.№1):
- Рассчитывается энтропия (количество информации)
- Оценка снизу для длины сжатого текста: `E = ⌈IΣ(Q) / 8⌉`
- Оценка длины архива: `G = E + размер_таблицы`

### Практическая реализация (Л4):
- Точный расчёт длины сжатых данных (с учётом округления длин кодов)
- Реальное сжатие/распаковка файлов
- Оценка влияния разрядности частот на размер архива

### Различия:
- Л2.№1: оценки **снизу** (идеальное сжатие)
- Л4: **реальные** размеры (с учётом дерева Хаффмана и округления)
- Л4 учитывает дробные части длин кодов и их влияние на размер

---

## Набранные баллы

### Основные задания:
- **Л4.№1**: Кодек Хаффмана ✓
- **Л4.№2**: Анализ разных разрядностей ✓
- **Л4.№3**: Универсальный декодер ✓

### Бонусные задания:
- **Л4.№4** (+3 балла): Интеллектуальный кодер ✓
- **Л4.№6** (+3 балла): Кодек Шеннона-Фано ✓

### Потенциальные бонусы:
- (+2 балла): Перебор всех разрядностей 1..64 в n2.py (флаг `--all-bits`)
- (+2 балла): Графики зависимостей E/G от B (требует доработки)

### Избежанные штрафы:
- ✓ Формат соответствует Л3.№2
- ✓ Сигнатура совпадает с Л3.№1
- ✓ Декодер правильно обрабатывает разные алгоритмы
- ✓ Бинарная обработка файлов
- ✓ Таблица частот ≤ 256 байт для алгоритма 1

---

## Тестирование

### Базовое тестирование:
```bash
# Создать тестовый файл
echo "Hello World! This is a test." > test.txt

# Тест n1.py (Хаффман)
python3 n1.py encode test.txt test.otik
python3 n1.py decode test.otik test_out.txt
diff test.txt test_out.txt

# Тест n6.py (Шеннон-Фано)
python3 n6.py encode test.txt test_sf.otik
python3 n6.py decode test_sf.otik test_sf_out.txt
diff test.txt test_sf_out.txt

# Тест n3.py (универсальный декодер)
python3 n3.py decode test.otik test_n3.txt
diff test.txt test_n3.txt

# Тест n4.py (интеллектуальный кодер)
python3 n4.py encode test.txt test_smart.otik
python3 n4.py decode test_smart.otik test_smart_out.txt
diff test.txt test_smart_out.txt

# Тест n2.py (анализ)
python3 n2.py analyze test.txt
```

### Тестирование на реальных файлах:
```bash
# Сравнение алгоритмов
python3 n2.py compare ../lab2/1.txt ../lab2/Керниган*.txt

# Сжатие больших файлов
python3 n4.py encode ../lab2/1.txt 1_compressed.otik
ls -lh ../lab2/1.txt 1_compressed.otik
```

---

## Структура файлов

```
lab4/
├── n1.py              # Л4.№1 - Кодек Хаффмана
├── n2.py              # Л4.№2 - Анализ разрядностей
├── n3.py              # Л4.№3 - Универсальный декодер
├── n4.py              # Л4.№4 - Интеллектуальный кодер
├── n6.py              # Л4.№6 - Кодек Шеннона-Фано
└── README.md          # Это описание
```

---

## Формат представления частот B** = 8 бит

**Предложение:** Использовать массив из 256 байт (`uint8[256]`), где каждый элемент - нормализованная частота байта с индексом i.

**Преимущества:**
- Простота чтения/записи (последовательный блок)
- Компактность (256 байт на весь файл)
- Прямой доступ к частоте любого байта по индексу
- Совместимость с любыми языками программирования

**Представление:**
```
Offset  |  0  1  2  3  4  5  ...  255
Data    | F0 F1 F2 F3 F4 F5 ... F255
```
где Fi - нормализованная частота байта i (0..255)

---

## Примечания

1. Все программы используют бинарную обработку файлов
2. Поддерживается корректная работа с любыми типами файлов (текст, изображения, бинарные)
3. Формат архива расширяемый (поле алгоритма позволяет добавлять новые методы)
4. Универсальный декодер автоматически выбирает подходящий алгоритм распаковки
5. Интеллектуальный кодер минимизирует размер архива автоматически
