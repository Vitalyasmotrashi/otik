Закодировали троичное сообщение C = 012210 (число z = 0,012210 (3)) десятичным числом.

При точных вычислениях z = 0,012210 (3) ∈ [0,012210000...; 0,012210222...) (3) = [0,21399...; 0,21536...) (10).
В качестве приближения можно взять x = 0,2140...(10) или x = 0,2150...(10).

При целочисленной реализации с N = 90 000 (причём масштабировали в 10 раз и только из целого ПИ [0,i; 0,i+1) на [0, N), без аналога «средней половины») 
получилось только 0,2150...(10);
0,2140...(10) не попало в рассматриваемый ПИ.

B = 215 (10)
n = 6 (троичных символов надо декодировать)
N = 90 000 (то же, что и при кодировании, чтобы была одинаковая погрешность).

При декодировании масштабировали так же — только из целого ПИ [0,i; 0,i+1) на [0, N) (в 10 раз), без аналога средней половины.
Получилось C = 0121... вместо 0122... — потеря точности.

Надо было начать масштабировать раньше (используя аналог «средней половины») или вообще как в двоичном кодировании (в 2 раза, ибо 10 делится на 2).


************


Для пересчёта с другим масштабированием используем Octave для ускорения процесса (но не полной автоматизации).
[λ, τ) обозначим [lb, tb)


Инициализация
N = 90000, Nlhm2 = [0, N/2, N/4; N/2, N, 3*N/4]; Nd10=N/10; l = lb = 0, t = tb = N, k=0, i=0,  B=[2 1 5 0 0 0 0], C=[], n=6

Чтение bk, пересчёт [lb, tb), вывод расчётных границ для проверки на попадание в троичную цифру
k=k+1, bk = B(k), d=tb-lb; tb = floor(lb + (bk+1)*d/10); lb = floor(lb + bk*d/10); lbtb=[lb, tb], d=t-l; W3=floor([l, l+d/3, l+2*d/3, t])

Запись ci, пересчёт [l, t), вывод констант для проверки на двоичное кратное масштабирование (и на десятичное некратное)
ci=0; i=i+1; C(i)=ci, d=t-l; t = floor(l + (ci+1)*d/3); l = floor(l + ci*d/3); lt=[l; t], Nlhm2, d=t-l, Nd10

Двоичное кратное масштабирование (как в статьях): L может быть 0, N/4 или N/2
L=0, scale=2, l=(l-L)*scale; lb=(lb-L)*scale; tb=(tb-L)*scale; t=(t-L)*scale; d=t-l; W3=floor([l, l+d/3, l+2*d/3, t]), lbtb=[lb, tb], lt=[l t]
L=N/2, scale=2, l=(l-L)*scale; lb=(lb-L)*scale; tb=(tb-L)*scale; t=(t-L)*scale; d=t-l; W3=floor([l, l+d/3, l+2*d/3, t]), lbtb=[lb, tb], lt=[l t]
L=N/4, scale=2, l=(l-L)*scale; lb=(lb-L)*scale; tb=(tb-L)*scale; t=(t-L)*scale; d=t-l; W3=floor([l, l+d/3, l+2*d/3, t]), lbtb=[lb, tb], lt=[l t]

************

Меня спросили на предыдущем занятии, почему я взяла L=2N/10 при 2N/10 ≤ l && t ≤ 3N/10 во время масштабирования в 10 раз.
Я не нашла аргументов, чем такое L лучше некратного N/10.
Возможно, кратность L и N необязательна?

Двоичное некратное масштабирование: L может быть любым, так возьмём l — допустимо ли это?
L=l, scale=2, l=(l-L)*scale; lb=(lb-L)*scale; tb=(tb-L)*scale; t=(t-L)*scale; d=t-l; W3=floor([l, l+d/3, l+2*d/3, t]), lbtb=[lb, tb], lt=[l t]

Десятичное некратное масштабирование
L=l, scale=10, l=(l-L)*scale; lb=(lb-L)*scale; tb=(tb-L)*scale; t=(t-L)*scale; d=t-l; W3=floor([l, l+d/3, l+2*d/3, t]), lbtb=[lb, tb], lt=[l t]


************


Все сравнения нестрогие, ибо верхняя граница невключаемая!

W3(j) ≤ lb && tb ≤ W3(j+1)  =>  запись ci = j (это если индекс с нуля, а в Octave он с единицы: ci = j-1), l = W3(j), t = W3(j+1)

L ≤ l && t ≤ L+N/2   =>  двоичное масштабирование: все x → (x-L)*2 (если равно 0, N/4 или N/2 — классическое масштабирование, описанное в литературе)

L ≤ l && t ≤ L+N/10  =>  десятичное масштабирование: все x → (x-L)*10

************

0 ≤ l ≤ lb < tb ≤ t ≤ N  — выполняется всегда, проверять при отладке (в середине строгое, ибо при lb=tb ПИ имеет нулевую длину, и это былинный отказ)


